const __create = Object.create;
const __getProtoOf = Object.getPrototypeOf;
const __defProp = Object.defineProperty;
const __getOwnPropertyNames = Object.getOwnPropertyNames;
const __hasOwnProperty = Object.prototype.hasOwnProperty;
const __toESM = (module_, isNodeMode, target) => {
  target = module_ == undefined ? {} : __create(__getProtoOf(module_));
  const to = isNodeMode || !module_ || !module_.__esModule ? __defProp(target, "default", { value: module_, enumerable: true }) : target;
  for (const key of __getOwnPropertyNames(module_))
    if (!__hasOwnProperty.call(to, key))
      __defProp(to, key, {
        get: () => module_[key],
        enumerable: true
      });
  return to;
};
const __commonJS = (callback, module_) => () => (module_ || callback((module_ = { exports: {} }).exports, module_), module_.exports);
const __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
const __esm = (function_, res) => () => (function_ && (res = function_(function_ = 0)), res);

// node_modules/react/cjs/react.development.js
const require_react_development = __commonJS((exports, module) => {
  (function() {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function() {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFunction(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      const warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
    }
    function Component(properties, context, updater) {
      this.props = properties;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(properties, context, updater) {
      this.props = properties;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        const JSCompiler_temporary_const = JSCompiler_inline_result.error;
        const JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temporary_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (type == undefined)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE: {
          return "Fragment";
        }
        case REACT_PROFILER_TYPE: {
          return "Profiler";
        }
        case REACT_STRICT_MODE_TYPE: {
          return "StrictMode";
        }
        case REACT_SUSPENSE_TYPE: {
          return "Suspense";
        }
        case REACT_SUSPENSE_LIST_TYPE: {
          return "SuspenseList";
        }
        case REACT_ACTIVITY_TYPE: {
          return "Activity";
        }
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE: {
            return "Portal";
          }
          case REACT_CONTEXT_TYPE: {
            return (type.displayName || "Context") + ".Provider";
          }
          case REACT_CONSUMER_TYPE: {
            return (type._context.displayName || "Context") + ".Consumer";
          }
          case REACT_FORWARD_REF_TYPE: {
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type === "" ? "ForwardRef" : "ForwardRef(" + type + ")");
            return type;
          }
          case REACT_MEMO_TYPE: {
            return innerType = type.displayName || null, innerType === null ? getComponentNameFromType(type.type) || "Memo" : innerType;
          }
          case REACT_LAZY_TYPE: {
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch {}
          }
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        const name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function getOwner() {
      const dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return new Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        const getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropertyWarningGetter(properties, displayName) {
      function warnAboutAccessingKey() {
        specialPropertyKeyWarningShown || (specialPropertyKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(properties, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementReferenceGetterWithDeprecationWarning() {
      let componentName = getComponentNameFromType(this.type);
      didWarnAboutElementReference[componentName] || (didWarnAboutElementReference[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName === undefined ? null : componentName;
    }
    function ReactElement(type, key, self, source, owner, properties, debugStack, debugTask) {
      self = properties.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props: properties,
        _owner: owner
      };
      (self === undefined ? null : self) === null ? Object.defineProperty(type, "ref", { enumerable: false, value: null }) : Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementReferenceGetterWithDeprecationWarning
      });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, undefined, undefined, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);
      oldElement._store && (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      const escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replaceAll(/[:=]/g, function(match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return typeof element === "object" && element !== null && element.key != undefined ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled": {
          return thenable.value;
        }
        case "rejected": {
          throw thenable.reason;
        }
        default: {
          switch (typeof thenable.status === "string" ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
            thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function(error) {
            thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error);
          })), thenable.status) {
            case "fulfilled": {
              return thenable.value;
            }
            case "rejected": {
              throw thenable.reason;
            }
          }
        }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      let type = typeof children;
      if (type === "undefined" || type === "boolean")
        children = null;
      let invokeCallback = false;
      if (children === null)
        invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number": {
            invokeCallback = true;
            break;
          }
          case "object": {
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE: {
                invokeCallback = true;
                break;
              }
              case REACT_LAZY_TYPE: {
                return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
              }
            }
          }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = nameSoFar === "" ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", childKey != undefined && (escapedPrefix = childKey.replaceAll(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : callback != undefined && (isValidElement(callback) && (callback.key != undefined && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == undefined || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replaceAll(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), nameSoFar !== "" && invokeCallback != undefined && isValidElement(invokeCallback) && invokeCallback.key == undefined && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = nameSoFar === "" ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var index_ = 0;index_ < children.length; index_++)
          nameSoFar = children[index_], type = childKey + getElementKey(nameSoFar, index_), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (index_ = getIteratorFunction(children), typeof index_ === "function")
        for (index_ === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true), children = index_.call(children), index_ = 0;!(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, index_++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (type === "object") {
        if (typeof children.then === "function")
          return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
        array = String(children);
        throw new Error("Objects are not valid as a React child (found: " + (array === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, function_, context) {
      if (children == undefined)
        return children;
      let result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return function_.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (payload._status === -1) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(function(moduleObject) {
          if (payload._status === 0 || payload._status === -1)
            payload._status = 1, payload._result = moduleObject;
        }, function(error) {
          if (payload._status === 0 || payload._status === -1)
            payload._status = 2, payload._result = error;
        });
        payload._status === -1 && (payload._status = 0, payload._result = ctor);
      }
      if (payload._status === 1)
        return ctor = payload._result, ctor === undefined && console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ctor), "default" in ctor || console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ctor), ctor.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      const dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
      if (enqueueTaskImpl === null)
        try {
          const requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch {
          enqueueTaskImpl = function(callback) {
            didWarnAboutMessageChannel === false && (didWarnAboutMessageChannel = true, typeof MessageChannel === "undefined" && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            const channel = new MessageChannel;
            channel.port1.onmessage = callback;
            channel.port2.postMessage();
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && typeof AggregateError === "function" ? new AggregateError(errors) : errors[0];
    }
    function popActScope(previousActQueue, previousActScopeDepth) {
      previousActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = previousActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      let queue = ReactSharedInternals.actQueue;
      if (queue !== null)
        if (queue.length > 0)
          try {
            flushActQueue(queue);
            enqueueTask(function() {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else
          ReactSharedInternals.actQueue = null;
      ReactSharedInternals.thrownErrors.length > 0 ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = true;
        let index_ = 0;
        try {
          for (;index_ < queue.length; index_++) {
            let callback = queue[index_];
            do {
              ReactSharedInternals.didUsePromise = false;
              const continuation = callback(false);
              if (continuation === null) {break;} else
                {
                if (ReactSharedInternals.didUsePromise) {
                  queue[index_] = callback;
                  queue.splice(0, index_);
                  return;
                }
                callback = continuation;
              }
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, index_ + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = false;
        }
      }
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function(publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function(publicInstance) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function(publicInstance) {
        warnNoop(publicInstance, "setState");
      }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != undefined)
        throw new Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    let deprecatedAPIs = {
      isMounted: [
        "isMounted",
        "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
      ],
      replaceState: [
        "replaceState",
        "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
      ]
    }, functionName;
    for (functionName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(functionName) && defineDeprecationWarning(functionName, deprecatedAPIs[functionName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy;
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = true;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      V: null,
      actQueue: null,
      isBatchingLegacy: false,
      didScheduleLegacyUpdate: false,
      didUsePromise: false,
      thrownErrors: [],
      getCurrentStack: null,
      recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    deprecatedAPIs = {
      "react-stack-bottom-frame": function(callStackForError) {
        return callStackForError();
      }
    };
    let specialPropertyKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementReference = {};
    const unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
    const unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof globalThis.window === "object" && typeof globalThis.ErrorEvent === "function") {
        const event = new globalThis.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!globalThis.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = typeof queueMicrotask === "function" ? function(callback) {
      queueMicrotask(function() {
        return queueMicrotask(callback);
      });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function(size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    exports.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunction, forEachContext) {
        mapChildren(children, function() {
          Reflect.apply(forEachFunction, this, arguments);
        }, forEachContext);
      },
      count: function(children) {
        let n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
      const previousActQueue = ReactSharedInternals.actQueue, previousActScopeDepth = actScopeDepth;
      actScopeDepth++;
      let queue = ReactSharedInternals.actQueue = previousActQueue === null ? [] : previousActQueue, didAwaitActCall = false;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (ReactSharedInternals.thrownErrors.length > 0)
        throw popActScope(previousActQueue, previousActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (result !== null && typeof result === "object" && typeof result.then === "function") {
        const thenable = result;
        queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            thenable.then(function(returnValue) {
              popActScope(previousActQueue, previousActScopeDepth);
              if (previousActScopeDepth === 0) {
                try {
                  flushActQueue(queue), enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                } catch (error) {
                  ReactSharedInternals.thrownErrors.push(error);
                }
                if (ReactSharedInternals.thrownErrors.length > 0) {
                  const _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject(_thrownError);
                }
              } else
                resolve(returnValue);
            }, function(error) {
              popActScope(previousActQueue, previousActScopeDepth);
              ReactSharedInternals.thrownErrors.length > 0 ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
            });
          }
        };
      }
      const returnValue$jscomp$0 = result;
      popActScope(previousActQueue, previousActScopeDepth);
      previousActScopeDepth === 0 && (flushActQueue(queue), queue.length > 0 && queueSeveralMicrotasks(function() {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (ReactSharedInternals.thrownErrors.length > 0)
        throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function(resolve, reject) {
          didAwaitActCall = true;
          previousActScopeDepth === 0 ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
          })) : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function(function_) {
      return function() {
        return Reflect.apply(function_, null, arguments);
      };
    };
    exports.captureOwnerStack = function() {
      const getCurrentStack = ReactSharedInternals.getCurrentStack;
      return getCurrentStack === null ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config, children) {
      if (element === null || element === undefined)
        throw new Error("The argument must be a React element, but you passed " + element + ".");
      let properties = assign({}, element.props), key = element.key, owner = element._owner;
      if (config != undefined) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = false;
            break a;
          }
          JSCompiler_inline_result = config.ref !== undefined;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
        for (propertyName in config)
          !hasOwnProperty.call(config, propertyName) || propertyName === "key" || propertyName === "__self" || propertyName === "__source" || propertyName === "ref" && config.ref === undefined || (properties[propertyName] = config[propertyName]);
      }
      var propertyName = arguments.length - 2;
      if (propertyName === 1)
        properties.children = children;
      else if (1 < propertyName) {
        JSCompiler_inline_result = new Array(propertyName);
        for (let index_ = 0;index_ < propertyName; index_++)
          JSCompiler_inline_result[index_] = arguments[index_ + 2];
        properties.children = JSCompiler_inline_result;
      }
      properties = ReactElement(element.type, key, undefined, undefined, owner, properties, element._debugStack, element._debugTask);
      for (key = 2;key < arguments.length; key++)
        owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
      return properties;
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      for (var index_ = 2;index_ < arguments.length; index_++) {
        var node = arguments[index_];
        isValidElement(node) && node._store && (node._store.validated = 1);
      }
      index_ = {};
      node = null;
      if (config != undefined)
        for (propertyName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
          hasOwnProperty.call(config, propertyName) && propertyName !== "key" && propertyName !== "__self" && propertyName !== "__source" && (index_[propertyName] = config[propertyName]);
      let childrenLength = arguments.length - 2;
      if (childrenLength === 1)
        index_.children = children;
      else if (1 < childrenLength) {
        for (var childArray = new Array(childrenLength), _index = 0;_index < childrenLength; _index++)
          childArray[_index] = arguments[_index + 2];
        Object.freeze && Object.freeze(childArray);
        index_.children = childArray;
      }
      if (type && type.defaultProps)
        for (propertyName in childrenLength = type.defaultProps, childrenLength)
          index_[propertyName] === undefined && (index_[propertyName] = childrenLength[propertyName]);
      node && defineKeyPropertyWarningGetter(index_, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      var propertyName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(type, node, undefined, undefined, getOwner(), index_, propertyName ? new Error("react-stack-top-frame") : unknownOwnerDebugStack, propertyName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
      const referenceObject = { current: null };
      Object.seal(referenceObject);
      return referenceObject;
    };
    exports.forwardRef = function(render) {
      render != undefined && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : (typeof render === "function" ? render.length > 0 && render.length !== 2 && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.") : console.error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render));
      render != undefined && render.defaultProps != undefined && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      let elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function(type, compare) {
      type == undefined && console.error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: compare === undefined ? null : compare
      };
      let ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
        }
      });
      return compare;
    };
    exports.startTransition = function(scope) {
      const previousTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      currentTransition._updatedFibers = new Set;
      try {
        const returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        previousTransition === null && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), ReactSharedInternals.T = previousTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      const dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFunction) {
      return resolveDispatcher().useDebugValue(value, formatterFunction);
    };
    exports.useDeferredValue = function(value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, createDeps, update) {
      create == undefined && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      const dispatcher = resolveDispatcher();
      if (typeof update === "function")
        throw new Error("useEffect CRUD overload is not enabled in this build of React.");
      return dispatcher.useEffect(create, createDeps);
    };
    exports.useId = function() {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(reference, create, deps) {
      return resolveDispatcher().useImperativeHandle(reference, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      create == undefined && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      create == undefined && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArgument, init) {
      return resolveDispatcher().useReducer(reducer, initialArgument, init);
    };
    exports.useRef = function(initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.1.0";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  })();
});

// node_modules/react/index.js
const require_react = __commonJS((exports, module) => {
  const react_development = __toESM(require_react_development(), 1);
  if (false) {} else {
    module.exports = react_development;
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
const require_scheduler_development = __commonJS((exports) => {
  (function() {
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        let currentTime = exports.unstable_now();
        startTime = currentTime;
        let hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            const previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue);currentTask !== null && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  const callback = currentTask.callback;
                  if (typeof callback === "function") {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    const continuationCallback = callback(currentTask.expirationTime <= currentTime);
                    currentTime = exports.unstable_now();
                    if (typeof continuationCallback === "function") {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else
                    pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (currentTask === null)
                  {
                  const firstTimer = peek(timerQueue);
                  firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                  hasMoreWork = false;
                }
                else {hasMoreWork = true;}
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = undefined;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    function push(heap, node) {
      let index = heap.length;
      heap.push(node);
      a:
        for (;0 < index; ) {
          const parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else
            break a;
        }
    }
    function peek(heap) {
      return heap.length === 0 ? null : heap[0];
    }
    function pop(heap) {
      if (heap.length === 0)
        return null;
      const first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a:
          for (let index = 0, length = heap.length, halfLength = length >>> 1;index < halfLength; ) {
            const leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else
              break a;
          }
      }
      return first;
    }
    function compare(a, b) {
      const diff = a.sortIndex - b.sortIndex;
      return diff === 0 ? a.id - b.id : diff;
    }
    function advanceTimers(currentTime) {
      for (let timer = peek(timerQueue);timer !== null; ) {
        if (timer.callback === null)
          pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else
          break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (peek(taskQueue) === null)
          {
          const firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
        else {isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());}
    }
    function shouldYieldToHost() {
      return needsPaint ? true : (exports.unstable_now() - startTime < frameInterval ? false : true);
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    exports.unstable_now = undefined;
    if (typeof performance === "object" && typeof performance.now === "function") {
      const localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      const localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = typeof setTimeout === "function" ? setTimeout : null, localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null, localSetImmediate = typeof setImmediate === "undefined" ? null : setImmediate, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if (typeof localSetImmediate === "function")
      var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if (typeof MessageChannel === "undefined") {schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };} else
      {
      const channel = new MessageChannel, port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1000 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3: {
          var priorityLevel = 3;
          break;
        }
        default: {
          priorityLevel = currentPriorityLevel;
        }
      }
      const previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5: {
          break;
        }
        default: {
          priorityLevel = 3;
        }
      }
      const previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      const currentTime = exports.unstable_now();
      typeof options === "object" && options !== null ? (options = options.delay, options = typeof options === "number" && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1: {
          var timeout = -1;
          break;
        }
        case 2: {
          timeout = 250;
          break;
        }
        case 5: {
          timeout = 1_073_741_823;
          break;
        }
        case 4: {
          timeout = 1e4;
          break;
        }
        default: {
          timeout = 5000;
        }
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      const parentPriorityLevel = currentPriorityLevel;
      return function() {
        const previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return Reflect.apply(callback, this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  })();
});

// node_modules/scheduler/index.js
const require_scheduler = __commonJS((exports, module) => {
  const scheduler_development = __toESM(require_scheduler_development(), 1);
  if (false) {} else {
    module.exports = scheduler_development;
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
const require_react_dom_development = __commonJS((exports) => {
  const React = __toESM(require_react(), 1);
  (function() {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      const key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol === "function" && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == undefined ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if (as === "font")
        return "";
      if (typeof input === "string")
        return input === "use-credentials" ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : typeof thing === "string" ? JSON.stringify(thing) : typeof thing === "number" ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      const dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var Internals = {
      d: {
        f: noop,
        r: function() {
          throw new Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
        },
        D: noop,
        C: noop,
        L: noop,
        m: noop,
        X: noop,
        S: noop,
        M: noop
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map === "function" && Map.prototype != undefined && typeof Map.prototype.forEach === "function" && typeof Set === "function" && Set.prototype != undefined && typeof Set.prototype.clear === "function" && typeof Set.prototype.forEach === "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
      const key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
      if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
        throw new Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(function_) {
      const previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, function_)
          return function_();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
      }
    };
    exports.preconnect = function(href, options) {
      typeof href === "string" && href ? (options != undefined && typeof options !== "object" ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : options != undefined && typeof options.crossOrigin !== "string" && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin))) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      typeof href === "string" && (options ? (options = options.crossOrigin, options = typeof options === "string" ? (options === "use-credentials" ? options : "") : undefined) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function(href) {
      if (typeof href !== "string" || !href)
        console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      else if (1 < arguments.length) {
        const options = arguments[1];
        typeof options === "object" && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
      }
      typeof href === "string" && Internals.d.D(href);
    };
    exports.preinit = function(href, options) {
      typeof href === "string" && href ? (options == undefined || typeof options !== "object" ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : options.as !== "style" && options.as !== "script" && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as))) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      if (typeof href === "string" && options && typeof options.as === "string") {
        const as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = typeof options.integrity === "string" ? options.integrity : undefined, fetchPriority = typeof options.fetchPriority === "string" ? options.fetchPriority : undefined;
        as === "style" ? Internals.d.S(href, typeof options.precedence === "string" ? options.precedence : undefined, {
          crossOrigin,
          integrity,
          fetchPriority
        }) : as === "script" && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined
        });
      }
    };
    exports.preinitModule = function(href, options) {
      let encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && options.as !== "script" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
      if (encountered)
        console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);
      else
        switch (encountered = options && typeof options.as === "string" ? options.as : "script", encountered) {
          case "script": {
            break;
          }
          default: {
            encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
          }
        }
      if (typeof href === "string")
        if (typeof options === "object" && options !== null) {
          if (options.as == undefined || options.as === "script")
            encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
              crossOrigin: encountered,
              integrity: typeof options.integrity === "string" ? options.integrity : undefined,
              nonce: typeof options.nonce === "string" ? options.nonce : undefined
            });
        } else
          options == undefined && Internals.d.M(href);
    };
    exports.preload = function(href, options) {
      let encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options == undefined || typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : typeof options.as === "string" && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
      if (typeof href === "string" && typeof options === "object" && options !== null && typeof options.as === "string") {
        encountered = options.as;
        const crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
        Internals.d.L(href, encountered, {
          crossOrigin,
          integrity: typeof options.integrity === "string" ? options.integrity : undefined,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined,
          type: typeof options.type === "string" ? options.type : undefined,
          fetchPriority: typeof options.fetchPriority === "string" ? options.fetchPriority : undefined,
          referrerPolicy: typeof options.referrerPolicy === "string" ? options.referrerPolicy : undefined,
          imageSrcSet: typeof options.imageSrcSet === "string" ? options.imageSrcSet : undefined,
          imageSizes: typeof options.imageSizes === "string" ? options.imageSizes : undefined,
          media: typeof options.media === "string" ? options.media : undefined
        });
      }
    };
    exports.preloadModule = function(href, options) {
      let encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && typeof options.as !== "string" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
      typeof href === "string" && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
        as: typeof options.as === "string" && options.as !== "script" ? options.as : undefined,
        crossOrigin: encountered,
        integrity: typeof options.integrity === "string" ? options.integrity : undefined
      })) : Internals.d.m(href));
    };
    exports.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function(function_, a) {
      return function_(a);
    };
    exports.useFormState = function(action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.1.0";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  })();
});

// node_modules/react-dom/index.js
const require_react_dom = __commonJS((exports, module) => {
  const react_dom_development = __toESM(require_react_dom_development(), 1);
  if (false) {} else {
    module.exports = react_dom_development;
  }
});

// node_modules/react-dom/cjs/react-dom-client.development.js
const require_react_dom_client_development = __commonJS((exports) => {
  const Scheduler = __toESM(require_scheduler(), 1);
  const React = __toESM(require_react(), 1);
  const ReactDOM = __toESM(require_react_dom(), 1);
  (function() {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState;fiber !== null && 0 < id; )
        fiber = fiber.next, id--;
      return fiber;
    }
    function copyWithSetImpl(object, path, index, value) {
      if (index >= path.length)
        return value;
      const key = path[index], updated = isArrayImpl(object) ? [...object] : assign({}, object);
      updated[key] = copyWithSetImpl(object[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(object, oldPath, newPath) {
      if (oldPath.length === newPath.length)
        {
        for (let index_ = 0;index_ < newPath.length - 1; index_++)
          if (oldPath[index_] !== newPath[index_]) {
            console.warn("copyWithRename() expects paths to be the same except for the deepest key");
            return;
          }
        return copyWithRenameImpl(object, oldPath, newPath, 0);
      }
      else {console.warn("copyWithRename() expects paths of the same length");}
    }
    function copyWithRenameImpl(object, oldPath, newPath, index) {
      const oldKey = oldPath[index], updated = isArrayImpl(object) ? [...object] : assign({}, object);
      index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(object[oldKey], oldPath, newPath, index + 1);
      return updated;
    }
    function copyWithDeleteImpl(object, path, index) {
      const key = path[index], updated = isArrayImpl(object) ? [...object] : assign({}, object);
      if (index + 1 === path.length)
        return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
      updated[key] = copyWithDeleteImpl(object[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return false;
    }
    function shouldErrorImpl() {
      return null;
    }
    function warnForMissingKey() {}
    function warnInvalidHookAccess() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function warnInvalidContextAccess() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function noop$2() {}
    function setToSortedString(set) {
      const array = [];
      for (const value of set) {
        array.push(value);
      }
      return array.sort().join(", ");
    }
    function createFiber(tag, pendingProperties, key, mode) {
      return new FiberNode(tag, pendingProperties, key, mode);
    }
    function scheduleRoot(root2, element) {
      root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
    }
    function scheduleRefresh(root2, update) {
      if (resolveFamily !== null) {
        const staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPendingEffects();
        scheduleFibersWithFamiliesRecursively(root2.current, update, staleFamilies);
        flushSyncWork$1();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function isValidContainer(node) {
      return !(!node || node.nodeType !== 1 && node.nodeType !== 9 && node.nodeType !== 11);
    }
    function getNearestMountedFiber(fiber) {
      let node = fiber, nearestMounted = fiber;
      if (fiber.alternate)
        for (;node.return; )
          node = node.return;
      else {
        fiber = node;
        do
          node = fiber, (node.flags & 4098) !== 0 && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return node.tag === 3 ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (fiber.tag === 13) {
        let suspenseState = fiber.memoizedState;
        suspenseState === null && (fiber = fiber.alternate, fiber !== null && (suspenseState = fiber.memoizedState));
        if (suspenseState !== null)
          return suspenseState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      let alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (alternate === null)
          throw new Error("Unable to find node on an unmounted component.");
        return alternate === fiber ? fiber : null;
      }
      for (var a = fiber, b = alternate;; ) {
        const parentA = a.return;
        if (parentA === null)
          break;
        let parentB = parentA.alternate;
        if (parentB === null) {
          b = parentA.return;
          if (b !== null) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child;parentB; ) {
            if (parentB === a)
              return assertIsMounted(parentA), fiber;
            if (parentB === b)
              return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (a.return === b.return)
          {
          for (var didFindChild = false, _child = parentA.child;_child; ) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child;_child; ) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        else {a = parentA, b = parentB;}
        if (a.alternate !== b)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (a.tag !== 3)
        throw new Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      let tag = node.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return node;
      for (node = node.child;node !== null; ) {
        tag = findCurrentHostFiberImpl(node);
        if (tag !== null)
          return tag;
        node = node.sibling;
      }
      return null;
    }
    function getIteratorFunction(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (type == undefined)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE: {
          return "Fragment";
        }
        case REACT_PROFILER_TYPE: {
          return "Profiler";
        }
        case REACT_STRICT_MODE_TYPE: {
          return "StrictMode";
        }
        case REACT_SUSPENSE_TYPE: {
          return "Suspense";
        }
        case REACT_SUSPENSE_LIST_TYPE: {
          return "SuspenseList";
        }
        case REACT_ACTIVITY_TYPE: {
          return "Activity";
        }
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE: {
            return "Portal";
          }
          case REACT_CONTEXT_TYPE: {
            return (type.displayName || "Context") + ".Provider";
          }
          case REACT_CONSUMER_TYPE: {
            return (type._context.displayName || "Context") + ".Consumer";
          }
          case REACT_FORWARD_REF_TYPE: {
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type === "" ? "ForwardRef" : "ForwardRef(" + type + ")");
            return type;
          }
          case REACT_MEMO_TYPE: {
            return innerType = type.displayName || null, innerType === null ? getComponentNameFromType(type.type) || "Memo" : innerType;
          }
          case REACT_LAZY_TYPE: {
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch {}
          }
        }
      return null;
    }
    function getComponentNameFromOwner(owner) {
      return typeof owner.tag === "number" ? getComponentNameFromFiber(owner) : (typeof owner.name === "string" ? owner.name : null);
    }
    function getComponentNameFromFiber(fiber) {
      let type = fiber.type;
      switch (fiber.tag) {
        case 31: {
          return "Activity";
        }
        case 24: {
          return "Cache";
        }
        case 9: {
          return (type._context.displayName || "Context") + ".Consumer";
        }
        case 10: {
          return (type.displayName || "Context") + ".Provider";
        }
        case 18: {
          return "DehydratedFragment";
        }
        case 11: {
          return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || (fiber === "" ? "ForwardRef" : "ForwardRef(" + fiber + ")");
        }
        case 7: {
          return "Fragment";
        }
        case 26:
        case 27:
        case 5: {
          return type;
        }
        case 4: {
          return "Portal";
        }
        case 3: {
          return "Root";
        }
        case 6: {
          return "Text";
        }
        case 16: {
          return getComponentNameFromType(type);
        }
        case 8: {
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        }
        case 22: {
          return "Offscreen";
        }
        case 12: {
          return "Profiler";
        }
        case 21: {
          return "Scope";
        }
        case 13: {
          return "Suspense";
        }
        case 19: {
          return "SuspenseList";
        }
        case 25: {
          return "TracingMarker";
        }
        case 1:
        case 0:
        case 14:
        case 15: {
          if (typeof type === "function")
            return type.displayName || type.name || null;
          if (typeof type === "string")
            return type;
          break;
        }
        case 29: {
          type = fiber._debugInfo;
          if (type != undefined) {
            for (let index_ = type.length - 1;0 <= index_; index_--)
              if (typeof type[index_].name === "string")
                return type[index_].name;
          }
          if (fiber.return !== null)
            return getComponentNameFromFiber(fiber.return);
        }
      }
      return null;
    }
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function requiredContext(c) {
      c === null && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      let nextRootContext = nextRootInstance.nodeType;
      switch (nextRootContext) {
        case 9:
        case 11: {
          nextRootContext = nextRootContext === 9 ? "#document" : "#fragment";
          nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? ((nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone) : HostContextNamespaceNone;
          break;
        }
        default: {
          if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProduction(nextRootInstance, nextRootContext);
          else
            switch (nextRootContext) {
              case "svg": {
                nextRootInstance = HostContextNamespaceSvg;
                break;
              }
              case "math": {
                nextRootInstance = HostContextNamespaceMath;
                break;
              }
              default: {
                nextRootInstance = HostContextNamespaceNone;
              }
            }
        }
      }
      nextRootContext = nextRootContext.toLowerCase();
      nextRootContext = updatedAncestorInfoDevelopment(null, nextRootContext);
      nextRootContext = {
        context: nextRootInstance,
        ancestorInfo: nextRootContext
      };
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      fiber.memoizedState !== null && push(hostTransitionProviderCursor, fiber, fiber);
      const context = requiredContext(contextStackCursor.current);
      let type = fiber.type;
      let nextContext = getChildHostContextProduction(context.context, type);
      type = updatedAncestorInfoDevelopment(context.ancestorInfo, type);
      nextContext = { context: nextContext, ancestorInfo: type };
      context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
    }
    function typeName(value) {
      return typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), false;
      } catch {
        return true;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value))
        return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
    }
    function checkCSSPropertyStringCoercion(value, propertyName) {
      if (willCoercionThrow(value))
        return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propertyName, typeName(value)), testStringCoercion(value);
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value))
        return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
    }
    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined")
        return false;
      const hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled)
        return true;
      if (!hook.supportsFiber)
        return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), true;
      try {
        rendererID = hook.inject(internals), injectedHook = hook;
      } catch (error) {
        console.error("React instrumentation encountered an error: %s.", error);
      }
      return hook.checkDCE ? true : false;
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      typeof log$1 === "function" && unstable_setDisableYieldValue2(newIsStrictMode);
      if (injectedHook && typeof injectedHook.setStrictMode === "function")
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (error) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %s", error));
        }
    }
    function injectProfilingHooks(profilingHooks) {
      injectedProfilingHooks = profilingHooks;
    }
    function markCommitStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function" && injectedProfilingHooks.markCommitStopped();
    }
    function markComponentRenderStarted(fiber) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function" && injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
    function markComponentRenderStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function" && injectedProfilingHooks.markComponentRenderStopped();
    }
    function markRenderStarted(lanes) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function" && injectedProfilingHooks.markRenderStarted(lanes);
    }
    function markRenderStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function" && injectedProfilingHooks.markRenderStopped();
    }
    function markStateUpdateScheduled(fiber, lane) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function" && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return x === 0 ? 32 : 31 - (log2(x) / LN2 | 0) | 0;
    }
    function getLabelForLane(lane) {
      if (lane & 1)
        return "SyncHydrationLane";
      if (lane & 2)
        return "Sync";
      if (lane & 4)
        return "InputContinuousHydration";
      if (lane & 8)
        return "InputContinuous";
      if (lane & 16)
        return "DefaultHydration";
      if (lane & 32)
        return "Default";
      if (lane & 128)
        return "TransitionHydration";
      if (lane & 4_194_048)
        return "Transition";
      if (lane & 62_914_560)
        return "Retry";
      if (lane & 67_108_864)
        return "SelectiveHydration";
      if (lane & 134_217_728)
        return "IdleHydration";
      if (lane & 268_435_456)
        return "Idle";
      if (lane & 536_870_912)
        return "Offscreen";
      if (lane & 1_073_741_824)
        return "Deferred";
    }
    function getHighestPriorityLanes(lanes) {
      const pendingSyncLanes = lanes & 42;
      if (pendingSyncLanes !== 0)
        return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1: {
          return 1;
        }
        case 2: {
          return 2;
        }
        case 4: {
          return 4;
        }
        case 8: {
          return 8;
        }
        case 16: {
          return 16;
        }
        case 32: {
          return 32;
        }
        case 64: {
          return 64;
        }
        case 128: {
          return 128;
        }
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16_384:
        case 32_768:
        case 65_536:
        case 131_072:
        case 262_144:
        case 524_288:
        case 1_048_576:
        case 2_097_152: {
          return lanes & 4_194_048;
        }
        case 4_194_304:
        case 8_388_608:
        case 16_777_216:
        case 33_554_432: {
          return lanes & 62_914_560;
        }
        case 67_108_864: {
          return 67_108_864;
        }
        case 134_217_728: {
          return 134_217_728;
        }
        case 268_435_456: {
          return 268_435_456;
        }
        case 536_870_912: {
          return 536_870_912;
        }
        case 1_073_741_824: {
          return 0;
        }
        default: {
          return console.error("Should have found matching lanes. This is a bug in React."), lanes;
        }
      }
    }
    function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
      let pendingLanes = root2.pendingLanes;
      if (pendingLanes === 0)
        return 0;
      let nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
      root2 = root2.warmLanes;
      let nonIdlePendingLanes = pendingLanes & 134_217_727;
      nonIdlePendingLanes === 0 ? (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, nonIdlePendingLanes === 0 ? (pingedLanes === 0 ? rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))) : nextLanes = getHighestPriorityLanes(pingedLanes)) : nextLanes = getHighestPriorityLanes(nonIdlePendingLanes)) : (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, pendingLanes === 0 ? (pingedLanes &= nonIdlePendingLanes, pingedLanes === 0 ? rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))) : nextLanes = getHighestPriorityLanes(pingedLanes)) : nextLanes = getHighestPriorityLanes(pendingLanes));
      return nextLanes === 0 ? 0 : (wipLanes !== 0 && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === 0 && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || suspendedLanes === 32 && (rootHasPendingCommit & 4_194_048) !== 0) ? wipLanes : nextLanes);
    }
    function checkIfRootIsPrerendering(root2, renderLanes2) {
      return (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2) === 0;
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64: {
          return currentTime + 250;
        }
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16_384:
        case 32_768:
        case 65_536:
        case 131_072:
        case 262_144:
        case 524_288:
        case 1_048_576:
        case 2_097_152: {
          return currentTime + 5000;
        }
        case 4_194_304:
        case 8_388_608:
        case 16_777_216:
        case 33_554_432: {
          return -1;
        }
        case 67_108_864:
        case 134_217_728:
        case 268_435_456:
        case 536_870_912:
        case 1_073_741_824: {
          return -1;
        }
        default: {
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
        }
      }
    }
    function claimNextTransitionLane() {
      const lane = nextTransitionLane;
      nextTransitionLane <<= 1;
      (nextTransitionLane & 4_194_048) === 0 && (nextTransitionLane = 256);
      return lane;
    }
    function claimNextRetryLane() {
      const lane = nextRetryLane;
      nextRetryLane <<= 1;
      (nextRetryLane & 62_914_560) === 0 && (nextRetryLane = 4_194_304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], index_ = 0;31 > index_; index_++)
        laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root2, updateLane) {
      root2.pendingLanes |= updateLane;
      updateLane !== 268_435_456 && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
    }
    function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      const previouslyPendingLanes = root2.pendingLanes;
      root2.pendingLanes = remainingLanes;
      root2.suspendedLanes = 0;
      root2.pingedLanes = 0;
      root2.warmLanes = 0;
      root2.expiredLanes &= remainingLanes;
      root2.entangledLanes &= remainingLanes;
      root2.errorRecoveryDisabledLanes &= remainingLanes;
      root2.shellSuspendCounter = 0;
      const { entanglements, expirationTimes, hiddenUpdates } = root2;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes;0 < remainingLanes; ) {
        let index = 31 - clz32(remainingLanes), lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        const hiddenUpdatesForLane = hiddenUpdates[index];
        if (hiddenUpdatesForLane !== null)
          for (hiddenUpdates[index] = null, index = 0;index < hiddenUpdatesForLane.length; index++) {
            const update = hiddenUpdatesForLane[index];
            update !== null && (update.lane &= -536_870_913);
          }
        remainingLanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root2, spawnedLane, 0);
      suspendedRetryLanes !== 0 && updatedLanes === 0 && root2.tag !== 0 && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
      root2.pendingLanes |= spawnedLane;
      root2.suspendedLanes &= ~spawnedLane;
      const spawnedLaneIndex = 31 - clz32(spawnedLane);
      root2.entangledLanes |= spawnedLane;
      root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1_073_741_824 | entangledLanes & 4_194_090;
    }
    function markRootEntangled(root2, entangledLanes) {
      let rootEntangledLanes = root2.entangledLanes |= entangledLanes;
      for (root2 = root2.entanglements;rootEntangledLanes; ) {
        const index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
        lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2: {
          lane = 1;
          break;
        }
        case 8: {
          lane = 4;
          break;
        }
        case 32: {
          lane = 16;
          break;
        }
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16_384:
        case 32_768:
        case 65_536:
        case 131_072:
        case 262_144:
        case 524_288:
        case 1_048_576:
        case 2_097_152:
        case 4_194_304:
        case 8_388_608:
        case 16_777_216:
        case 33_554_432: {
          lane = 128;
          break;
        }
        case 268_435_456: {
          lane = 134_217_728;
          break;
        }
        default: {
          lane = 0;
        }
      }
      return lane;
    }
    function addFiberToLanesMap(root2, fiber, lanes) {
      if (isDevelopmentToolsPresent)
        for (root2 = root2.pendingUpdatersLaneMap;0 < lanes; ) {
          const index = 31 - clz32(lanes), lane = 1 << index;
          root2[index].add(fiber);
          lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root2, lanes) {
      if (isDevelopmentToolsPresent)
        for (var { pendingUpdatersLaneMap, memoizedUpdaters } = root2;0 < lanes; ) {
          let index = 31 - clz32(lanes);
          root2 = 1 << index;
          index = pendingUpdatersLaneMap[index];
          index.size > 0 && (index.forEach(function(fiber) {
            const alternate = fiber.alternate;
            alternate !== null && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
          }), index.clear());
          lanes &= ~root2;
        }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return DiscreteEventPriority !== 0 && DiscreteEventPriority < lanes ? ContinuousEventPriority !== 0 && ContinuousEventPriority < lanes ? (lanes & 134_217_727) === 0 ? IdleEventPriority : DefaultEventPriority : ContinuousEventPriority : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
      let updatePriority = ReactDOMSharedInternals.p;
      if (updatePriority !== 0)
        return updatePriority;
      updatePriority = window.event;
      return updatePriority === undefined ? DefaultEventPriority : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, function_) {
      const previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, function_();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropertiesKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      let targetInst = targetNode[internalInstanceKey];
      if (targetInst)
        return targetInst;
      for (let parentNode = targetNode.parentNode;parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (targetInst.child !== null || parentNode !== null && parentNode.child !== null)
            for (targetNode = getParentSuspenseInstance(targetNode);targetNode !== null; ) {
              if (parentNode = targetNode[internalInstanceKey])
                return parentNode;
              targetNode = getParentSuspenseInstance(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        const tag = node.tag;
        if (tag === 5 || tag === 6 || tag === 13 || tag === 26 || tag === 27 || tag === 3)
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      const tag = inst.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return inst.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root2) {
      let resources = root2[internalRootNodeResourcesKey];
      resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: new Map, hoistableScripts: new Map });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = true;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] && console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
      registrationNameDependencies[registrationName] = dependencies;
      const lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;
      registrationName === "onDoubleClick" && (possibleRegistrationNames.ondblclick = registrationName);
      for (registrationName = 0;registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProperties(tagName, properties) {
      hasReadOnlyValue[properties.type] || properties.onChange || properties.onInput || properties.readOnly || properties.disabled || properties.value == undefined || (tagName === "select" ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
      properties.onChange || properties.readOnly || properties.disabled || properties.checked == undefined || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
        return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      console.error("Invalid attribute name: `%s`", attributeName);
      return false;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
      if (isAttributeNameSafe(name)) {
        if (!node.hasAttribute(name)) {
          switch (typeof expected) {
            case "symbol":
            case "object": {
              return expected;
            }
            case "function": {
              return expected;
            }
            case "boolean": {
              if (expected === false)
                return expected;
            }
          }
          return expected === undefined ? undefined : null;
        }
        node = node.getAttribute(name);
        if (node === "" && expected === true)
          return true;
        checkAttributeStringCoercion(expected, name);
        return node === "" + expected ? expected : node;
      }
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (value === null)
          node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol": {
              node.removeAttribute(name);
              return;
            }
            case "boolean": {
              const prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                node.removeAttribute(name);
                return;
              }
            }
          }
          checkAttributeStringCoercion(value, name);
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (value === null)
        node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean": {
            node.removeAttribute(name);
            return;
          }
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (value === null)
        node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean": {
            node.removeAttribute(name);
            return;
          }
        }
        checkAttributeStringCoercion(value, name);
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function disabledLog() {}
    function disableLogs() {
      if (disabledDepth === 0) {
        previousLog = console.log;
        previousInfo = console.info;
        previousWarn = console.warn;
        previousError = console.error;
        previousGroup = console.group;
        previousGroupCollapsed = console.groupCollapsed;
        previousGroupEnd = console.groupEnd;
        const properties = {
          configurable: true,
          enumerable: true,
          value: disabledLog,
          writable: true
        };
        Object.defineProperties(console, {
          info: properties,
          log: properties,
          warn: properties,
          error: properties,
          group: properties,
          groupCollapsed: properties,
          groupEnd: properties
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (disabledDepth === 0) {
        const properties = { configurable: true, enumerable: true, writable: true };
        Object.defineProperties(console, {
          log: assign({}, properties, { value: previousLog }),
          info: assign({}, properties, { value: previousInfo }),
          warn: assign({}, properties, { value: previousWarn }),
          error: assign({}, properties, { value: previousError }),
          group: assign({}, properties, { value: previousGroup }),
          groupCollapsed: assign({}, properties, { value: previousGroupCollapsed }),
          groupEnd: assign({}, properties, { value: previousGroupEnd })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
      if (prefix === undefined)
        try {
          throw new Error();
        } catch (error) {
          const match = error.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < error.stack.indexOf(`
    at`) ? " (<anonymous>)" : (-1 < error.stack.indexOf("@") ? "@unknown:0:0" : "");
        }
      return `
` + prefix + name + suffix;
    }
    function describeNativeComponentFrame(function_, construct) {
      if (!function_ || reentry)
        return "";
      let frame = componentFrameCache.get(function_);
      if (frame !== undefined)
        return frame;
      reentry = true;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      let previousDispatcher2 = null;
      previousDispatcher2 = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        const RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw new Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw new Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (error) {
                    var control = error;
                  }
                  Reflect.construct(function_, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (error) {
                    control = error;
                  }
                  function_.call(Fake.prototype);
                }
              } else {
                try {
                  throw new Error();
                } catch (error) {
                  control = error;
                }
                (Fake = function_()) && typeof Fake.catch === "function" && Fake.catch(function() {});
              }
            } catch (error) {
              if (error && control && typeof error.stack === "string")
                return [error.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        let namePropertyDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropertyDescriptor && namePropertyDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        let _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
          for (_RunInRootFrame$Deter = namePropertyDescriptor = 0;namePropertyDescriptor < sampleLines.length && !sampleLines[namePropertyDescriptor].includes("DetermineComponentFrameRoot"); )
            namePropertyDescriptor++;
          for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
            _RunInRootFrame$Deter++;
          if (namePropertyDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
            for (namePropertyDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropertyDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropertyDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
              _RunInRootFrame$Deter--;
          for (;1 <= namePropertyDescriptor && 0 <= _RunInRootFrame$Deter; namePropertyDescriptor--, _RunInRootFrame$Deter--)
            if (sampleLines[namePropertyDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              if (namePropertyDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
                do
                  if (namePropertyDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropertyDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    let _frame = `
` + sampleLines[namePropertyDescriptor].replace(" at new ", " at ");
                    function_.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", function_.displayName));
                    typeof function_ === "function" && componentFrameCache.set(function_, _frame);
                    return _frame;
                  }
                while (1 <= namePropertyDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = function_ ? function_.displayName || function_.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      typeof function_ === "function" && componentFrameCache.set(function_, sampleLines);
      return sampleLines;
    }
    function formatOwnerStack(error) {
      let previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      error = error.stack;
      Error.prepareStackTrace = previousPrepareStackTrace;
      error.startsWith(`Error: react-stack-top-frame
`) && (error = error.slice(29));
      previousPrepareStackTrace = error.indexOf(`
`);
      previousPrepareStackTrace !== -1 && (error = error.slice(previousPrepareStackTrace + 1));
      previousPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
      previousPrepareStackTrace !== -1 && (previousPrepareStackTrace = error.lastIndexOf(`
`, previousPrepareStackTrace));
      if (previousPrepareStackTrace === -1)
        {return "";}
      else
        {error = error.slice(0, previousPrepareStackTrace);}
      return error;
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5: {
          return describeBuiltInComponentFrame(fiber.type);
        }
        case 16: {
          return describeBuiltInComponentFrame("Lazy");
        }
        case 13: {
          return describeBuiltInComponentFrame("Suspense");
        }
        case 19: {
          return describeBuiltInComponentFrame("SuspenseList");
        }
        case 0:
        case 15: {
          return describeNativeComponentFrame(fiber.type, false);
        }
        case 11: {
          return describeNativeComponentFrame(fiber.type.render, false);
        }
        case 1: {
          return describeNativeComponentFrame(fiber.type, true);
        }
        case 31: {
          return describeBuiltInComponentFrame("Activity");
        }
        default: {
          return "";
        }
      }
    }
    function getStackByFiberInDevelopmentAndProduction(workInProgress2) {
      try {
        let info = "";
        do {
          info += describeFiber(workInProgress2);
          const debugInfo = workInProgress2._debugInfo;
          if (debugInfo)
            for (let index_ = debugInfo.length - 1;0 <= index_; index_--) {
              const entry = debugInfo[index_];
              if (typeof entry.name === "string") {
                const JSCompiler_temporary_const = info, environment = entry.env;
                const JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (environment ? " [" + environment + "]" : ""));
                info = JSCompiler_temporary_const + JSCompiler_inline_result;
              }
            }
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2);
        return info;
      } catch (error) {
        return `
Error generating stack: ` + error.message + `
` + error.stack;
      }
    }
    function describeFunctionComponentFrameWithoutLineNumber(function_) {
      return (function_ = function_ ? function_.displayName || function_.name : "") ? describeBuiltInComponentFrame(function_) : "";
    }
    function getCurrentFiberOwnerNameInDevelopmentOrNull() {
      if (current === null)
        return null;
      const owner = current._debugOwner;
      return owner == undefined ? null : getComponentNameFromOwner(owner);
    }
    function getCurrentFiberStackInDevelopment() {
      if (current === null)
        return "";
      let workInProgress2 = current;
      try {
        let info = "";
        workInProgress2.tag === 6 && (workInProgress2 = workInProgress2.return);
        switch (workInProgress2.tag) {
          case 26:
          case 27:
          case 5: {
            info += describeBuiltInComponentFrame(workInProgress2.type);
            break;
          }
          case 13: {
            info += describeBuiltInComponentFrame("Suspense");
            break;
          }
          case 19: {
            info += describeBuiltInComponentFrame("SuspenseList");
            break;
          }
          case 31: {
            info += describeBuiltInComponentFrame("Activity");
            break;
          }
          case 30:
          case 0:
          case 15:
          case 1: {
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type));
            break;
          }
          case 11: {
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type.render));
          }
        }
        for (;workInProgress2; )
          if (typeof workInProgress2.tag === "number") {
            const fiber = workInProgress2;
            workInProgress2 = fiber._debugOwner;
            let debugStack = fiber._debugStack;
            workInProgress2 && debugStack && (typeof debugStack !== "string" && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), debugStack !== "" && (info += `
` + debugStack));
          } else if (workInProgress2.debugStack == undefined) {break;} else
            {
            const ownerStack = workInProgress2.debugStack;
            (workInProgress2 = workInProgress2.owner) && ownerStack && (info += `
` + formatOwnerStack(ownerStack));
          }
        var JSCompiler_inline_result = info;
      } catch (error) {
        JSCompiler_inline_result = `
Error generating stack: ` + error.message + `
` + error.stack;
      }
      return JSCompiler_inline_result;
    }
    function runWithFiberInDEV(fiber, callback, argument0, argument1, argument2, argument3, arg4) {
      const previousFiber = current;
      setCurrentFiber(fiber);
      try {
        return fiber !== null && fiber._debugTask ? fiber._debugTask.run(callback.bind(null, argument0, argument1, argument2, argument3, arg4)) : callback(argument0, argument1, argument2, argument3, arg4);
      } finally {
        setCurrentFiber(previousFiber);
      }
      throw new Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function setCurrentFiber(fiber) {
      ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDevelopment;
      isRendering = false;
      current = fiber;
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined": {
          return value;
        }
        case "object": {
          return checkFormFieldValueStringCoercion(value), value;
        }
        default: {
          return "";
        }
      }
    }
    function isCheckable(element) {
      const type = element.type;
      return (element = element.nodeName) && element.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
    }
    function trackValueOnNode(node) {
      const valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
      checkFormFieldValueStringCoercion(node[valueField]);
      let currentValue = "" + node[valueField];
      if (!node.hasOwnProperty(valueField) && descriptor !== undefined && typeof descriptor.get === "function" && typeof descriptor.set === "function") {
        const { get, set } = descriptor;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get.call(this);
          },
          set: function(value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
          },
          stopTracking: function() {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      node._valueTracker || (node._valueTracker = trackValueOnNode(node));
    }
    function updateValueIfChanged(node) {
      if (!node)
        return false;
      const tracker = node._valueTracker;
      if (!tracker)
        return true;
      const lastValue = tracker.getValue();
      let value = "";
      node && (value = isCheckable(node) ? (node.checked ? "true" : "false") : node.value);
      node = value;
      return node === lastValue ? false : (tracker.setValue(node), true);
    }
    function getActiveElement(document_) {
      document_ = document_ || (typeof document === "undefined" ? undefined : document);
      if (document_ === undefined)
        return null;
      try {
        return document_.activeElement || document_.body;
      } catch {
        return document_.body;
      }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replaceAll(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
        return "\\" + ch.charCodeAt(0).toString(16) + " ";
      });
    }
    function validateInputProperties(element, properties) {
      properties.checked === undefined || properties.defaultChecked === undefined || didWarnCheckedDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevelopmentOrNull() || "A component", properties.type), didWarnCheckedDefaultChecked = true);
      properties.value === undefined || properties.defaultValue === undefined || didWarnValueDefaultValue$1 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevelopmentOrNull() || "A component", properties.type), didWarnValueDefaultValue$1 = true);
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      type != undefined && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean" ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
      if (value == undefined)
        {type !== "submit" && type !== "reset" || element.removeAttribute("value");}
      else
        {if (type === "number") {
          if (value === 0 && element.value === "" || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));}
      value == undefined ? (defaultValue == undefined ? lastDefaultValue != undefined && element.removeAttribute("value") : setDefaultValue(element, type, getToStringValue(defaultValue))) : setDefaultValue(element, type, getToStringValue(value));
      checked == undefined && defaultChecked != undefined && (element.defaultChecked = Boolean(defaultChecked));
      checked != undefined && (element.checked = checked && typeof checked !== "function" && typeof checked !== "symbol");
      name != undefined && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean" ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
      type != undefined && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean" && (checkAttributeStringCoercion(type, "type"), element.type = type);
      if (value != undefined || defaultValue != undefined) {
        if (!(type !== "submit" && type !== "reset" || value !== undefined && value !== null))
          return;
        defaultValue = defaultValue == undefined ? "" : "" + getToStringValue(defaultValue);
        value = value == undefined ? defaultValue : "" + getToStringValue(value);
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = checked == undefined ? defaultChecked : checked;
      checked = typeof checked !== "function" && typeof checked !== "symbol" && Boolean(checked);
      element.checked = isHydrating2 ? element.checked : Boolean(checked);
      element.defaultChecked = Boolean(checked);
      name != undefined && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean" && (checkAttributeStringCoercion(name, "name"), element.name = name);
    }
    function setDefaultValue(node, type, value) {
      type === "number" && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function validateOptionProperties(element, properties) {
      properties.value == undefined && (typeof properties.children === "object" && properties.children !== null ? React.Children.forEach(properties.children, function(child) {
        child == undefined || typeof child === "string" || typeof child === "number" || typeof child === "bigint" || didWarnInvalidChild || (didWarnInvalidChild = true, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."));
      }) : properties.dangerouslySetInnerHTML == undefined || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")));
      properties.selected == undefined || didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = true);
    }
    function getDeclarationErrorAddendum() {
      const ownerName = getCurrentFiberOwnerNameInDevelopmentOrNull();
      return ownerName ? `

Check the render method of \`` + ownerName + "`." : "";
    }
    function updateOptions(node, multiple, propertyValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var index_ = 0;index_ < propertyValue.length; index_++)
          multiple["$" + propertyValue[index_]] = true;
        for (propertyValue = 0;propertyValue < node.length; propertyValue++)
          index_ = multiple.hasOwnProperty("$" + node[propertyValue].value), node[propertyValue].selected !== index_ && (node[propertyValue].selected = index_), index_ && setDefaultSelected && (node[propertyValue].defaultSelected = true);
      } else {
        propertyValue = "" + getToStringValue(propertyValue);
        multiple = null;
        for (index_ = 0;index_ < node.length; index_++) {
          if (node[index_].value === propertyValue) {
            node[index_].selected = true;
            setDefaultSelected && (node[index_].defaultSelected = true);
            return;
          }
          multiple !== null || node[index_].disabled || (multiple = node[index_]);
        }
        multiple !== null && (multiple.selected = true);
      }
    }
    function validateSelectProperties(element, properties) {
      for (element = 0;element < valuePropertyNames.length; element++) {
        const propName = valuePropertyNames[element];
        if (properties[propName] != undefined) {
          const propNameIsArray = isArrayImpl(properties[propName]);
          properties.multiple && !propNameIsArray ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !properties.multiple && propNameIsArray && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
        }
      }
      properties.value === undefined || properties.defaultValue === undefined || didWarnValueDefaultValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnValueDefaultValue = true);
    }
    function validateTextareaProperties(element, props) {
      props.value === undefined || props.defaultValue === undefined || didWarnValDefaultVal || (console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevelopmentOrNull() || "A component"), didWarnValDefaultVal = true);
      props.children != undefined && props.value == undefined && console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
    }
    function updateTextarea(element, value, defaultValue) {
      if (value != undefined && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), defaultValue == undefined)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = defaultValue == undefined ? "" : "" + getToStringValue(defaultValue);
    }
    function initTextarea(element, value, defaultValue, children) {
      if (value == undefined) {
        if (children != undefined) {
          if (defaultValue != undefined)
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArrayImpl(children)) {
            if (1 < children.length)
              throw new Error("<textarea> can only have at most one child.");
            children = children[0];
          }
          defaultValue = children;
        }
        defaultValue == undefined && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && children !== "" && children !== null && (element.value = children);
    }
    function findNotableNode(node, indent) {
      return node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5: {
          return fiber.type;
        }
        case 16: {
          return "Lazy";
        }
        case 13: {
          return "Suspense";
        }
        case 19: {
          return "SuspenseList";
        }
        case 0:
        case 15: {
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        }
        case 11: {
          return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
        }
        case 1: {
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        }
        default: {
          return null;
        }
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? (8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}') : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
    }
    function describeTextDiff(clientText, serverProperties, indent) {
      const maxLength = 120 - 2 * indent;
      if (serverProperties === null)
        return added(indent) + describeTextNode(clientText, maxLength) + `
`;
      if (typeof serverProperties === "string") {
        for (var firstDiff = 0;firstDiff < serverProperties.length && firstDiff < clientText.length && serverProperties.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++)
          ;
        firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProperties = "..." + serverProperties.slice(firstDiff - 8));
        return added(indent) + describeTextNode(clientText, maxLength) + `
` + removed(indent) + describeTextNode(serverProperties, maxLength) + `
`;
      }
      return indentation(indent) + describeTextNode(clientText, maxLength) + `
`;
    }
    function objectName(object) {
      return Object.prototype.toString.call(object).replace(/^\[object (.*)]$/, function(m, p0) {
        return p0;
      });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string": {
          return value = JSON.stringify(value), value.length > maxLength ? (5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."') : value;
        }
        case "object": {
          if (value === null)
            return "null";
          if (isArrayImpl(value))
            return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE)
            return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
          let name = objectName(value);
          if (name === "Object") {
            name = "";
            maxLength -= 2;
            for (let propertyName in value)
              if (value.hasOwnProperty(propertyName)) {
                let jsonPropName = JSON.stringify(propertyName);
                jsonPropName !== '"' + propertyName + '"' && (propertyName = jsonPropName);
                maxLength -= propertyName.length - 2;
                jsonPropName = describeValue(value[propertyName], Math.min(15, maxLength));
                maxLength -= jsonPropName.length;
                if (0 > maxLength) {
                  name += name === "" ? "..." : ", ...";
                  break;
                }
                name += (name === "" ? "" : ",") + propertyName + ":" + jsonPropName;
              }
            return "{" + name + "}";
          }
          return name;
        }
        case "function": {
          return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
        }
        default: {
          return String(value);
        }
      }
    }
    function describePropertyValue(value, maxLength) {
      return typeof value !== "string" || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      let remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
      for (propName in props)
        if (props.hasOwnProperty(propName) && propName !== "children") {
          const propValue = describePropertyValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
          remainingRowLength -= propName.length + propValue.length + 2;
          properties.push(propName + "=" + propValue);
        }
      return properties.length === 0 ? rowPrefix + "<" + type + `>
` : (0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + `>
` : rowPrefix + "<" + type + `
` + rowPrefix + "  " + properties.join(`
` + rowPrefix + "  ") + `
` + rowPrefix + `>
`);
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      let properties = "", remainingServerProperties = assign({}, serverObject), propName;
      for (propName in clientObject)
        if (clientObject.hasOwnProperty(propName)) {
          delete remainingServerProperties[propName];
          let maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
          serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + `
`, properties += removed(indent) + propName + ": " + maxLength + `
`) : properties += added(indent) + propName + ": " + clientPropValue + `
`;
        }
      for (const _propName in remainingServerProperties)
        remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + `
`);
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      let content = "", serverPropNames = new Map;
      for (propName$jscomp$0 in serverProps)
        serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
      if (serverPropNames.size === 1 && serverPropNames.has("children"))
        content += describeExpandedElement(type, clientProps, indentation(indent));
      else {
        for (const _propName2 in clientProps)
          if (clientProps.hasOwnProperty(_propName2) && _propName2 !== "children") {
            let maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
            if (serverPropName === undefined) {content += indentation(indent + 1) + _propName2 + "=" + describePropertyValue(clientProps[_propName2], maxLength$jscomp$0) + `
`;} else
              {
              serverPropNames.delete(_propName2.toLowerCase());
              var propName$jscomp$0 = clientProps[_propName2];
              serverPropName = serverProps[serverPropName];
              const clientPropValue = describePropertyValue(propName$jscomp$0, maxLength$jscomp$0);
              maxLength$jscomp$0 = describePropertyValue(serverPropName, maxLength$jscomp$0);
              typeof propName$jscomp$0 === "object" && propName$jscomp$0 !== null && typeof serverPropName === "object" && serverPropName !== null && objectName(propName$jscomp$0) === "Object" && objectName(serverPropName) === "Object" && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + `={{
` + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + `}}
` : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + `
`, content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + `
`);
            }
          }
        for (const propName of serverPropNames) {
          if (propName !== "children") {
            const maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content += removed(indent + 1) + propName + "=" + describePropertyValue(serverProps[propName], maxLength) + `
`;
          }
        }
        content = content === "" ? indentation(indent) + "<" + type + `>
` : indentation(indent) + "<" + type + `
` + content + indentation(indent) + `>
`;
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if (typeof type === "string" || typeof type === "number" || typeof type === "bigint") {
        serverPropNames = "";
        if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
          serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
        content = type == undefined ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, undefined, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      let type = describeFiberType(fiber);
      if (type === null) {
        type = "";
        for (fiber = fiber.child;fiber; )
          type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
        return type;
      }
      return indentation(indent) + "<" + type + `>
`;
    }
    function describeNode(node, indent) {
      let skipToNode = findNotableNode(node, indent);
      if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode))
        return indentation(indent) + `...
` + describeNode(skipToNode, indent + 1);
      skipToNode = "";
      let debugInfo = node.fiber._debugInfo;
      if (debugInfo)
        for (var i = 0;i < debugInfo.length; i++) {
          var serverComponentName = debugInfo[i].name;
          typeof serverComponentName === "string" && (skipToNode += indentation(indent) + "<" + serverComponentName + `>
`, indent++);
        }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (node.fiber.tag === 6)
        debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
      else if (serverComponentName = describeFiberType(node.fiber), serverComponentName !== null)
        if (node.serverProps === undefined) {
          debugInfo = indent;
          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
          for (propName in i)
            if (i.hasOwnProperty(propName) && propName !== "children") {
              const propValue = describePropertyValue(i[propName], 15);
              maxLength -= propName.length + propValue.length + 2;
              if (0 > maxLength) {
                content += " ...";
                break;
              }
              content += " " + propName + "=" + propValue;
            }
          debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + `>
`;
          indent++;
        } else
          node.serverProps === null ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : (typeof node.serverProps === "string" ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++));
      var propName = "";
      i = node.fiber.child;
      for (serverComponentName = 0;i && serverComponentName < node.children.length; )
        maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
      i && node.children.length > 0 && (propName += indentation(indent) + `...
`);
      i = node.serverTail;
      node.serverProps === null && indent--;
      for (node = 0;node < i.length; node++)
        serverComponentName = i[node], propName = typeof serverComponentName === "string" ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + `
`) : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return `

` + describeNode(rootNode, 0);
      } catch {
        return "";
      }
    }
    function describeAncestors(ancestor, child, properties) {
      for (var fiber = child, node = null, distanceFromLeaf = 0;fiber; )
        fiber === ancestor && (distanceFromLeaf = 0), node = {
          fiber,
          children: node === null ? [] : [node],
          serverProps: fiber === child ? properties : (fiber === ancestor ? null : undefined),
          serverTail: [],
          distanceFromLeaf
        }, distanceFromLeaf++, fiber = fiber.return;
      return node === null ? "" : describeDiff(node).replaceAll(/^[+-]/gm, ">");
    }
    function updatedAncestorInfoDevelopment(oldInfo, tag) {
      const ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDevelopment), info = { tag };
      inScopeTags.includes(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
      buttonScopeTags.has(tag) && (ancestorInfo.pTagInButtonScope = null);
      specialTags.includes(tag) && tag !== "address" && tag !== "div" && tag !== "p" && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
      ancestorInfo.current = info;
      tag === "form" && (ancestorInfo.formTag = info);
      tag === "a" && (ancestorInfo.aTagInScope = info);
      tag === "button" && (ancestorInfo.buttonTagInScope = info);
      tag === "nobr" && (ancestorInfo.nobrTagInScope = info);
      tag === "p" && (ancestorInfo.pTagInButtonScope = info);
      tag === "li" && (ancestorInfo.listItemTagAutoclosing = info);
      if (tag === "dd" || tag === "dt")
        ancestorInfo.dlItemTagAutoclosing = info;
      tag === "#document" || tag === "html" ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
      oldInfo !== null || tag !== "#document" && tag !== "html" && tag !== "body" ? ancestorInfo.implicitRootScope === true && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
      return ancestorInfo;
    }
    function isTagValidWithParent(tag, parentTag, implicitRootScope) {
      switch (parentTag) {
        case "select": {
          return tag === "hr" || tag === "option" || tag === "optgroup" || tag === "script" || tag === "template" || tag === "#text";
        }
        case "optgroup": {
          return tag === "option" || tag === "#text";
        }
        case "option": {
          return tag === "#text";
        }
        case "tr": {
          return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
        }
        case "tbody":
        case "thead":
        case "tfoot": {
          return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
        }
        case "colgroup": {
          return tag === "col" || tag === "template";
        }
        case "table": {
          return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
        }
        case "head": {
          return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
        }
        case "html": {
          if (implicitRootScope)
            break;
          return tag === "head" || tag === "body" || tag === "frameset";
        }
        case "frameset": {
          return tag === "frame";
        }
        case "#document": {
          if (!implicitRootScope)
            return tag === "html";
        }
      }
      switch (tag) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6": {
          return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
        }
        case "rp":
        case "rt": {
          return !impliedEndTags.includes(parentTag);
        }
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr": {
          return parentTag == undefined;
        }
        case "head": {
          return implicitRootScope || parentTag === null;
        }
        case "html": {
          return implicitRootScope && parentTag === "#document" || parentTag === null;
        }
        case "body": {
          return implicitRootScope && (parentTag === "#document" || parentTag === "html") || parentTag === null;
        }
      }
      return true;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
      switch (tag) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6": {
          return ancestorInfo.pTagInButtonScope;
        }
        case "form": {
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        }
        case "li": {
          return ancestorInfo.listItemTagAutoclosing;
        }
        case "dd":
        case "dt": {
          return ancestorInfo.dlItemTagAutoclosing;
        }
        case "button": {
          return ancestorInfo.buttonTagInScope;
        }
        case "a": {
          return ancestorInfo.aTagInScope;
        }
        case "nobr": {
          return ancestorInfo.nobrTagInScope;
        }
      }
      return null;
    }
    function findAncestor(parent, tagName) {
      for (;parent; ) {
        switch (parent.tag) {
          case 5:
          case 26:
          case 27: {
            if (parent.type === tagName)
              return parent;
          }
        }
        parent = parent.return;
      }
      return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfoDevelopment;
      let parentInfo = ancestorInfo.current;
      ancestorInfo = (parentInfo = isTagValidWithParent(childTag, parentInfo && parentInfo.tag, ancestorInfo.implicitRootScope) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
      ancestorInfo = parentInfo || ancestorInfo;
      if (!ancestorInfo)
        return true;
      const ancestorTag = ancestorInfo.tag;
      ancestorInfo = String(Boolean(parentInfo)) + "|" + childTag + "|" + ancestorTag;
      if (didWarn[ancestorInfo])
        return false;
      didWarn[ancestorInfo] = true;
      const ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = ancestorInfo !== null && ancestor !== null ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
      parentInfo ? (parentInfo = "", ancestorTag === "table" && childTag === "tr" && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(`In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`, tagDisplayName, ancestorTag, parentInfo, ancestorDescription)) : console.error(`In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`, tagDisplayName, ancestorTag, ancestorDescription);
      ancestorInfo && (childTag = ancestorInfo.return, ancestor === null || childTag === null || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
        console.error(`<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`, ancestorTag, tagDisplayName);
      }));
      return false;
    }
    function validateTextNesting(childText, parentTag, implicitRootScope) {
      if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
        return true;
      implicitRootScope = "#text|" + parentTag;
      if (didWarn[implicitRootScope])
        return false;
      didWarn[implicitRootScope] = true;
      const ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
      implicitRootScope = implicitRootScope !== null && ancestor !== null ? describeAncestors(ancestor, implicitRootScope, implicitRootScope.tag === 6 ? null : { children: null }) : "";
      /\S/.test(childText) ? console.error(`In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`, parentTag, implicitRootScope) : console.error(`In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`, parentTag, implicitRootScope);
      return false;
    }
    function setTextContent(node, text) {
      if (text) {
        const firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    function camelize(string) {
      return string.replaceAll(hyphenPattern, function(_, character) {
        return character.toUpperCase();
      });
    }
    function setValueForStyle(style2, styleName, value) {
      const isCustomProperty = styleName.indexOf("--") === 0;
      isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error("Unsupported style property %s. Did you mean %s?", styleName, camelize(styleName.replace(msPattern, "ms-")))) : (badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", styleName, styleName.charAt(0).toUpperCase() + styleName.slice(1))) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, styleName, value.replace(badStyleValueWithSemicolonPattern, "")))), typeof value === "number" && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error("`NaN` is an invalid value for the `%s` css style property.", styleName)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error("`Infinity` is an invalid value for the `%s` css style property.", styleName))));
      value == undefined || typeof value === "boolean" || value === "" ? isCustomProperty ? style2.setProperty(styleName, "") : styleName === "float" ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : typeof value !== "number" || value === 0 || unitlessNumbers.has(styleName) ? styleName === "float" ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
    }
    function setValueForStyles(node, styles, previousStyles) {
      if (styles != undefined && typeof styles !== "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      styles && Object.freeze(styles);
      node = node.style;
      if (previousStyles == undefined) {for (expandedUpdates in styles)
          styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);} else
        {
        if (styles) {
          var expandedUpdates = {};
          if (previousStyles) {
            for (var key in previousStyles)
              if (previousStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                for (var longhands = shorthandToLonghand[key] || [key], i = 0;i < longhands.length; i++)
                  expandedUpdates[longhands[i]] = key;
          }
          for (var _key in styles)
            if (styles.hasOwnProperty(_key) && (!previousStyles || previousStyles[_key] !== styles[_key]))
              for (key = shorthandToLonghand[_key] || [_key], longhands = 0;longhands < key.length; longhands++)
                expandedUpdates[key[longhands]] = _key;
          _key = {};
          for (var key$jscomp$0 in styles)
            for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0;longhands < key.length; longhands++)
              _key[key[longhands]] = key$jscomp$0;
          key$jscomp$0 = {};
          for (var _key2 in expandedUpdates)
            if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
              key$jscomp$0[i] = true;
              i = console;
              const value = styles[key];
              i.error.call(i, "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", value == undefined || typeof value === "boolean" || value === "" ? "Removing" : "Updating", key, longhands);
            }
        }
        for (const styleName in previousStyles)
          !previousStyles.hasOwnProperty(styleName) || styles != undefined && styles.hasOwnProperty(styleName) || (styleName.indexOf("--") === 0 ? node.setProperty(styleName, "") : (styleName === "float" ? node.cssFloat = "" : node[styleName] = ""));
        for (const _styleName in styles)
          _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && previousStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
      }
    }
    function isCustomElement(tagName) {
      if (!tagName.includes("-"))
        return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph": {
          return false;
        }
        default: {
          return true;
        }
      }
    }
    function getAttributeAlias(name) {
      return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
      if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
        return true;
      if (rARIACamel$1.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == undefined)
          return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = true;
        if (name !== tagName)
          return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = true;
      }
      if (rARIA$1.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == undefined)
          return warnedProperties$1[name] = true, false;
        name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = true);
      }
      return true;
    }
    function validateProperties$2(type, properties) {
      let invalidProps = [], key;
      for (key in properties)
        validateProperty$1(type, key) || invalidProps.push(key);
      properties = invalidProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      invalidProps.length === 1 ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", properties, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", properties, type);
    }
    function validateProperty(tagName, name, value, eventRegistry) {
      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
        return true;
      let lowerCasedName = name.toLowerCase();
      if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
        return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = true;
      if (typeof value === "function" && (tagName === "form" && name === "action" || tagName === "input" && name === "formAction" || tagName === "button" && name === "formAction"))
        return true;
      if (eventRegistry != undefined) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
          return true;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
        if (eventRegistry != undefined)
          return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = true;
        if (EVENT_NAME_REGEX.test(name))
          return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = true;
      } else if (EVENT_NAME_REGEX.test(name))
        return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = true;
      if (rARIA.test(name) || rARIACamel.test(name))
        return true;
      if (lowerCasedName === "innerhtml")
        return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = true;
      if (lowerCasedName === "aria")
        return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = true;
      if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string")
        return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = true;
      if (typeof value === "number" && isNaN(value))
        return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = true;
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
          return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = true;
      } else if (name !== lowerCasedName)
        return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = true;
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref": {
          return true;
        }
        case "innerText":
        case "textContent": {
          return true;
        }
      }
      switch (typeof value) {
        case "boolean": {
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert": {
              return true;
            }
            default: {
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if (lowerCasedName === "data-" || lowerCasedName === "aria-")
                return true;
              value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              return warnedProperties[name] = true;
            }
          }
        }
        case "function":
        case "symbol": {
          return warnedProperties[name] = true, false;
        }
        case "string": {
          if (value === "false" || value === "true") {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert": {
                break;
              }
              default: {
                return true;
              }
            }
            console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties[name] = true;
          }
        }
      }
      return true;
    }
    function warnUnknownProperties(type, properties, eventRegistry) {
      let unknownProps = [], key;
      for (key in properties)
        validateProperty(type, key, properties[key], eventRegistry) || unknownProps.push(key);
      properties = unknownProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      unknownProps.length === 1 ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior", properties, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior", properties, type);
    }
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || globalThis;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return nativeEvent.nodeType === 3 ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
      let internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        let properties = target[internalPropertiesKey] || null;
        a:
          switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input": {
              updateInput(target, properties.value, properties.defaultValue, properties.defaultValue, properties.checked, properties.defaultChecked, properties.type, properties.name);
              internalInstance = properties.name;
              if (properties.type === "radio" && internalInstance != undefined) {
                for (properties = target;properties.parentNode; )
                  properties = properties.parentNode;
                checkAttributeStringCoercion(internalInstance, "name");
                properties = properties.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
                for (internalInstance = 0;internalInstance < properties.length; internalInstance++) {
                  var otherNode = properties[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    const otherProps = otherNode[internalPropertiesKey] || null;
                    if (!otherProps)
                      throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                    updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
                  }
                }
                for (internalInstance = 0;internalInstance < properties.length; internalInstance++)
                  otherNode = properties[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            }
            case "textarea": {
              updateTextarea(target, properties.value, properties.defaultValue);
              break a;
            }
            case "select": {
              internalInstance = properties.value, internalInstance != undefined && updateOptions(target, Boolean(properties.multiple), internalInstance, false);
            }
          }
      }
    }
    function batchedUpdates$1(function_, a, b) {
      if (isInsideEventHandler)
        return function_(a, b);
      isInsideEventHandler = true;
      try {
        const JSCompiler_inline_result = function_(a);
        return JSCompiler_inline_result;
      } finally {
        if ((isInsideEventHandler = false, restoreTarget !== null || restoreQueue !== null) && (flushSyncWork$1(), restoreTarget && (a = restoreTarget, function_ = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), function_))) for (a = 0;a < function_.length; a++)
              restoreStateOfTarget(function_[a]);
      }
    }
    function getListener(inst, registrationName) {
      let stateNode = inst.stateNode;
      if (stateNode === null)
        return null;
      let properties = stateNode[internalPropertiesKey] || null;
      if (properties === null)
        return null;
      stateNode = properties[registrationName];
      a:
        switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter": {
            (properties = !properties.disabled) || (inst = inst.type, properties = !(inst === "button" || inst === "input" || inst === "select" || inst === "textarea"));
            inst = !properties;
            break a;
          }
          default: {
            inst = false;
          }
        }
      if (inst)
        return null;
      if (stateNode && typeof stateNode !== "function")
        throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type.");
      return stateNode;
    }
    function getData() {
      if (fallbackText)
        return fallbackText;
      let start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
      for (start = 0;start < startLength && startValue[start] === endValue[start]; start++)
        ;
      const minEnd = startLength - start;
      for (end = 1;end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++)
        ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : undefined);
    }
    function getEventCharCode(nativeEvent) {
      const keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, nativeEvent === 0 && keyCode === 13 && (nativeEvent = 13)) : nativeEvent = keyCode;
      nativeEvent === 10 && (nativeEvent = 13);
      return 32 <= nativeEvent || nativeEvent === 13 ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (const propertyName in Interface)
          Interface.hasOwnProperty(propertyName) && (reactName = Interface[propertyName], this[propertyName] = reactName ? reactName(nativeEvent) : nativeEvent[propertyName]);
        this.isDefaultPrevented = (nativeEvent.defaultPrevented == undefined ? nativeEvent.returnValue === false : nativeEvent.defaultPrevented) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          const event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : typeof event.returnValue !== "unknown" && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          const event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : typeof event.cancelBubble !== "unknown" && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {},
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArgument) {
      const nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArgument) : ((keyArgument = modifierKeyToProp[keyArgument]) ? Boolean(nativeEvent[keyArgument]) : false);
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup": {
          return END_KEYCODES.has(nativeEvent.keyCode);
        }
        case "keydown": {
          return nativeEvent.keyCode !== START_KEYCODE;
        }
        case "keypress":
        case "mousedown":
        case "focusout": {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return typeof nativeEvent === "object" && "data" in nativeEvent ? nativeEvent.data : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend": {
          return getDataFromCustomEvent(nativeEvent);
        }
        case "keypress": {
          if (nativeEvent.which !== SPACEBAR_CODE)
            return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        }
        case "textInput": {
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        }
        default: {
          return null;
        }
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste": {
          return null;
        }
        case "keypress": {
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which)
              return String.fromCharCode(nativeEvent.which);
          }
          return null;
        }
        case "compositionend": {
          return useFallbackCompositionData && nativeEvent.locale !== "ko" ? null : nativeEvent.data;
        }
        default: {
          return null;
        }
      }
    }
    function isTextInputElement(element) {
      const nodeName = element && element.nodeName && element.nodeName.toLowerCase();
      return nodeName === "input" ? Boolean(supportedInputTypes[element.type]) : (nodeName === "textarea" ? true : false);
    }
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM)
        return false;
      eventNameSuffix = "on" + eventNameSuffix;
      let isSupported = eventNameSuffix in document;
      isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = typeof isSupported[eventNameSuffix] === "function");
      return isSupported;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? (restoreQueue ? restoreQueue.push(target) : restoreQueue = [target]) : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      inst.length > 0 && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      const targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode))
        return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if (domEventName === "change")
        return targetInst;
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName === "value" && getInstIfValueChanged(activeElementInst$1)) {
        const dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      domEventName === "focusin" ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : domEventName === "focusout" && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown")
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if (domEventName === "click")
        return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if (domEventName === "input" || domEventName === "change")
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function shallowEqual(objectA, objB) {
      if (objectIs(objectA, objB))
        return true;
      if (typeof objectA !== "object" || objectA === null || typeof objB !== "object" || objB === null)
        return false;
      let keysA = Object.keys(objectA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return false;
      for (keysB = 0;keysB < keysA.length; keysB++) {
        const currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objectA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node) {
      for (;node && node.firstChild; )
        node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root2, offset) {
      let node = getLeafNode(root2);
      root2 = 0;
      for (var nodeEnd;node; ) {
        if (node.nodeType === 3) {
          nodeEnd = root2 + node.textContent.length;
          if (root2 <= offset && nodeEnd >= offset)
            return { node, offset: offset - root2 };
          root2 = nodeEnd;
        }
        a: {
          for (;node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = undefined;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && outerNode.nodeType === 3 ? false : innerNode && innerNode.nodeType === 3 ? containsNode(outerNode, innerNode.parentNode) : ("contains" in outerNode) ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? Boolean(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = containerInfo != undefined && containerInfo.ownerDocument != undefined && containerInfo.ownerDocument.defaultView != undefined ? containerInfo.ownerDocument.defaultView : globalThis;
      for (var element = getActiveElement(containerInfo.document);element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = typeof element.contentWindow.location.href === "string";
        } catch {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result)
          containerInfo = element.contentWindow;
        else
          break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(element) {
      const nodeName = element && element.nodeName && element.nodeName.toLowerCase();
      return nodeName && (nodeName === "input" && (element.type === "text" || element.type === "search" || element.type === "tel" || element.type === "url" || element.type === "password") || nodeName === "textarea" || element.contentEditable === "true");
    }
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      let document = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : (nativeEventTarget.nodeType === 9 ? nativeEventTarget : nativeEventTarget.ownerDocument);
      mouseDown || activeElement == undefined || activeElement !== getActiveElement(document) || (document = activeElement, ("selectionStart" in document) && hasSelectionCapabilities(document) ? document = { start: document.selectionStart, end: document.selectionEnd } : (document = (document.ownerDocument && document.ownerDocument.defaultView || window).getSelection(), document = {
        anchorNode: document.anchorNode,
        anchorOffset: document.anchorOffset,
        focusNode: document.focusNode,
        focusOffset: document.focusOffset
      }), lastSelection && shallowEqual(lastSelection, document) || (lastSelection = document, document = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), document.length > 0 && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({ event: nativeEvent, listeners: document }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProperty, eventName) {
      const prefixes = {};
      prefixes[styleProperty.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProperty] = "webkit" + eventName;
      prefixes["Moz" + styleProperty] = "moz" + eventName;
      return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName])
        return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName])
        return eventName;
      let prefixMap = vendorPrefixes[eventName], styleProperty;
      for (styleProperty in prefixMap)
        if (prefixMap.hasOwnProperty(styleProperty) && styleProperty in style)
          return prefixedEventNames[eventName] = prefixMap[styleProperty];
      return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function createCapturedValueAtFiber(value, source) {
      if (typeof value === "object" && value !== null) {
        const existing = CapturedStacks.get(value);
        if (existing !== undefined)
          return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevelopmentAndProduction(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevelopmentAndProduction(source)
      };
    }
    function finishQueueingConcurrentUpdates() {
      for (let endIndex = concurrentQueuesIndex, index_ = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0;index_ < endIndex; ) {
        const fiber = concurrentQueues[index_];
        concurrentQueues[index_++] = null;
        const queue = concurrentQueues[index_];
        concurrentQueues[index_++] = null;
        const update = concurrentQueues[index_];
        concurrentQueues[index_++] = null;
        const lane = concurrentQueues[index_];
        concurrentQueues[index_++] = null;
        if (queue !== null && update !== null) {
          const pending = queue.pending;
          pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        lane !== 0 && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      fiber !== null && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      let alternate = sourceFiber.alternate;
      alternate !== null && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return;parent !== null; )
        parent.childLanes |= lane, alternate = parent.alternate, alternate !== null && (alternate.childLanes |= lane), parent.tag === 22 && (sourceFiber = parent.stateNode, sourceFiber === null || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return sourceFiber.tag === 3 ? (parent = sourceFiber.stateNode, isHidden && update !== null && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], alternate === null ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536_870_912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      sourceFiber.alternate === null && (sourceFiber.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return;parent !== null; )
        node.alternate === null && (node.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
      return node.tag === 3 ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      const family = resolveFamily(type);
      return family === undefined ? type : family.current;
    }
    function resolveForwardReferenceForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      let family = resolveFamily(type);
      return family === undefined ? (type !== null && type !== undefined && typeof type.render === "function" && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, type.displayName !== undefined && (family.displayName = type.displayName), family) : type) : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (resolveFamily === null)
        return false;
      const previousType = fiber.elementType;
      element = element.type;
      let needsCompareFamilies = false, $$typeofNextType = typeof element === "object" && element !== null ? element.$$typeof : null;
      switch (fiber.tag) {
        case 1: {
          typeof element === "function" && (needsCompareFamilies = true);
          break;
        }
        case 0: {
          typeof element === "function" ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        }
        case 11: {
          $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        }
        case 14:
        case 15: {
          $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        }
        default: {
          return false;
        }
      }
      return needsCompareFamilies && (fiber = resolveFamily(previousType), fiber !== undefined && fiber === resolveFamily(element)) ? true : false;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      resolveFamily !== null && typeof WeakSet === "function" && (failedBoundaries === null && (failedBoundaries = new WeakSet), failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
      let { alternate, child, sibling, tag, type } = fiber, candidateType = null;
      switch (tag) {
        case 0:
        case 15:
        case 1: {
          candidateType = type;
          break;
        }
        case 11: {
          candidateType = type.render;
        }
      }
      if (resolveFamily === null)
        throw new Error("Expected resolveFamily to be set during hot reload.");
      let needsRender = false;
      type = false;
      candidateType !== null && (candidateType = resolveFamily(candidateType), candidateType !== undefined && (staleFamilies.has(candidateType) ? type = true : updatedFamilies.has(candidateType) && (tag === 1 ? type = true : needsRender = true)));
      failedBoundaries !== null && (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) && (type = true);
      type && (fiber._debugNeedsRemount = true);
      if (type || needsRender)
        alternate = enqueueConcurrentRenderForLane(fiber, 2), alternate !== null && scheduleUpdateOnFiber(alternate, fiber, 2);
      child === null || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
      sibling !== null && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
    function FiberNode(tag, pendingProperties, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProperties;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
      this._debugNeedsRemount = false;
      this._debugHookTypes = null;
      hasBadMapPolyfill || typeof Object.preventExtensions !== "function" || Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current2, pendingProperties) {
      let workInProgress2 = current2.alternate;
      workInProgress2 === null ? (workInProgress2 = createFiber(current2.tag, pendingProperties, current2.key, current2.mode), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProperties, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
      workInProgress2.flags = current2.flags & 65_011_712;
      workInProgress2.childLanes = current2.childLanes;
      workInProgress2.lanes = current2.lanes;
      workInProgress2.child = current2.child;
      workInProgress2.memoizedProps = current2.memoizedProps;
      workInProgress2.memoizedState = current2.memoizedState;
      workInProgress2.updateQueue = current2.updateQueue;
      pendingProperties = current2.dependencies;
      workInProgress2.dependencies = pendingProperties === null ? null : {
        lanes: pendingProperties.lanes,
        firstContext: pendingProperties.firstContext,
        _debugThenableState: pendingProperties._debugThenableState
      };
      workInProgress2.sibling = current2.sibling;
      workInProgress2.index = current2.index;
      workInProgress2.ref = current2.ref;
      workInProgress2.refCleanup = current2.refCleanup;
      workInProgress2.selfBaseDuration = current2.selfBaseDuration;
      workInProgress2.treeBaseDuration = current2.treeBaseDuration;
      workInProgress2._debugInfo = current2._debugInfo;
      workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
      switch (workInProgress2.tag) {
        case 0:
        case 15: {
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        }
        case 1: {
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        }
        case 11: {
          workInProgress2.type = resolveForwardReferenceForHotReloading(current2.type);
        }
      }
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65_011_714;
      const current2 = workInProgress2.alternate;
      current2 === null ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = renderLanes2 === null ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext,
        _debugThenableState: renderLanes2._debugThenableState
      }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
      return workInProgress2;
    }
    function createFiberFromTypeAndProperties(type, key, pendingProps, owner, mode, lanes) {
      let fiberTag = 0, resolvedType = type;
      if (typeof type === "function")
        shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
      else if (typeof type === "string")
        fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : (type === "html" || type === "head" || type === "body" ? 27 : 5);
      else
        a:
          switch (type) {
            case REACT_ACTIVITY_TYPE: {
              return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
            }
            case REACT_FRAGMENT_TYPE: {
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            }
            case REACT_STRICT_MODE_TYPE: {
              fiberTag = 8;
              mode |= StrictLegacyMode;
              mode |= StrictEffectsMode;
              break;
            }
            case REACT_PROFILER_TYPE: {
              return type = pendingProps, owner = mode, typeof type.id !== "string" && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
            }
            case REACT_SUSPENSE_TYPE: {
              return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
            }
            default: {
              if (typeof type === "object" && type !== null)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE: {
                    fiberTag = 10;
                    break a;
                  }
                  case REACT_CONSUMER_TYPE: {
                    fiberTag = 9;
                    break a;
                  }
                  case REACT_FORWARD_REF_TYPE: {
                    fiberTag = 11;
                    resolvedType = resolveForwardReferenceForHotReloading(resolvedType);
                    break a;
                  }
                  case REACT_MEMO_TYPE: {
                    fiberTag = 14;
                    break a;
                  }
                  case REACT_LAZY_TYPE: {
                    fiberTag = 16;
                    resolvedType = null;
                    break a;
                  }
                }
              resolvedType = "";
              if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
                resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              type === null ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
              (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += `

Check the render method of \`` + fiberTag + "`.");
              fiberTag = 29;
              pendingProps = new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
              resolvedType = null;
            }
          }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProperties(element.type, element.key, element.props, element._owner, mode, lanes);
      mode._debugOwner = element._owner;
      mode._debugStack = element._debugStack;
      mode._debugTask = element._debugTask;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(4, portal.children === null ? [] : portal.children, portal.key, mode);
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function pushTreeFork(workInProgress2, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      let baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      let baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      let length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        const numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      warnIfNotHydrating();
      workInProgress2.return !== null && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (;workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (;workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function warnIfNotHydrating() {
      isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (fiber.return === null) {
        if (hydrationDiffRootDEV === null)
          hydrationDiffRootDEV = {
            fiber,
            children: [],
            serverProps: undefined,
            serverTail: [],
            distanceFromLeaf
          };
        else {
          if (hydrationDiffRootDEV.fiber !== fiber)
            throw new Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      let siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
      if (siblings.length > 0 && siblings.at(-1).fiber === fiber)
        return siblings = siblings.at(-1), siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
      distanceFromLeaf = {
        fiber,
        children: [],
        serverProps: undefined,
        serverTail: [],
        distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, rejectedCandidate !== null && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      let diff = "", diffRoot = hydrationDiffRootDEV;
      diffRoot !== null && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
      queueHydrationError(createCapturedValueAtFiber(new Error(`Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + diff), fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      let didHydrate = fiber.stateNode;
      let { type, memoizedProps: props } = fiber;
      didHydrate[internalInstanceKey] = fiber;
      didHydrate[internalPropertiesKey] = props;
      validatePropertiesInDevelopment(type, props);
      switch (type) {
        case "dialog": {
          listenToNonDelegatedEvent("cancel", didHydrate);
          listenToNonDelegatedEvent("close", didHydrate);
          break;
        }
        case "iframe":
        case "object":
        case "embed": {
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        }
        case "video":
        case "audio": {
          for (type = 0;type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
          break;
        }
        case "source": {
          listenToNonDelegatedEvent("error", didHydrate);
          break;
        }
        case "img":
        case "image":
        case "link": {
          listenToNonDelegatedEvent("error", didHydrate);
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        }
        case "details": {
          listenToNonDelegatedEvent("toggle", didHydrate);
          break;
        }
        case "input": {
          checkControlledValueProperties("input", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateInputProperties(didHydrate, props);
          initInput(didHydrate, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, true);
          track(didHydrate);
          break;
        }
        case "option": {
          validateOptionProperties(didHydrate, props);
          break;
        }
        case "select": {
          checkControlledValueProperties("select", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateSelectProperties(didHydrate, props);
          break;
        }
        case "textarea": {
          checkControlledValueProperties("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProperties(didHydrate, props), initTextarea(didHydrate, props.value, props.defaultValue, props.children), track(didHydrate);
        }
      }
      type = props.children;
      typeof type !== "string" && typeof type !== "number" && typeof type !== "bigint" || didHydrate.textContent === "" + type || props.suppressHydrationWarning === true || checkForUnmatchedText(didHydrate.textContent, type) ? (props.popover != undefined && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), props.onScroll != undefined && listenToNonDelegatedEvent("scroll", didHydrate), props.onScrollEnd != undefined && listenToNonDelegatedEvent("scrollend", didHydrate), props.onClick != undefined && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
      didHydrate || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return;hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 13: {
            rootOrSingletonContext = false;
            return;
          }
          case 27:
          case 3: {
            rootOrSingletonContext = true;
            return;
          }
          default: {
            hydrationParentFiber = hydrationParentFiber.return;
          }
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber)
        return false;
      if (!isHydrating)
        return popToNextHostParent(fiber), isHydrating = true, false;
      let tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = tag !== 3 && tag !== 27) {
        if (JSCompiler_temp = tag === 5)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !(JSCompiler_temp !== "form" && JSCompiler_temp !== "button") || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      if (JSCompiler_temp && nextHydratableInstance) {
        for (JSCompiler_temp = nextHydratableInstance;JSCompiler_temp; ) {
          const diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
          diffNode.serverTail.push(description);
          JSCompiler_temp = description.type === "Suspense" ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
        }
        throwOnHydrationMismatch(fiber);
      }
      popToNextHostParent(fiber);
      if (tag === 13) {
        fiber = fiber.memoizedState;
        fiber = fiber === null ? null : fiber.dehydrated;
        if (!fiber)
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
      } else
        tag === 27 ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      didSuspendOrErrorDEV = isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      const queuedErrors = hydrationErrors;
      queuedErrors !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      hydrationErrors === null ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      let diffRoot = hydrationDiffRootDEV;
      if (diffRoot !== null) {
        hydrationDiffRootDEV = null;
        for (var diff = describeDiff(diffRoot);diffRoot.children.length > 0; )
          diffRoot = diffRoot.children[0];
        runWithFiberInDEV(diffRoot.fiber, function() {
          console.error(`A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`, "https://react.dev/link/hydration-mismatch", diff);
        });
      }
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      isDisallowedContextReadInDEV = false;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber);
      context._currentValue = nextValue;
      push(rendererCursorDEV, context._currentRenderer, providerFiber);
      context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
      context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      context._currentValue = valueCursor.current;
      const currentRenderer = rendererCursorDEV.current;
      pop(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (;parent !== null; ) {
        const alternate = parent.alternate;
        (parent.childLanes & renderLanes2) === renderLanes2 ? alternate !== null && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2) : (parent.childLanes |= renderLanes2, alternate !== null && (alternate.childLanes |= renderLanes2));
        if (parent === propagationRoot)
          break;
        parent = parent.return;
      }
      parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      let fiber = workInProgress2.child;
      fiber !== null && (fiber.return = workInProgress2);
      for (;fiber !== null; ) {
        let list = fiber.dependencies;
        if (list !== null) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a:
            for (;list !== null; ) {
              let dependency = list;
              list = fiber;
              for (let i = 0;i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  dependency !== null && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(list.return, renderLanes2, workInProgress2);
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
        } else if (fiber.tag === 18) {
          nextFiber = fiber.return;
          if (nextFiber === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          list !== null && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else
          nextFiber = fiber.child;
        if (nextFiber === null)
          {for (nextFiber = fiber;nextFiber !== null; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (fiber !== null) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }}
        else
          {nextFiber.return = fiber;}
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current2 = null;
      for (let parent = workInProgress2, isInsidePropagationBailout = false;parent !== null; ) {
        if (!isInsidePropagationBailout) {
          if ((parent.flags & 524_288) !== 0)
            isInsidePropagationBailout = true;
          else if ((parent.flags & 262_144) !== 0)
            break;
        }
        if (parent.tag === 10) {
          var currentParent = parent.alternate;
          if (currentParent === null)
            throw new Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (currentParent !== null) {
            const context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (current2 === null ? current2 = [context] : current2.push(context));
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (currentParent === null)
            throw new Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (current2 === null ? current2 = [HostTransitionContext] : current2.push(HostTransitionContext));
        }
        parent = parent.return;
      }
      current2 !== null && propagateContextChanges(workInProgress2, current2, renderLanes2, forcePropagateEntireTree);
      workInProgress2.flags |= 262_144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext;currentDependencies !== null; ) {
        if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      workInProgress2 !== null && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      currentlyRenderingFiber$1 === null && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      const value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (lastContextDependency === null) {
        if (consumer === null)
          throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524_288;
      } else
        lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal,
        data: new Map,
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
      cache.refCount === 0 && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    function pushNestedEffectDurations() {
      const prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      const elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      const elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        const elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        const elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        const elapsedTime = now() - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
      }
    }
    function startEffectTimer() {
      profilerStartTime = now();
    }
    function transferActualDuration(fiber) {
      for (let child = fiber.child;child; )
        fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function entangleAsyncAction(transition, thenable) {
      if (currentEntangledListeners === null) {
        const entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: undefined,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (--currentEntangledPendingCount === 0 && currentEntangledListeners !== null) {
        currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = "fulfilled");
        const listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (let i = 0;i < listeners.length; i++)
          (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      const listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(function() {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (let i = 0;i < listeners.length; i++)
          (0, listeners[i])(result);
      }, function(error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0;error < listeners.length; error++)
          (0, listeners[error])();
      });
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      const cacheResumedFromPreviousRender = resumedCache.current;
      return cacheResumedFromPreviousRender === null ? workInProgressRoot.pooledCache : cacheResumedFromPreviousRender;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      prevCachePool === null ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      const cacheFromPool = peekCacheFromPool();
      return cacheFromPool === null ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    function createThenableState() {
      return { didWarnAboutUncachedPromise: false, thenables: [] };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return thenable === "fulfilled" || thenable === "rejected";
    }
    function noop$3() {}
    function trackUsedThenable(thenableState2, thenable, index) {
      ReactSharedInternals.actQueue !== null && (ReactSharedInternals.didUsePromise = true);
      const trackedThenables = thenableState2.thenables;
      index = trackedThenables[index];
      index === undefined ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$3, noop$3), thenable = index);
      switch (thenable.status) {
        case "fulfilled": {
          return thenable.value;
        }
        case "rejected": {
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        }
        default: {
          if (typeof thenable.status === "string")
            thenable.then(noop$3, noop$3);
          else {
            thenableState2 = workInProgressRoot;
            if (thenableState2 !== null && 100 < thenableState2.shellSuspendCounter)
              throw new Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(function(fulfilledValue) {
              if (thenable.status === "pending") {
                const fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            }, function(error) {
              if (thenable.status === "pending") {
                const rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            });
          }
          switch (thenable.status) {
            case "fulfilled": {
              return thenable.value;
            }
            case "rejected": {
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = true;
          throw SuspenseException;
        }
      }
    }
    function getSuspendedThenable() {
      if (suspendedThenable === null)
        throw new Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      const thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = false;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw new Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current2, workInProgress2) {
      current2 = current2.updateQueue;
      workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
        baseState: current2.baseState,
        firstBaseUpdate: current2.firstBaseUpdate,
        lastBaseUpdate: current2.lastBaseUpdate,
        shared: current2.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return {
        lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      let updateQueue = fiber.updateQueue;
      if (updateQueue === null)
        return null;
      updateQueue = updateQueue.shared;
      if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
        var componentName2 = getComponentNameFromFiber(fiber);
        console.error(`An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`, componentName2);
        didWarnUpdateInsideUpdate = true;
      }
      if ((executionContext & RenderContext) !== NoContext)
        return componentName2 = updateQueue.pending, componentName2 === null ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root2, fiber, lane) {
      fiber = fiber.updateQueue;
      if (fiber !== null && (fiber = fiber.shared, (lane & 4_194_048) !== 0)) {
        let queueLanes = fiber.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      let { updateQueue: queue, alternate: current2 } = workInProgress2;
      if (current2 !== null && (current2 = current2.updateQueue, queue === current2)) {
        let newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (queue === null) {newFirst = newLast = capturedUpdate;} else
          {
          do {
            const clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            newLast === null ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (queue !== null);
          newLast === null ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        }
        queue = {
          baseState: current2.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current2.shared,
          callbacks: current2.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      workInProgress2 === null ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        const entangledActionThenable = currentEntangledActionThenable;
        if (entangledActionThenable !== null)
          throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      const queue = workInProgress2.updateQueue;
      hasForceUpdate = false;
      currentlyProcessingQueue = queue.shared;
      let { firstBaseUpdate, lastBaseUpdate } = queue, pendingQueue = queue.shared.pending;
      if (pendingQueue !== null) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current2 = workInProgress2.alternate;
        current2 !== null && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (pendingQueue === null ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
      }
      if (firstBaseUpdate !== null) {
        let newState = queue.baseState;
        lastBaseUpdate = 0;
        current2 = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          let updateLane = pendingQueue.lane & -536_870_913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            updateLane !== 0 && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            current2 !== null && (current2 = current2.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              updateLane = workInProgress2;
              let partialState = pendingQueue;
              const nextProps = props, instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState: {
                  partialState = partialState.payload;
                  if (typeof partialState === "function") {
                    isDisallowedContextReadInDEV = true;
                    var nextState = partialState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                }
                case CaptureUpdate: {
                  updateLane.flags = updateLane.flags & -65_537 | 128;
                }
                case UpdateState: {
                  nextState = partialState.payload;
                  if (typeof nextState === "function") {
                    isDisallowedContextReadInDEV = true;
                    partialState = nextState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                  } else
                    partialState = nextState;
                  if (partialState === null || partialState === undefined)
                    break a;
                  newState = assign({}, newState, partialState);
                  break a;
                }
                case ForceUpdate: {
                  hasForceUpdate = true;
                }
              }
            }
            updateLane = pendingQueue.callback;
            updateLane !== null && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, isHiddenUpdate === null ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, current2 === null ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (pendingQueue === null)
            if (pendingQueue = queue.shared.pending, pendingQueue === null)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        current2 === null && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current2;
        firstBaseUpdate === null && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress2.lanes = lastBaseUpdate;
        workInProgress2.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if (typeof callback !== "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      const hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (hiddenCallbacks !== null)
        for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;updateQueue < hiddenCallbacks.length; updateQueue++)
          callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      const callbacks = updateQueue.callbacks;
      if (callbacks !== null)
        for (updateQueue.callbacks = null, updateQueue = 0;updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    function pushHiddenContext(fiber, context) {
      const prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function mountHookTypesDev() {
      const hookName = currentHookNameInDev;
      hookTypesDev === null ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      const hookName = currentHookNameInDev;
      if (hookTypesDev !== null && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
        const componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), hookTypesDev !== null)) {
          for (var table = "", i = 0;i <= hookTypesUpdateIndexDev; i++) {
            let oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (oldHookName = i + 1 + ". " + oldHookName;30 > oldHookName.length; )
              oldHookName += " ";
            oldHookName += newHookName + `
`;
            table += oldHookName;
          }
          console.error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName2, table);
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      deps === undefined || deps === null || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnUseFormStateInDev() {
      const componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
      didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName2));
    }
    function throwInvalidHookError() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies)
        return false;
      if (prevDeps === null)
        return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), false;
      nextDeps.length !== prevDeps.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
      for (let i = 0;i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i]))
          return false;
      return true;
    }
    function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      hookTypesDev = current2 === null ? null : current2._debugHookTypes;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      if (Object.prototype.toString.call(Component) === "[object AsyncFunction]" || Object.prototype.toString.call(Component) === "[object AsyncGeneratorFunction]")
        nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.", nextRenderLanes === null ? "An unknown Component" : "<" + nextRenderLanes + ">"));
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = current2 !== null && current2.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : (hookTypesDev === null ? HooksDispatcherOnMountInDEV : HooksDispatcherOnMountWithHookTypesInDEV);
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
      let children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress2, Component, props, secondArg));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(true);
        try {
          children = renderWithHooksAgain(workInProgress2, Component, props, secondArg);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      finishRenderingHooks(current2, workInProgress2);
      return children;
    }
    function finishRenderingHooks(current2, workInProgress2) {
      workInProgress2._debugHookTypes = hookTypesDev;
      workInProgress2.dependencies === null ? thenableState$1 !== null && (workInProgress2.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: thenableState$1
      }) : workInProgress2.dependencies._debugThenableState = thenableState$1;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      const didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
      renderLanes = 0;
      hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      current2 !== null && (current2.flags & 65_011_712) !== (workInProgress2.flags & 65_011_712) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter$1 = 0;
      thenableState$1 = null;
      if (didRenderTooFewHooks)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      current2 === null || didReceiveUpdate || (current2 = current2.dependencies, current2 !== null && checkIfContextChanged(current2) && (didReceiveUpdate = true));
      needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
      current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      let numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
        thenableIndexCounter$1 = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        numberOfReRenders += 1;
        ignorePreviousDependencies = false;
        workInProgressHook = currentHook = null;
        if (workInProgress2.updateQueue != undefined) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          children.memoCache != undefined && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      let dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = typeof maybeThenable.then === "function" ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (currentHook === null ? null : currentHook.memoizedState) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      const didRenderIdHook = localIdCounter !== 0;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current2, workInProgress2, lanes) {
      workInProgress2.updateQueue = current2.updateQueue;
      workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) === NoMode ? workInProgress2.flags & -2053 : workInProgress2.flags & -402_655_237;
      current2.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState;workInProgress2 !== null; ) {
          const queue = workInProgress2.queue;
          queue !== null && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter$1 = localIdCounter = 0;
      thenableState$1 = null;
    }
    function mountWorkInProgressHook() {
      const hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (currentHook === null) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = nextCurrentHook === null ? null : nextCurrentHook.memoizedState;
      } else
        nextCurrentHook = currentHook.next;
      const nextWorkInProgressHook = workInProgressHook === null ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (nextWorkInProgressHook === null)
        {
        if (nextCurrentHook === null) {
          if (currentlyRenderingFiber.alternate === null)
            throw new Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw new Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      else {workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;}
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      let index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      thenableState$1 === null && (thenableState$1 = createThenableState());
      thenable = trackUsedThenable(thenableState$1, thenable, index);
      index = currentlyRenderingFiber;
      (workInProgressHook === null ? index.memoizedState : workInProgressHook.next) === null && (index = index.alternate, ReactSharedInternals.H = index !== null && index.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
      return thenable;
    }
    function use(usable) {
      if (usable !== null && typeof usable === "object") {
        if (typeof usable.then === "function")
          return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE)
          return readContext(usable);
      }
      throw new Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      let memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      updateQueue !== null && (memoCache = updateQueue.memoCache);
      if (memoCache == undefined) {
        var current2 = currentlyRenderingFiber.alternate;
        current2 !== null && (current2 = current2.updateQueue, current2 !== null && (current2 = current2.memoCache, current2 != undefined && (memoCache = {
          data: current2.data.map(function(array) {
            return [...array];
          }),
          index: 0
        })));
      }
      memoCache == undefined && (memoCache = { data: [], index: 0 });
      updateQueue === null && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (updateQueue === undefined || ignorePreviousDependencies)
        for (updateQueue = memoCache.data[memoCache.index] = new Array(size), current2 = 0;current2 < size; current2++)
          updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
      else
        updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return typeof action === "function" ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      const hook = mountWorkInProgressHook();
      if (init === undefined) {initialState = initialArg;} else
        {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      const hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current2, reducer) {
      const queue = hook.queue;
      if (queue === null)
        throw new Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      let baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (pendingQueue !== null) {
        if (baseQueue !== null) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current2.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
        current2.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (baseQueue === null)
        hook.memoizedState = pendingQueue;
      else {
        current2 = baseQueue.next;
        let newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
        do {
          let updateLane = update.lane & -536_870_913;
          if (updateLane === update.lane ? (renderLanes & updateLane) === updateLane : (workInProgressRootRenderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (revertLane === 0)
              newBaseQueueLast !== null && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (update !== null && update !== current2);
        newBaseQueueLast === null ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, reducer !== null)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      baseQueue === null && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      const hook = updateWorkInProgressHook(), queue = hook.queue;
      if (queue === null)
        throw new Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      let { dispatch, pending: lastRenderPhaseUpdate } = queue, newState = hook.memoizedState;
      if (lastRenderPhaseUpdate !== null) {
        queue.pending = null;
        let update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        hook.baseQueue === null && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      const fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (getServerSnapshot === undefined)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true));
        if (workInProgressRoot === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        (workInProgressRootRenderLanes & 124) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = { value: nextSnapshot, getSnapshot };
      hook.queue = getServerSnapshot;
      mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [subscribe]);
      fiber.flags |= 2048;
      pushSimpleEffect(HasEffect | Passive, createEffectInstance(), updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), null);
      return nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      let fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (getServerSnapshot === undefined)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        getServerSnapshot = getServerSnapshot();
      } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      }
      if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot))
        hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
      hook = hook.queue;
      const create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (hook.getSnapshot !== getSnapshot || cachedSnapshot || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
        fiber.flags |= 2048;
        pushSimpleEffect(HasEffect | Passive, createEffectInstance(), updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
        if (workInProgressRoot === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        isHydrating$jscomp$0 || (renderLanes & 124) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16_384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      getSnapshot === null ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, renderedSnapshot === null ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      const latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        const nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      const root2 = enqueueConcurrentRenderForLane(fiber, 2);
      root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2);
    }
    function mountStateImpl(initialState) {
      const hook = mountWorkInProgressHook();
      if (typeof initialState === "function") {
        const initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      const queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      let hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      const queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, true, queue);
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      const hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current2, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(hook, currentHook, typeof reducer === "function" ? reducer : basicStateReducer);
    }
    function rerenderOptimistic(passthrough, reducer) {
      const hook = updateWorkInProgressHook();
      if (currentHook !== null)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber))
        throw new Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (fiber !== null) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        ReactSharedInternals.T === null ? actionNode.isTransition = false : setPendingState(true);
        setState(actionNode);
        setPendingState = actionQueue.pending;
        setPendingState === null ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      let { action, payload } = node, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        ReactSharedInternals.T._updatedFibers = new Set;
        try {
          const returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else
        try {
          currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error) {
          onActionError(actionQueue, node, error);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function" ? (returnValue.then(function(nextState) {
        onActionSuccess(actionQueue, node, nextState);
      }, function(error) {
        return onActionError(actionQueue, node, error);
      }), node.isTransition || console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      actionNode !== null && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      let last = actionQueue.pending;
      actionQueue.pending = null;
      if (last !== null) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (let i = 0;i < actionNode.length; i++)
        (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (ssrFormState !== null) {
          a: {
            var isMatching = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var markerInstance = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext;markerInstance.nodeType !== 8; ) {
                    if (!inRootOrSingleton) {
                      markerInstance = null;
                      break b;
                    }
                    markerInstance = getNextHydratable(markerInstance.nextSibling);
                    if (markerInstance === null) {
                      markerInstance = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = markerInstance.data;
                  markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                }
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratable(markerInstance.nextSibling);
                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = false;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, isMatching);
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, false, isMatching.queue);
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, inRootOrSingleton, ssrFormState);
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      const stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if (typeof currentStateHook === "object" && currentStateHook !== null && typeof currentStateHook.then === "function")
        try {
          var state = useThenable(currentStateHook);
        } catch (error) {
          if (error === SuspenseException)
            throw SuspenseActionException;
          throw error;
        }
      else
        state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      const actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(HasEffect | Passive, createEffectInstance(), actionStateActionEffect.bind(null, actionQueue, action), null));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      let stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (currentStateHook !== null)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      const dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, createDeps) {
      tag = {
        tag,
        create,
        deps: createDeps,
        inst,
        next: null
      };
      inst = currentlyRenderingFiber.updateQueue;
      inst === null && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      create === null ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
      return tag;
    }
    function createEffectInstance() {
      return { destroy: undefined, resource: undefined };
    }
    function mountRef(initialValue) {
      const hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
      const hook = mountWorkInProgressHook();
      createDeps = createDeps === undefined ? null : createDeps;
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, createEffectInstance(), create, createDeps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      const hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      const inst = hook.memoizedState.inst;
      currentHook !== null && deps !== null && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, inst, create, deps));
    }
    function mountEffect(create, createDeps) {
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276_826_112, Passive, create, createDeps) : mountEffectImpl(8_390_656, Passive, create, createDeps);
    }
    function mountLayoutEffect(create, deps) {
      let fiberFlags = 4_194_308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134_217_728);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if (typeof ref === "function") {
        create = create();
        const refCleanup = ref(create);
        return function() {
          typeof refCleanup === "function" ? refCleanup() : ref(null);
        };
      }
      if (ref !== null && ref !== undefined)
        return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    function mountImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create === null ? "null" : typeof create);
      deps = deps !== null && deps !== undefined ? [...deps, ref] : null;
      let fiberFlags = 4_194_308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134_217_728);
      mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function updateImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create === null ? "null" : typeof create);
      deps = deps !== null && deps !== undefined ? [...deps, ref] : null;
      updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        deps === undefined ? null : deps
      ];
      return callback;
    }
    function updateCallback(callback, deps) {
      const hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      const prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      const hook = mountWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      const nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      const hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      let prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      const hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      const hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function rerenderDeferredValue(value, initialValue) {
      const hook = updateWorkInProgressHook();
      return currentHook === null ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (initialValue === undefined || (renderLanes & 1_073_741_824) !== 0)
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue))
        return value;
      if (currentTreeHiddenStackCursor.current !== null)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if ((renderLanes & 42) === 0)
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      const previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = previousPriority !== 0 && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
      const prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      currentTransition._updatedFibers = new Set;
      try {
        const returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        if (returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function") {
          const thenableForFinishedState = chainThenableValue(returnValue, finishedState);
          dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
        } else
          dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
      } catch (error) {
        dispatchSetStateInternal(fiber, queue, { then: function() {}, status: "rejected", reason: error }, requestUpdateLane(fiber));
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (formFiber.tag !== 5)
        throw new Error("Expected the form instance to be a HostComponent. This is a bug in React.");
      const queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(formFiber, queue, pendingState, NotPendingTransition, action === null ? noop$2 : function() {
        requestFormReset$1(formFiber);
        return action(formData);
      });
    }
    function ensureFormComponentIsStateful(formFiber) {
      let existingStateHook = formFiber.memoizedState;
      if (existingStateHook !== null)
        return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      const initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      formFiber !== null && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      ReactSharedInternals.T === null && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
      const resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
      dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));
    }
    function mountTransition() {
      let stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, true, false);
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    }
    function updateTransition() {
      const booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function rerenderTransition() {
      const booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      let hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        const idWithLeadingBit = treeContextId;
        treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
        identifierPrefix = "" + identifierPrefix + "R" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += "";
      } else
        treeId = globalClientIdCounter++, identifierPrefix = "" + identifierPrefix + "r" + treeId.toString(32) + "";
      return hook.memoizedState = identifierPrefix;
    }
    function mountRefresh() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
    }
    function refreshCache(fiber, seedKey) {
      for (let provider = fiber.return;provider !== null; ) {
        switch (provider.tag) {
          case 24:
          case 3: {
            const lane = requestUpdateLane(provider);
            fiber = createUpdate(lane);
            const root2 = enqueueUpdate(provider, fiber, lane);
            root2 !== null && (scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
            provider = createCache();
            seedKey !== null && seedKey !== undefined && root2 !== null && console.error("The seed argument is not enabled outside experimental channels.");
            fiber.payload = { cache: provider };
            return;
          }
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      let args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      let update = {
        lane: args,
        revertLane: 0,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), update !== null && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
      markStateUpdateScheduled(fiber, args);
    }
    function dispatchSetState(fiber, queue, action) {
      let args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, args);
      markStateUpdateScheduled(fiber, args);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      const update = {
        lane,
        revertLane: 0,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber))
        enqueueRenderPhaseUpdate(queue, update);
      else {
        let alternate = fiber.alternate;
        if (fiber.lanes === 0 && (alternate === null || alternate.lanes === 0) && (alternate = queue.lastRenderedReducer, alternate !== null)) {
          const prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            const currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), workInProgressRoot === null && finishQueueingConcurrentUpdates(), false;
          } catch {} finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (action !== null)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      ReactSharedInternals.T === null && currentEntangledLane === 0 && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender)
          throw new Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), throwIfDuringRender !== null && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      markStateUpdateScheduled(fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      const alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      const pending = queue.pending;
      pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root2, queue, lane) {
      if ((lane & 4_194_048) !== 0) {
        let queueLanes = queue.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function pushDebugInfo(debugInfo) {
      const previousDebugInfo = currentDebugInfo;
      debugInfo != undefined && (currentDebugInfo = previousDebugInfo === null ? debugInfo : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (let keys = Object.keys(element.props), i = 0;i < keys.length; i++) {
        const key = keys[i];
        if (key !== "children" && key !== "key") {
          fiber === null && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
          runWithFiberInDEV(fiber, function(erroredKey) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
          }, key);
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      const index = thenableIndexCounter;
      thenableIndexCounter += 1;
      thenableState === null && (thenableState = createThenableState());
      return trackUsedThenable(thenableState, thenable, index);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = element === undefined ? null : element;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw new Error(`A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`);
      returnFiber = Object.prototype.toString.call(newChild);
      throw new Error("Objects are not valid as a React child (found: " + (returnFiber === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      const parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", returnFiber.tag === 3 ? console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`, invalidChild, invalidChild, invalidChild) : console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`, invalidChild, invalidChild, parentName, invalidChild, parentName));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      const parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), returnFiber.tag === 3 ? console.error(`Symbols are not valid as a React child.
  root.render(%s)`, invalidChild) : console.error(`Symbols are not valid as a React child.
  <%s>%s</%s>`, parentName, invalidChild, parentName));
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          const deletions = returnFiber.deletions;
          deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects)
          return null;
        for (;currentFirstChild !== null; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map;currentFirstChild !== null; )
          currentFirstChild.key === null ? existingChildren.set(currentFirstChild.index, currentFirstChild) : existingChildren.set(currentFirstChild.key, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1_048_576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (newIndex !== null)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67_108_866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67_108_866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= 67_108_866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current2, textContent, lanes) {
        if (current2 === null || current2.tag !== 6)
          return current2 = createFiberFromText(textContent, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, textContent);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateElement(returnFiber, current2, element, lanes) {
        const elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return current2 = updateFragment(returnFiber, current2, element.props.children, lanes, element.key), validateFragmentProps(element, current2, returnFiber), current2;
        if (current2 !== null && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current2.type))
          return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
        current2 = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current2, element);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updatePortal(returnFiber, current2, portal, lanes) {
        if (current2 === null || current2.tag !== 4 || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
          return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, portal.children || []);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateFragment(returnFiber, current2, fragment, lanes, key) {
        if (current2 === null || current2.tag !== 7)
          return current2 = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, fragment);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            }
            case REACT_PORTAL_TYPE: {
              return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            }
            case REACT_LAZY_TYPE: {
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
            }
          }
          if (isArrayImpl(newChild) || getIteratorFunction(newChild))
            return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
          if (typeof newChild.then === "function")
            return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        let key = oldFiber === null ? null : oldFiber.key;
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return key === null ? updateTextNode(returnFiber, oldFiber, "" + newChild, lanes) : null;
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
            }
            case REACT_PORTAL_TYPE: {
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            }
            case REACT_LAZY_TYPE: {
              return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
            }
          }
          if (isArrayImpl(newChild) || getIteratorFunction(newChild)) {
            if (key !== null)
              return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            currentDebugInfo = key;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              return newIdx = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
            }
            case REACT_PORTAL_TYPE: {
              return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            }
            case REACT_LAZY_TYPE: {
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
            }
          }
          if (isArrayImpl(newChild) || getIteratorFunction(newChild))
            return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
          if (typeof newChild.then === "function")
            return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
        if (typeof child !== "object" || child === null)
          return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE: {
            warnForMissingKey(returnFiber, workInProgress2, child);
            const key = child.key;
            if (typeof key !== "string")
              break;
            if (knownKeys === null) {
              knownKeys = new Set;
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress2, function() {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", key);
            });
            break;
          }
          case REACT_LAZY_TYPE: {
            child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
          }
        }
        return knownKeys;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null;oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (newChildren == undefined)
          throw new Error("An iterable object provided no iterator.");
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next();oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;!step.done; newIdx++, step = newChildren.next())
            oldFiber = createChild(returnFiber, step.value, lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);!step.done; newIdx++, step = newChildren.next())
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (currentFirstChild.tag === 7) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.props.children);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || typeof key === "object" && key !== null && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            }
            case REACT_PORTAL_TYPE: {
              a: {
                prevDebugInfo = newChild;
                for (newChild = prevDebugInfo.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === newChild)
                    if (currentFirstChild.tag === 4 && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            }
            case REACT_LAZY_TYPE: {
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
            }
          }
          if (isArrayImpl(newChild))
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (getIteratorFunction(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFunction(newChild);
            if (typeof key !== "function")
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            const newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (returnFiber.tag !== 0 || Object.prototype.toString.call(returnFiber.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(newChildren) !== "[object Generator]")
                didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = true;
            } else
              newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true);
            returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return prevDebugInfo = "" + newChild, currentFirstChild !== null && currentFirstChild.tag === 6 ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        const prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter = 0;
          const firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
          thenableState = null;
          return firstChildFiber;
        } catch (error) {
          if (error === SuspenseException || error === SuspenseActionException)
            throw error;
          const fiber = createFiber(29, error, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          const debugInfo = fiber._debugInfo = currentDebugInfo;
          fiber._debugOwner = returnFiber._debugOwner;
          fiber._debugTask = returnFiber._debugTask;
          if (debugInfo != undefined) {
            for (let i = debugInfo.length - 1;0 <= i; i--)
              if (typeof debugInfo[i].stack === "string") {
                fiber._debugOwner = debugInfo[i];
                fiber._debugTask = debugInfo[i].debugTask;
                break;
              }
          }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      const current2 = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
      push(suspenseHandlerStackCursor, handler, handler);
      shellBoundary === null && (current2 === null || currentTreeHiddenStackCursor.current !== null ? shellBoundary = handler : current2.memoizedState !== null && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (fiber.tag === 22) {
        if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), shellBoundary === null) {
          const current2 = fiber.alternate;
          current2 !== null && current2.memoizedState !== null && (shellBoundary = fiber);
        }
      } else
        reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (let node = row;node !== null; ) {
        if (node.tag === 13) {
          let state = node.memoizedState;
          if (state !== null && (state = state.dehydrated, state === null || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state)))
            return node;
        } else if (node.tag === 19 && node.memoizedProps.revealOrder !== undefined) {
          if ((node.flags & 128) !== 0)
            return node;
        } else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row)
          break;
        for (;node.sibling === null; ) {
          if (node.return === null || node.return === row)
            return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function warnOnInvalidCallback(callback) {
      if (callback !== null && typeof callback !== "function") {
        const key = String(callback);
        didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      let prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress2.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(true);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      partialState === undefined && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
      prevState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
      workInProgress2.memoizedState = prevState;
      workInProgress2.lanes === 0 && (workInProgress2.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      const instance = workInProgress2.stateNode;
      if (typeof instance.shouldComponentUpdate === "function") {
        oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
        if (workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(true);
          try {
            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        oldProps === undefined && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      const oldState = instance.state;
      typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps(newProps, nextContext);
      typeof instance.UNSAFE_componentWillReceiveProps === "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress2)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function resolveClassComponentProps(Component, baseProps) {
      let newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (const propName in baseProps)
          propName !== "ref" && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (const _propName in Component)
          newProps[_propName] === undefined && (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
      console.warn(`%s

%s
`, componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.", `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`);
    }
    function defaultOnCaughtError(error) {
      const componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
      if (typeof error === "object" && error !== null && typeof error.environmentName === "string") {
        let JSCompiler_inline_result = error.environmentName;
        error = [
          `%o

%s

%s
`,
          error,
          componentNameMessage,
          recreateMessage
        ].slice(0);
        typeof error[0] === "string" ? error.splice(0, 1, badgeFormat + error[0], badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle) : error.splice(0, 0, badgeFormat, badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle);
        error.unshift(console);
        JSCompiler_inline_result = bind.apply(console.error, error);
        JSCompiler_inline_result();
      } else
        console.error(`%o

%s

%s
`, error, componentNameMessage, recreateMessage);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root2, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = null;
        const error = errorInfo.value;
        if (ReactSharedInternals.actQueue === null)
          {
          const onUncaughtError = root2.onUncaughtError;
          onUncaughtError(error, { componentStack: errorInfo.stack });
        }
        else {ReactSharedInternals.thrownErrors.push(error);}
      } catch (error_) {
        setTimeout(function() {
          throw error_;
        });
      }
    }
    function logCaughtError(root2, boundary, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        const onCaughtError = root2.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: boundary.tag === 1 ? boundary.stateNode : null
        });
      } catch (error) {
        setTimeout(function() {
          throw error;
        });
      }
    }
    function createRootErrorUpdate(root2, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = { element: null };
      lane.callback = function() {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
      const getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if (typeof getDerivedStateFromError === "function") {
        const error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(errorInfo.source, logCaughtError, root2, fiber, errorInfo);
        };
      }
      const inst = fiber.stateNode;
      inst !== null && typeof inst.componentDidCatch === "function" && (update.callback = function() {
        markFailedErrorBoundaryForHotReloading(fiber);
        runWithFiberInDEV(errorInfo.source, logCaughtError, root2, fiber, errorInfo);
        typeof getDerivedStateFromError !== "function" && (legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        callComponentDidCatchInDEV(this, errorInfo);
        typeof getDerivedStateFromError === "function" || (fiber.lanes & 2) === 0 && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
      });
    }
    function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32_768;
      isDevelopmentToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
      if (value !== null && typeof value === "object" && typeof value.then === "function") {
        returnFiber = sourceFiber.alternate;
        returnFiber !== null && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, true);
        isHydrating && (didSuspendOrErrorDEV = true);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (sourceFiber !== null) {
          switch (sourceFiber.tag) {
            case 13: {
              return shellBoundary === null ? renderDidSuspendDelayIfPossible() : sourceFiber.alternate === null && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65_536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16_384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            case 22: {
              return sourceFiber.flags |= 65_536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16_384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, sourceFiber === null ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
          }
          throw new Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
        }
        attachPingListener(root2, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, returnFiber === null ? (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(new Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", { cause: value }), sourceFiber)), root2 = root2.current.alternate, root2.flags |= 65_536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root2.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)) : ((returnFiber.flags & 65_536) === 0 && (returnFiber.flags |= 256), returnFiber.flags |= 65_536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(new Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", { cause: value }), sourceFiber))), false;
      let error = createCapturedValueAtFiber(new Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: value }), sourceFiber);
      workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
      if (returnFiber === null)
        return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3: {
            return sourceFiber.flags |= 65_536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
          }
          case 1: {
            if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, (sourceFiber.flags & 128) === 0 && (typeof returnFiber.getDerivedStateFromError === "function" || error !== null && typeof error.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
              return sourceFiber.flags |= 65_536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root2, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
        }
        sourceFiber = sourceFiber.return;
      } while (sourceFiber !== null);
      return false;
    }
    function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = current2 === null ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
    }
    function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      const ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          key !== "ref" && (propsWithoutRef[key] = nextProps[key]);
      } else
        propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      markComponentRenderStarted(workInProgress2);
      nextProps = renderWithHooks(current2, workInProgress2, Component, propsWithoutRef, ref, renderLanes2);
      key = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 === null) {
        var type = Component.type;
        if (typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined && Component.compare === null)
          return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        current2 = createFiberFromTypeAndProperties(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
        current2.ref = workInProgress2.ref;
        current2.return = workInProgress2;
        return workInProgress2.child = current2;
      }
      type = current2.child;
      if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
        const prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = Component === null ? shallowEqual : Component;
        if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current2 = createWorkInProgress(type, nextProps);
      current2.ref = workInProgress2.ref;
      current2.return = workInProgress2;
      return workInProgress2.child = current2;
    }
    function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 !== null) {
        const prevProps = current2.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
            (current2.flags & 131_072) !== 0 && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
    }
    function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
      let nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = current2 === null ? null : current2.memoizedState;
      if (nextProps.mode === "hidden") {
        if ((workInProgress2.flags & 128) !== 0) {
          nextProps = prevState === null ? renderLanes2 : prevState.baseLanes | renderLanes2;
          if (current2 === null) {workInProgress2.childLanes = 0, workInProgress2.child = null;} else
            {
            nextChildren = workInProgress2.child = current2.child;
            for (prevState = 0;nextChildren !== null; )
              prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
            workInProgress2.childLanes = prevState & ~nextProps;
          }
          return deferHiddenOffscreenComponent(current2, workInProgress2, nextProps, renderLanes2);
        }
        if ((renderLanes2 & 536_870_912) === 0)
          {return workInProgress2.lanes = workInProgress2.childLanes = 536_870_912, deferHiddenOffscreenComponent(current2, workInProgress2, prevState === null ? renderLanes2 : prevState.baseLanes | renderLanes2, renderLanes2);}
        else
          {workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, current2 !== null && pushTransition(workInProgress2, prevState === null ? null : prevState.cachePool), prevState === null ? reuseHiddenContextOnStack(workInProgress2) : pushHiddenContext(workInProgress2, prevState), pushOffscreenSuspenseHandler(workInProgress2);}
      } else
        prevState === null ? (current2 !== null && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2)) : (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null);
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
      let JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = JSCompiler_inline_result === null ? null : {
        parent: CacheContext._currentValue,
        pool: JSCompiler_inline_result
      };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      current2 !== null && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack(workInProgress2);
      pushOffscreenSuspenseHandler(workInProgress2);
      current2 !== null && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
      return null;
    }
    function markRef(current2, workInProgress2) {
      const ref = workInProgress2.ref;
      if (ref === null)
        current2 !== null && current2.ref !== null && (workInProgress2.flags |= 4_194_816);
      else {
        if (typeof ref !== "function" && typeof ref !== "object")
          throw new Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        if (current2 === null || current2.ref !== ref)
          workInProgress2.flags |= 4_194_816;
      }
    }
    function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (Component.prototype && typeof Component.prototype.render === "function") {
        var componentName2 = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName2] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName2, componentName2), didWarnAboutBadClass[componentName2] = true);
      }
      workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
      current2 === null && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName2))));
      prepareToReadContext(workInProgress2);
      markComponentRenderStarted(workInProgress2);
      Component = renderWithHooks(current2, workInProgress2, Component, nextProps, undefined, renderLanes2);
      nextProps = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      markComponentRenderStarted(workInProgress2);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(workInProgress2, Component, nextProps, secondArg);
      finishRenderingHooks(current2, workInProgress2);
      Component = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      switch (shouldErrorImpl(workInProgress2)) {
        case false: {
          var _instance = workInProgress2.stateNode, state = new workInProgress2.type(workInProgress2.memoizedProps, _instance.context).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        }
        case true: {
          workInProgress2.flags |= 128;
          workInProgress2.flags |= 65_536;
          _instance = new Error("Simulated error coming from DevTools");
          var lane = renderLanes2 & -renderLanes2;
          workInProgress2.lanes |= lane;
          state = workInProgressRoot;
          if (state === null)
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(lane, state, workInProgress2, createCapturedValueAtFiber(_instance, workInProgress2));
          enqueueCapturedUpdate(workInProgress2, lane);
        }
      }
      prepareToReadContext(workInProgress2);
      if (workInProgress2.stateNode === null) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component && _instance !== null && (_instance === undefined || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = _instance === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _instance === "object" ? _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}." : " However, it is set to a " + typeof _instance + ".", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
        typeof _instance === "object" && _instance !== null && (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(true);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        state = workInProgress2.memoizedState = _instance.state !== null && _instance.state !== undefined ? _instance.state : null;
        _instance.updater = classComponentUpdater;
        workInProgress2.stateNode = _instance;
        _instance._reactInternals = workInProgress2;
        _instance._reactInternalInstance = fakeInternalInstance;
        typeof Component.getDerivedStateFromProps === "function" && state === null && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, _instance.state === null ? "null" : "undefined", state)));
        if (typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") {
          var foundWillUpdateName = lane = state = null;
          typeof _instance.componentWillMount === "function" && _instance.componentWillMount.__suppressDeprecationWarning !== true ? state = "componentWillMount" : typeof _instance.UNSAFE_componentWillMount === "function" && (state = "UNSAFE_componentWillMount");
          typeof _instance.componentWillReceiveProps === "function" && _instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? lane = "componentWillReceiveProps" : typeof _instance.UNSAFE_componentWillReceiveProps === "function" && (lane = "UNSAFE_componentWillReceiveProps");
          typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof _instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (state !== null || lane !== null || foundWillUpdateName !== null) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _instance, newApiName, state === null ? "" : `
  ` + state, lane === null ? "" : `
  ` + lane, foundWillUpdateName === null ? "" : `
  ` + foundWillUpdateName));
          }
        }
        _instance = workInProgress2.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render || (Component.prototype && typeof Component.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
        !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
        _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
        _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
        Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
        Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
        typeof _instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
        Component.prototype && Component.prototype.isPureReactComponent && _instance.shouldComponentUpdate !== undefined && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
        typeof _instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
        typeof _instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
        typeof _instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
        typeof _instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
        lane = _instance.props !== nextProps;
        _instance.props !== undefined && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
        _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
        typeof _instance.getSnapshotBeforeUpdate !== "function" || typeof _instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
        typeof _instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof _instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof Component.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
        (lane = _instance.state) && (typeof lane !== "object" || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
        typeof _instance.getChildContext === "function" && typeof Component.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
        _instance = workInProgress2.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress2.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress2);
        state = Component.contextType;
        _instance.context = typeof state === "object" && state !== null ? readContext(state) : emptyContextObject;
        _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
        workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, _instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, _instance);
        _instance.state = workInProgress2.memoizedState;
        state = Component.getDerivedStateFromProps;
        typeof state === "function" && (applyDerivedStateFromProps(workInProgress2, Component, state, nextProps), _instance.state = workInProgress2.memoizedState);
        typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function" || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (state = _instance.state, typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
        typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4_194_308);
        (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134_217_728);
        _instance = true;
      } else if (current2 === null) {
        _instance = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        typeof foundWillUpdateName === "object" && foundWillUpdateName !== null && (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName = typeof newApiName === "function" || typeof _instance.getSnapshotBeforeUpdate === "function";
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        foundWillUpdateName || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, state);
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (typeof newApiName === "function" && (applyDerivedStateFromProps(workInProgress2, Component, newApiName, nextProps), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount()), typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4_194_308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134_217_728)) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4_194_308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134_217_728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4_194_308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134_217_728), _instance = false);
      } else {
        _instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        state = workInProgress2.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress2.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        typeof oldContext === "object" && oldContext !== null && (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = typeof unresolvedOldProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, lane);
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        let newState = workInProgress2.memoizedState;
        state !== newApiName || oldState !== newState || hasForceUpdate || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies) ? (typeof unresolvedOldProps === "function" && (applyDerivedStateFromProps(workInProgress2, Component, unresolvedOldProps, nextProps), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies)) ? (oldContext || typeof _instance.UNSAFE_componentWillUpdate !== "function" && typeof _instance.componentWillUpdate !== "function" || (typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate(nextProps, newState, lane), typeof _instance.UNSAFE_componentWillUpdate === "function" && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), typeof _instance.componentDidUpdate === "function" && (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate === "function" && (workInProgress2.flags |= 1024)) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
      }
      lane = _instance;
      markRef(current2, workInProgress2);
      state = (workInProgress2.flags & 128) !== 0;
      if (lane || state) {
        lane = workInProgress2.stateNode;
        setCurrentFiber(workInProgress2);
        if (state && typeof Component.getDerivedStateFromError !== "function")
          Component = null, profilerStartTime = -1;
        else {
          markComponentRenderStarted(workInProgress2);
          Component = callRenderInDEV(lane);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              callRenderInDEV(lane);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          markComponentRenderStopped();
        }
        workInProgress2.flags |= 1;
        current2 !== null && state ? (workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), workInProgress2.child = reconcileChildFibers(workInProgress2, null, Component, renderLanes2)) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
        workInProgress2.memoizedState = lane.state;
        current2 = workInProgress2.child;
      } else
        current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      renderLanes2 = workInProgress2.stateNode;
      _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component"), didWarnAboutReassigningProps = true);
      return current2;
    }
    function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function validateFunctionComponentInDev(workInProgress2, Component) {
      Component && Component.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, Component.displayName || Component.name || "Component");
      typeof Component.getDerivedStateFromProps === "function" && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress2), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
      typeof Component.contextType === "object" && Component.contextType !== null && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
    }
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
      current2 = current2 === null ? 0 : current2.childLanes & ~renderLanes2;
      primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
      return current2;
    }
    function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
      let JSCompiler_object_inline_digest_2451;
      let JSCompiler_object_inline_stack_2452 = workInProgress2.pendingProps;
      shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
      let JSCompiler_object_inline_componentStack_2453 = false;
      const didSuspend = (workInProgress2.flags & 128) !== 0;
      (JSCompiler_object_inline_digest_2451 = didSuspend) || (JSCompiler_object_inline_digest_2451 = current2 !== null && current2.memoizedState === null ? false : (suspenseStackCursor.current & ForceSuspenseFallback) !== 0);
      JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_componentStack_2453 = true, workInProgress2.flags &= -129);
      JSCompiler_object_inline_digest_2451 = (workInProgress2.flags & 32) !== 0;
      workInProgress2.flags &= -33;
      if (current2 === null) {
        if (isHydrating) {
          JSCompiler_object_inline_componentStack_2453 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
          if (isHydrating) {
            var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
            var JSCompiler_temp;
            if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
              c: {
                var instance = JSCompiler_object_inline_message_2450;
                for (JSCompiler_temp = rootOrSingletonContext;instance.nodeType !== 8; ) {
                  if (!JSCompiler_temp) {
                    JSCompiler_temp = null;
                    break c;
                  }
                  instance = getNextHydratable(instance.nextSibling);
                  if (instance === null) {
                    JSCompiler_temp = null;
                    break c;
                  }
                }
                JSCompiler_temp = instance;
              }
              JSCompiler_temp === null ? JSCompiler_temp = false : (warnIfNotHydrating(), workInProgress2.memoizedState = {
                dehydrated: JSCompiler_temp,
                treeContext: treeContextProvider === null ? null : { id: treeContextId, overflow: treeContextOverflow },
                retryLane: 536_870_912,
                hydrationErrors: null
              }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress2, workInProgress2.child = instance, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp = true);
              JSCompiler_temp = !JSCompiler_temp;
            }
            JSCompiler_temp && (warnNonHydratedInstance(workInProgress2, JSCompiler_object_inline_message_2450), throwOnHydrationMismatch(workInProgress2));
          }
          JSCompiler_object_inline_message_2450 = workInProgress2.memoizedState;
          if (JSCompiler_object_inline_message_2450 !== null && (JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_message_2450.dehydrated, JSCompiler_object_inline_message_2450 !== null))
            return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536_870_912, null;
          popSuspenseHandler(workInProgress2);
        }
        JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_stack_2452.children;
        JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_stack_2452.fallback;
        if (JSCompiler_object_inline_componentStack_2453)
          return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = workInProgress2.mode, JSCompiler_object_inline_message_2450 = mountWorkInProgressOffscreenFiber({
            mode: "hidden",
            children: JSCompiler_object_inline_message_2450
          }, JSCompiler_object_inline_componentStack_2453), JSCompiler_object_inline_stack_2452 = createFiberFromFragment(JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_componentStack_2453, renderLanes2, null), JSCompiler_object_inline_message_2450.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_message_2450.sibling = JSCompiler_object_inline_stack_2452, workInProgress2.child = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_componentStack_2453.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_object_inline_digest_2451, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, JSCompiler_object_inline_message_2450);
      }
      const prevState = current2.memoizedState;
      if (prevState !== null && (JSCompiler_object_inline_message_2450 = prevState.dehydrated, JSCompiler_object_inline_message_2450 !== null)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2)) : (workInProgress2.memoizedState === null ? (reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_object_inline_stack_2452 = mountWorkInProgressOffscreenFiber({
            mode: "visible",
            children: JSCompiler_object_inline_stack_2452.children
          }, JSCompiler_object_inline_message_2450), JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_message_2450, renderLanes2, null), JSCompiler_object_inline_componentStack_2453.flags |= 2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), JSCompiler_object_inline_stack_2452 = workInProgress2.child, JSCompiler_object_inline_stack_2452.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2452.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_object_inline_digest_2451, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = JSCompiler_object_inline_componentStack_2453) : (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug."), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)) {
          JSCompiler_object_inline_digest_2451 = JSCompiler_object_inline_message_2450.nextSibling && JSCompiler_object_inline_message_2450.nextSibling.dataset;
          if (JSCompiler_object_inline_digest_2451) {
            JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
            var message = JSCompiler_object_inline_digest_2451.msg;
            instance = JSCompiler_object_inline_digest_2451.stck;
            var componentStack = JSCompiler_object_inline_digest_2451.cstck;
          }
          JSCompiler_object_inline_message_2450 = message;
          JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
          JSCompiler_object_inline_stack_2452 = instance;
          JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 = componentStack;
          JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_message_2450 ? new Error(JSCompiler_object_inline_message_2450) : new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          JSCompiler_object_inline_componentStack_2453.stack = JSCompiler_object_inline_stack_2452 || "";
          JSCompiler_object_inline_componentStack_2453.digest = JSCompiler_object_inline_digest_2451;
          JSCompiler_object_inline_digest_2451 = JSCompiler_temp === undefined ? null : JSCompiler_temp;
          JSCompiler_object_inline_stack_2452 = {
            value: JSCompiler_object_inline_componentStack_2453,
            source: null,
            stack: JSCompiler_object_inline_digest_2451
          };
          typeof JSCompiler_object_inline_digest_2451 === "string" && CapturedStacks.set(JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_stack_2452);
          queueHydrationError(JSCompiler_object_inline_stack_2452);
          workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        } else if (didReceiveUpdate || propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), JSCompiler_object_inline_digest_2451 = (renderLanes2 & current2.childLanes) !== 0, didReceiveUpdate || JSCompiler_object_inline_digest_2451) {
          JSCompiler_object_inline_digest_2451 = workInProgressRoot;
          if (JSCompiler_object_inline_digest_2451 !== null && (JSCompiler_object_inline_stack_2452 = renderLanes2 & -renderLanes2, JSCompiler_object_inline_stack_2452 = (JSCompiler_object_inline_stack_2452 & 42) === 0 ? getBumpedLaneForHydrationByLane(JSCompiler_object_inline_stack_2452) : 1, JSCompiler_object_inline_stack_2452 = (JSCompiler_object_inline_stack_2452 & (JSCompiler_object_inline_digest_2451.suspendedLanes | renderLanes2)) === 0 ? JSCompiler_object_inline_stack_2452 : 0, JSCompiler_object_inline_stack_2452 !== 0 && JSCompiler_object_inline_stack_2452 !== prevState.retryLane))
            throw prevState.retryLane = JSCompiler_object_inline_stack_2452, enqueueConcurrentRenderForLane(current2, JSCompiler_object_inline_stack_2452), scheduleUpdateOnFiber(JSCompiler_object_inline_digest_2451, current2, JSCompiler_object_inline_stack_2452), SelectiveHydrationException;
          JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        } else
          JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(JSCompiler_object_inline_message_2450.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, current2 !== null && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current2.id, treeContextOverflow = current2.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(workInProgress2, JSCompiler_object_inline_stack_2452.children), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (JSCompiler_object_inline_componentStack_2453)
        return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_temp = current2.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2452 = createWorkInProgress(JSCompiler_temp, {
          mode: "hidden",
          children: JSCompiler_object_inline_stack_2452.children
        }), JSCompiler_object_inline_stack_2452.subtreeFlags = JSCompiler_temp.subtreeFlags & 65_011_712, instance === null ? (JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_message_2450, renderLanes2, null), JSCompiler_object_inline_componentStack_2453.flags |= 2) : JSCompiler_object_inline_componentStack_2453 = createWorkInProgress(instance, JSCompiler_object_inline_componentStack_2453), JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_message_2450 = current2.child.memoizedState, JSCompiler_object_inline_message_2450 === null ? JSCompiler_object_inline_message_2450 = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp = JSCompiler_object_inline_message_2450.cachePool, JSCompiler_temp === null ? JSCompiler_temp = getSuspendedCache() : (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent === instance ? JSCompiler_temp : { parent: instance, pool: instance }), JSCompiler_object_inline_message_2450 = {
          baseLanes: JSCompiler_object_inline_message_2450.baseLanes | renderLanes2,
          cachePool: JSCompiler_temp
        }), JSCompiler_object_inline_componentStack_2453.memoizedState = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_object_inline_digest_2451, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current2.child;
      current2 = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: JSCompiler_object_inline_stack_2452.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      current2 !== null && (JSCompiler_object_inline_digest_2451 = workInProgress2.deletions, JSCompiler_object_inline_digest_2451 === null ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2451.push(current2));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber({ mode: "visible", children: primaryChildren }, workInProgress2.mode);
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiber(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      offscreenProps.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      };
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      current2 = mountSuspensePrimaryChildren(workInProgress2, workInProgress2.pendingProps.children);
      current2.flags |= 2;
      workInProgress2.memoizedState = null;
      return current2;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      const alternate = fiber.alternate;
      alternate !== null && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      let isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && typeof getIteratorFunction(childSlot) === "function";
      return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), false) : true;
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
      const renderState = workInProgress2.memoizedState;
      renderState === null ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
    }
    function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
      let nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      nextProps = nextProps.children;
      if (revealOrder !== undefined && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder])
        if (didWarnAboutRevealOrder[revealOrder] = true, typeof revealOrder === "string")
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            }
            default: {
              console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
            }
          }
        else
          console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
      tailMode === undefined || didWarnAboutTailOptions[tailMode] || (tailMode !== "collapsed" && tailMode !== "hidden" ? (didWarnAboutTailOptions[tailMode] = true, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : revealOrder !== "forwards" && revealOrder !== "backwards" && (didWarnAboutTailOptions[tailMode] = true, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
      a:
        if ((revealOrder === "forwards" || revealOrder === "backwards") && nextProps !== undefined && nextProps !== null && nextProps !== false)
          if (isArrayImpl(nextProps))
            for (var i = 0;i < nextProps.length; i++) {
              if (!validateSuspenseListNestedChild(nextProps[i], i))
                break a;
            }
          else if (i = getIteratorFunction(nextProps), typeof i === "function") {
            if (i = i.call(nextProps))
              for (let step = i.next(), _index = 0;!step.done; step = i.next()) {
                if (!validateSuspenseListNestedChild(step.value, _index))
                  break a;
                _index++;
              }
          } else
            console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      nextProps = suspenseStackCursor.current;
      if ((nextProps & ForceSuspenseFallback) === 0)
        {
        if (current2 !== null && (current2.flags & 128) !== 0)
          a:
            for (current2 = workInProgress2.child;current2 !== null; ) {
              if (current2.tag === 13)
                current2.memoizedState !== null && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (current2.tag === 19)
                scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (current2.child !== null) {
                current2.child.return = current2;
                current2 = current2.child;
                continue;
              }
              if (current2 === workInProgress2)
                break a;
              for (;current2.sibling === null; ) {
                if (current2.return === null || current2.return === workInProgress2)
                  break a;
                current2 = current2.return;
              }
              current2.sibling.return = current2.return;
              current2 = current2.sibling;
            }
        nextProps &= SubtreeSuspenseContextMask;
      }
      else {nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;}
      push(suspenseStackCursor, nextProps, workInProgress2);
      switch (revealOrder) {
        case "forwards": {
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null;renderLanes2 !== null; )
            current2 = renderLanes2.alternate, current2 !== null && findFirstSuspended(current2) === null && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          renderLanes2 === null ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(workInProgress2, false, revealOrder, renderLanes2, tailMode);
          break;
        }
        case "backwards": {
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null;revealOrder !== null; ) {
            current2 = revealOrder.alternate;
            if (current2 !== null && findFirstSuspended(current2) === null) {
              workInProgress2.child = revealOrder;
              break;
            }
            current2 = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current2;
          }
          initSuspenseListRenderState(workInProgress2, true, renderLanes2, null, tailMode);
          break;
        }
        case "together": {
          initSuspenseListRenderState(workInProgress2, false, null, null);
          break;
        }
        default: {
          workInProgress2.memoizedState = null;
        }
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
      current2 !== null && (workInProgress2.dependencies = current2.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if ((renderLanes2 & workInProgress2.childLanes) === 0)
        if (current2 === null) {return null;} else
          {
          if (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), (renderLanes2 & workInProgress2.childLanes) === 0)
            return null;
        }
      if (current2 !== null && workInProgress2.child !== current2.child)
        throw new Error("Resuming work not yet implemented.");
      if (workInProgress2.child !== null) {
        current2 = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2;current2.sibling !== null; )
          current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current2, renderLanes2) {
      if ((current2.lanes & renderLanes2) !== 0)
        return true;
      current2 = current2.dependencies;
      return current2 !== null && checkIfContextChanged(current2) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3: {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
          resetHydrationState();
          break;
        }
        case 27:
        case 5: {
          pushHostContext(workInProgress2);
          break;
        }
        case 4: {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        }
        case 10: {
          pushProvider(workInProgress2, workInProgress2.type, workInProgress2.memoizedProps.value);
          break;
        }
        case 12: {
          (renderLanes2 & workInProgress2.childLanes) !== 0 && (workInProgress2.flags |= 4);
          workInProgress2.flags |= 2048;
          var stateNode = workInProgress2.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        }
        case 13: {
          stateNode = workInProgress2.memoizedState;
          if (stateNode !== null) {
            if (stateNode.dehydrated !== null)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if ((renderLanes2 & workInProgress2.child.childLanes) !== 0)
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            return current2 === null ? null : current2.sibling;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        }
        case 19: {
          let didSuspendBefore = (current2.flags & 128) !== 0;
          stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0;
          stateNode || (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0);
          if (didSuspendBefore) {
            if (stateNode)
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          didSuspendBefore !== null && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current, workInProgress2);
          if (stateNode)
            break;
          else
            return null;
        }
        case 22:
        case 23: {
          return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
        }
        case 24: {
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
        }
      }
      return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
    }
    function beginWork(current2, workInProgress2, renderLanes2) {
      if (workInProgress2._debugNeedsRemount && current2 !== null) {
        renderLanes2 = createFiberFromTypeAndProperties(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes);
        renderLanes2._debugStack = workInProgress2._debugStack;
        renderLanes2._debugTask = workInProgress2._debugTask;
        var returnFiber = workInProgress2.return;
        if (returnFiber === null)
          throw new Error("Cannot swap the root fiber.");
        current2.alternate = null;
        workInProgress2.alternate = null;
        renderLanes2.index = workInProgress2.index;
        renderLanes2.sibling = workInProgress2.sibling;
        renderLanes2.return = workInProgress2.return;
        renderLanes2.ref = workInProgress2.ref;
        renderLanes2._debugInfo = workInProgress2._debugInfo;
        if (workInProgress2 === returnFiber.child)
          returnFiber.child = renderLanes2;
        else {
          var previousSibling = returnFiber.child;
          if (previousSibling === null)
            throw new Error("Expected parent to have a child.");
          for (;previousSibling.sibling !== workInProgress2; )
            if (previousSibling = previousSibling.sibling, previousSibling === null)
              throw new Error("Expected to find the previous sibling.");
          previousSibling.sibling = renderLanes2;
        }
        workInProgress2 = returnFiber.deletions;
        workInProgress2 === null ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
        renderLanes2.flags |= 2;
        return renderLanes2;
      }
      if (current2 === null)
        {
        didReceiveUpdate = false;
        if (returnFiber = isHydrating)
          warnIfNotHydrating(), returnFiber = (workInProgress2.flags & 1_048_576) !== 0;
        returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
      }
      else {if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current2, renderLanes2) && (workInProgress2.flags & 128) === 0)
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
          didReceiveUpdate = (current2.flags & 131_072) === 0 ? false : true;
        }}
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16: {
          a:
            if (returnFiber = workInProgress2.pendingProps, current2 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current2, typeof current2 === "function")
              shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(current2, returnFiber), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(null, workInProgress2, current2, returnFiber, renderLanes2)) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(null, workInProgress2, current2, returnFiber, renderLanes2));
            else {
              if (current2 !== undefined && current2 !== null) {
                if (previousSibling = current2.$$typeof, previousSibling === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2.type = current2 = resolveForwardReferenceForHotReloading(current2);
                  workInProgress2 = updateForwardRef(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                } else if (previousSibling === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                }
              }
              workInProgress2 = "";
              current2 !== null && typeof current2 === "object" && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
              current2 = getComponentNameFromType(current2) || current2;
              throw new Error("Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2);
            }
          return workInProgress2;
        }
        case 0: {
          return updateFunctionComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        }
        case 1: {
          return returnFiber = workInProgress2.type, previousSibling = resolveClassComponentProps(returnFiber, workInProgress2.pendingProps), updateClassComponent(current2, workInProgress2, returnFiber, previousSibling, renderLanes2);
        }
        case 3: {
          a: {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            if (current2 === null)
              throw new Error("Should have a current fiber. This is a bug in React.");
            returnFiber = workInProgress2.pendingProps;
            var previousState = workInProgress2.memoizedState;
            previousSibling = previousState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            returnFiber = nextState.cache;
            pushProvider(workInProgress2, CacheContext, returnFiber);
            returnFiber !== previousState.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true);
            suspendIfUpdateReadFromEntangledAsyncAction();
            returnFiber = nextState.element;
            if (previousState.isDehydrated)
              if (previousState = {
                element: returnFiber,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = previousState, workInProgress2.memoizedState = previousState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, returnFiber, renderLanes2);
                break a;
              } else if (returnFiber === previousSibling) {
                current2 = workInProgress2.stateNode.containerInfo;
                switch (current2.nodeType) {
                  case 9: {
                    current2 = current2.body;
                    break;
                  }
                  default: {
                    current2 = current2.nodeName === "HTML" ? current2.ownerDocument.body : current2;
                  }
                }
                nextHydratableInstance = getNextHydratable(current2.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                didSuspendOrErrorDEV = false;
                hydrationDiffRootDEV = null;
                rootOrSingletonContext = true;
                current2 = mountChildFibers(workInProgress2, null, returnFiber, renderLanes2);
                for (workInProgress2.child = current2;current2; )
                  current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
              } else {
                previousSibling = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                queueHydrationError(previousSibling);
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, returnFiber, renderLanes2);
                break a;
              }
            else {
              resetHydrationState();
              if (returnFiber === previousSibling) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                break a;
              }
              reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        }
        case 26: {
          return markRef(current2, workInProgress2), current2 === null ? ((current2 = getResource(workInProgress2.type, null, workInProgress2.pendingProps, null)) ? workInProgress2.memoizedState = current2 : isHydrating || (current2 = workInProgress2.type, renderLanes2 = workInProgress2.pendingProps, returnFiber = requiredContext(rootInstanceStackCursor.current), returnFiber = getOwnerDocumentFromRootContainer(returnFiber).createElement(current2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropertiesKey] = renderLanes2, setInitialProperties(returnFiber, current2, renderLanes2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber)) : workInProgress2.memoizedState = getResource(workInProgress2.type, current2.memoizedProps, workInProgress2.pendingProps, current2.memoizedState), null;
        }
        case 27: {
          return pushHostContext(workInProgress2), current2 === null && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), previousSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(workInProgress2.type, workInProgress2.pendingProps, returnFiber, previousSibling, false), didSuspendOrErrorDEV || (previousSibling = diffHydratedProperties(returnFiber, workInProgress2.type, workInProgress2.pendingProps, previousSibling), previousSibling !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = previousSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, previousSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = previousSibling, nextHydratableInstance = getNextHydratable(returnFiber.firstChild)) : nextHydratableInstance = previousSibling), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), markRef(current2, workInProgress2), current2 === null && (workInProgress2.flags |= 4_194_304), workInProgress2.child;
        }
        case 5: {
          return current2 === null && isHydrating && (previousState = getHostContext(), returnFiber = validateDOMNesting(workInProgress2.type, previousState.ancestorInfo), previousSibling = nextHydratableInstance, (nextState = !previousSibling) || (nextState = canHydrateInstance(previousSibling, workInProgress2.type, workInProgress2.pendingProps, rootOrSingletonContext), nextState === null ? previousState = false : (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (previousState = diffHydratedProperties(nextState, workInProgress2.type, workInProgress2.pendingProps, previousState), previousState !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = previousState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(nextState.firstChild), rootOrSingletonContext = false, previousState = true), nextState = !previousState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, previousSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), previousSibling = workInProgress2.type, previousState = workInProgress2.pendingProps, nextState = current2 === null ? null : current2.memoizedProps, returnFiber = previousState.children, shouldSetTextContent(previousSibling, previousState) ? returnFiber = null : nextState !== null && shouldSetTextContent(previousSibling, nextState) && (workInProgress2.flags |= 32), workInProgress2.memoizedState !== null && (previousSibling = renderWithHooks(current2, workInProgress2, TransitionAwareHostComponent, null, null, renderLanes2), HostTransitionContext._currentValue = previousSibling), markRef(current2, workInProgress2), reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        }
        case 6: {
          return current2 === null && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), returnFiber = renderLanes2.ancestorInfo.current, current2 = returnFiber == undefined ? true : validateTextNesting(current2, returnFiber.tag, renderLanes2.ancestorInfo.implicitRootScope), renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(renderLanes2, workInProgress2.pendingProps, rootOrSingletonContext), returnFiber === null ? returnFiber = false : (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true), returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
        }
        case 13: {
          return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
        }
        case 4: {
          return pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo), returnFiber = workInProgress2.pendingProps, current2 === null ? workInProgress2.child = reconcileChildFibers(workInProgress2, null, returnFiber, renderLanes2) : reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        }
        case 11: {
          return updateForwardRef(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        }
        case 7: {
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps, renderLanes2), workInProgress2.child;
        }
        case 8: {
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        }
        case 12: {
          return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        }
        case 10: {
          return returnFiber = workInProgress2.type, previousSibling = workInProgress2.pendingProps, previousState = previousSibling.value, "value" in previousSibling || hasWarnedAboutUsingNoValuePropertyOnContextProvider || (hasWarnedAboutUsingNoValuePropertyOnContextProvider = true, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress2, returnFiber, previousState), reconcileChildren(current2, workInProgress2, previousSibling.children, renderLanes2), workInProgress2.child;
        }
        case 9: {
          return previousSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, typeof returnFiber !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress2), previousSibling = readContext(previousSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(returnFiber, previousSibling), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        }
        case 14: {
          return updateMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        }
        case 15: {
          return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        }
        case 19: {
          return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
        }
        case 31: {
          return returnFiber = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, returnFiber = {
            mode: returnFiber.mode,
            children: returnFiber.children
          }, current2 === null ? (current2 = mountWorkInProgressOffscreenFiber(returnFiber, renderLanes2), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2) : (current2 = createWorkInProgress(current2.child, returnFiber), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2), workInProgress2;
        }
        case 22: {
          return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
        }
        case 24: {
          return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), current2 === null ? (previousSibling = peekCacheFromPool(), previousSibling === null && (previousSibling = workInProgressRoot, previousState = createCache(), previousSibling.pooledCache = previousState, retainCache(previousState), previousState !== null && (previousSibling.pooledCacheLanes |= renderLanes2), previousSibling = previousState), workInProgress2.memoizedState = {
            parent: returnFiber,
            cache: previousSibling
          }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, previousSibling)) : ((current2.lanes & renderLanes2) !== 0 && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), previousSibling = current2.memoizedState, previousState = workInProgress2.memoizedState, previousSibling.parent === returnFiber ? (returnFiber = previousState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== previousSibling.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true)) : (previousSibling = {
            parent: returnFiber,
            cache: returnFiber
          }, workInProgress2.memoizedState = previousSibling, workInProgress2.lanes === 0 && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = previousSibling), pushProvider(workInProgress2, CacheContext, returnFiber))), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        }
        case 29: {
          throw workInProgress2.pendingProps;
        }
      }
      throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if (resource.type !== "stylesheet" || (resource.state.loading & Inserted) !== NotLoaded)
        workInProgress2.flags &= -16_777_217;
      else if (workInProgress2.flags |= 16_777_216, !preloadResource(resource)) {
        resource = suspenseHandlerStackCursor.current;
        if (resource !== null && ((workInProgressRootRenderLanes & 4_194_048) === workInProgressRootRenderLanes ? shellBoundary !== null : (workInProgressRootRenderLanes & 62_914_560) !== workInProgressRootRenderLanes && (workInProgressRootRenderLanes & 536_870_912) === 0 || resource !== shellBoundary))
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        workInProgress2.flags |= 8192;
      }
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      retryQueue !== null && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16_384 && (retryQueue = workInProgress2.tag === 22 ? 536_870_912 : claimNextRetryLane(), workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden": {
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null;hasRenderedATailFallback !== null; )
              hasRenderedATailFallback.alternate !== null && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          }
          case "collapsed": {
            lastTailNode = renderState.tail;
            for (var _lastTailNode = null;lastTailNode !== null; )
              lastTailNode.alternate !== null && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
            _lastTailNode === null ? (hasRenderedATailFallback || renderState.tail === null ? renderState.tail = null : renderState.tail.sibling = null) : _lastTailNode.sibling = null;
          }
        }
    }
    function bubbleProperties(completedWork) {
      let didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        if ((completedWork.mode & ProfileMode) === NoMode) {for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
            newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65_011_712, subtreeFlags |= _treeBaseDuration.flags & 65_011_712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;} else
          {
          for (var { selfBaseDuration: _treeBaseDuration, child: _child2 } = completedWork;_child2 !== null; )
            newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65_011_712, subtreeFlags |= _child2.flags & 65_011_712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
          completedWork.treeBaseDuration = _treeBaseDuration;
        }
      else if ((completedWork.mode & ProfileMode) === NoMode) {for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
          newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;} else
        {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (let child = completedWork.child;child !== null; )
          newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      }
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current2, workInProgress2, renderLanes2) {
      let newProperties = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14: {
          return bubbleProperties(workInProgress2), null;
        }
        case 1: {
          return bubbleProperties(workInProgress2), null;
        }
        case 3: {
          renderLanes2 = workInProgress2.stateNode;
          newProperties = null;
          current2 !== null && (newProperties = current2.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProperties && (workInProgress2.flags |= 2048);
          popProvider(CacheContext, workInProgress2);
          popHostContainer(workInProgress2);
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (current2 === null || current2.child === null)
            popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : current2 === null || current2.memoizedState.isDehydrated && (workInProgress2.flags & 256) === 0 || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        }
        case 26: {
          return renderLanes2 = workInProgress2.memoizedState, current2 === null ? (markUpdate(workInProgress2), renderLanes2 === null ? (bubbleProperties(workInProgress2), workInProgress2.flags &= -16_777_217) : (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2))) : renderLanes2 ? renderLanes2 === current2.memoizedState ? (bubbleProperties(workInProgress2), workInProgress2.flags &= -16_777_217) : (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (current2.memoizedProps !== newProperties && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16_777_217), null;
        }
        case 27: {
          popHostContext(workInProgress2);
          renderLanes2 = requiredContext(rootInstanceStackCursor.current);
          var _type = workInProgress2.type;
          if (current2 !== null && workInProgress2.stateNode != undefined)
            current2.memoizedProps !== newProperties && markUpdate(workInProgress2);
          else {
            if (!newProperties) {
              if (workInProgress2.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress2);
              return null;
            }
            current2 = getHostContext();
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(_type, newProperties, renderLanes2, current2, true), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        }
        case 5: {
          popHostContext(workInProgress2);
          renderLanes2 = workInProgress2.type;
          if (current2 !== null && workInProgress2.stateNode != undefined)
            current2.memoizedProps !== newProperties && markUpdate(workInProgress2);
          else {
            if (!newProperties) {
              if (workInProgress2.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress2);
              return null;
            }
            _type = getHostContext();
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2, _type);
            else {
              current2 = requiredContext(rootInstanceStackCursor.current);
              validateDOMNesting(renderLanes2, _type.ancestorInfo);
              _type = _type.context;
              current2 = getOwnerDocumentFromRootContainer(current2);
              switch (_type) {
                case HostContextNamespaceSvg: {
                  current2 = current2.createElementNS(SVG_NAMESPACE, renderLanes2);
                  break;
                }
                case HostContextNamespaceMath: {
                  current2 = current2.createElementNS(MATH_NAMESPACE, renderLanes2);
                  break;
                }
                default: {
                  switch (renderLanes2) {
                    case "svg": {
                      current2 = current2.createElementNS(SVG_NAMESPACE, renderLanes2);
                      break;
                    }
                    case "math": {
                      current2 = current2.createElementNS(MATH_NAMESPACE, renderLanes2);
                      break;
                    }
                    case "script": {
                      current2 = current2.createElement("div");
                      current2.innerHTML = "<script></script>";
                      current2 = current2.removeChild(current2.firstChild);
                      break;
                    }
                    case "select": {
                      current2 = typeof newProperties.is === "string" ? current2.createElement("select", { is: newProperties.is }) : current2.createElement("select");
                      newProperties.multiple ? current2.multiple = true : newProperties.size && (current2.size = newProperties.size);
                      break;
                    }
                    default: {
                      current2 = typeof newProperties.is === "string" ? current2.createElement(renderLanes2, {
                        is: newProperties.is
                      }) : current2.createElement(renderLanes2), !renderLanes2.includes("-") && (renderLanes2 !== renderLanes2.toLowerCase() && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", renderLanes2), Object.prototype.toString.call(current2) !== "[object HTMLUnknownElement]" || hasOwnProperty.call(warnedUnknownTags, renderLanes2) || (warnedUnknownTags[renderLanes2] = true, console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", renderLanes2)));
                    }
                  }
                }
              }
              current2[internalInstanceKey] = workInProgress2;
              current2[internalPropertiesKey] = newProperties;
              a:
                for (_type = workInProgress2.child;_type !== null; ) {
                  if (_type.tag === 5 || _type.tag === 6)
                    current2.append(_type.stateNode);
                  else if (_type.tag !== 4 && _type.tag !== 27 && _type.child !== null) {
                    _type.child.return = _type;
                    _type = _type.child;
                    continue;
                  }
                  if (_type === workInProgress2)
                    break a;
                  for (;_type.sibling === null; ) {
                    if (_type.return === null || _type.return === workInProgress2)
                      break a;
                    _type = _type.return;
                  }
                  _type.sibling.return = _type.return;
                  _type = _type.sibling;
                }
              workInProgress2.stateNode = current2;
              a:
                switch (setInitialProperties(current2, renderLanes2, newProperties), renderLanes2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea": {
                    current2 = Boolean(newProperties.autoFocus);
                    break a;
                  }
                  case "img": {
                    current2 = true;
                    break a;
                  }
                  default: {
                    current2 = false;
                  }
                }
              current2 && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          workInProgress2.flags &= -16_777_217;
          return null;
        }
        case 6: {
          if (current2 && workInProgress2.stateNode != undefined)
            current2.memoizedProps !== newProperties && markUpdate(workInProgress2);
          else {
            if (typeof newProperties !== "string" && workInProgress2.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            current2 = requiredContext(rootInstanceStackCursor.current);
            renderLanes2 = getHostContext();
            if (popHydrationState(workInProgress2)) {
              current2 = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              _type = !didSuspendOrErrorDEV;
              newProperties = null;
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null)
                switch (returnFiber.tag) {
                  case 3: {
                    _type && (_type = diffHydratedTextForDevelopmentWarnings(current2, renderLanes2, newProperties), _type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
                    break;
                  }
                  case 27:
                  case 5: {
                    newProperties = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevelopmentWarnings(current2, renderLanes2, newProperties), _type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
                  }
                }
              current2[internalInstanceKey] = workInProgress2;
              current2 = current2.nodeValue === renderLanes2 || newProperties !== null && newProperties.suppressHydrationWarning === true || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
              current2 || throwOnHydrationMismatch(workInProgress2);
            } else
              _type = renderLanes2.ancestorInfo.current, _type != undefined && validateTextNesting(newProperties, _type.tag, renderLanes2.ancestorInfo.implicitRootScope), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(newProperties), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
          }
          bubbleProperties(workInProgress2);
          return null;
        }
        case 13: {
          newProperties = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
            _type = popHydrationState(workInProgress2);
            if (newProperties !== null && newProperties.dehydrated !== null) {
              if (current2 === null) {
                if (!_type)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                _type = workInProgress2.memoizedState;
                _type = _type === null ? null : _type.dehydrated;
                if (!_type)
                  throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                _type[internalInstanceKey] = workInProgress2;
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & ProfileMode) !== NoMode && newProperties !== null && (_type = workInProgress2.child, _type !== null && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(), resetHydrationState(), (workInProgress2.flags & 128) === 0 && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && newProperties !== null && (_type = workInProgress2.child, _type !== null && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
              _type = false;
            } else
              _type = upgradeHydrationErrorsToRecoverable(), current2 !== null && current2.memoizedState !== null && (current2.memoizedState.hydrationErrors = _type), _type = true;
            if (!_type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if ((workInProgress2.flags & 128) !== 0)
            return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
          renderLanes2 = newProperties !== null;
          current2 = current2 !== null && current2.memoizedState !== null;
          renderLanes2 && (newProperties = workInProgress2.child, _type = null, newProperties.alternate !== null && newProperties.alternate.memoizedState !== null && newProperties.alternate.memoizedState.cachePool !== null && (_type = newProperties.alternate.memoizedState.cachePool.pool), returnFiber = null, newProperties.memoizedState !== null && newProperties.memoizedState.cachePool !== null && (returnFiber = newProperties.memoizedState.cachePool.pool), returnFiber !== _type && (newProperties.flags |= 2048));
          renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
          return null;
        }
        case 4: {
          return popHostContainer(workInProgress2), current2 === null && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        }
        case 10: {
          return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
        }
        case 19: {
          pop(suspenseStackCursor, workInProgress2);
          _type = workInProgress2.memoizedState;
          if (_type === null)
            return bubbleProperties(workInProgress2), null;
          newProperties = (workInProgress2.flags & 128) !== 0;
          returnFiber = _type.rendering;
          if (returnFiber === null)
            if (newProperties)
              cutOffTailIfNeeded(_type, false);
            else {
              if (workInProgressRootExitStatus !== RootInProgress || current2 !== null && (current2.flags & 128) !== 0)
                for (current2 = workInProgress2.child;current2 !== null; ) {
                  returnFiber = findFirstSuspended(current2);
                  if (returnFiber !== null) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(_type, false);
                    current2 = returnFiber.updateQueue;
                    workInProgress2.updateQueue = current2;
                    scheduleRetryEffect(workInProgress2, current2);
                    workInProgress2.subtreeFlags = 0;
                    current2 = renderLanes2;
                    for (renderLanes2 = workInProgress2.child;renderLanes2 !== null; )
                      resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                    push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2);
                    return workInProgress2.child;
                  }
                  current2 = current2.sibling;
                }
              _type.tail !== null && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProperties = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4_194_304);
            }
          else {
            if (!newProperties)
              if (current2 = findFirstSuspended(returnFiber), current2 !== null) {
                if (workInProgress2.flags |= 128, newProperties = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(_type, true), _type.tail === null && _type.tailMode === "hidden" && !returnFiber.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && renderLanes2 !== 536_870_912 && (workInProgress2.flags |= 128, newProperties = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4_194_304);
            _type.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current2 = _type.last, current2 === null ? workInProgress2.child = returnFiber : current2.sibling = returnFiber, _type.last = returnFiber);
          }
          if (_type.tail !== null)
            return current2 = _type.tail, _type.rendering = current2, _type.tail = current2.sibling, _type.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProperties ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current2;
          bubbleProperties(workInProgress2);
          return null;
        }
        case 22:
        case 23: {
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProperties = workInProgress2.memoizedState !== null, current2 === null ? newProperties && (workInProgress2.flags |= 8192) : current2.memoizedState !== null !== newProperties && (workInProgress2.flags |= 8192), newProperties ? (renderLanes2 & 536_870_912) !== 0 && (workInProgress2.flags & 128) === 0 && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, renderLanes2 !== null && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (renderLanes2 = current2.memoizedState.cachePool.pool), newProperties = null, workInProgress2.memoizedState !== null && workInProgress2.memoizedState.cachePool !== null && (newProperties = workInProgress2.memoizedState.cachePool.pool), newProperties !== renderLanes2 && (workInProgress2.flags |= 2048), current2 !== null && pop(resumedCache, workInProgress2), null;
        }
        case 24: {
          return renderLanes2 = null, current2 !== null && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
        }
        case 25: {
          return null;
        }
        case 30: {
          return null;
        }
      }
      throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current2, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1: {
          return current2 = workInProgress2.flags, current2 & 65_536 ? (workInProgress2.flags = current2 & -65_537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        }
        case 3: {
          return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, (current2 & 65_536) !== 0 && (current2 & 128) === 0 ? (workInProgress2.flags = current2 & -65_537 | 128, workInProgress2) : null;
        }
        case 26:
        case 27:
        case 5: {
          return popHostContext(workInProgress2), null;
        }
        case 13: {
          popSuspenseHandler(workInProgress2);
          current2 = workInProgress2.memoizedState;
          if (current2 !== null && current2.dehydrated !== null) {
            if (workInProgress2.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current2 = workInProgress2.flags;
          return current2 & 65_536 ? (workInProgress2.flags = current2 & -65_537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        }
        case 19: {
          return pop(suspenseStackCursor, workInProgress2), null;
        }
        case 4: {
          return popHostContainer(workInProgress2), null;
        }
        case 10: {
          return popProvider(workInProgress2.type, workInProgress2), null;
        }
        case 22:
        case 23: {
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), current2 !== null && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65_536 ? (workInProgress2.flags = current2 & -65_537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        }
        case 24: {
          return popProvider(CacheContext, workInProgress2), null;
        }
        case 25: {
          return null;
        }
        default: {
          return null;
        }
      }
    }
    function unwindInterruptedWork(current2, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3: {
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        }
        case 26:
        case 27:
        case 5: {
          popHostContext(interruptedWork);
          break;
        }
        case 4: {
          popHostContainer(interruptedWork);
          break;
        }
        case 13: {
          popSuspenseHandler(interruptedWork);
          break;
        }
        case 19: {
          pop(suspenseStackCursor, interruptedWork);
          break;
        }
        case 10: {
          popProvider(interruptedWork.type, interruptedWork);
          break;
        }
        case 22:
        case 23: {
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          current2 !== null && pop(resumedCache, interruptedWork);
          break;
        }
        case 24: {
          popProvider(CacheContext, interruptedWork);
        }
      }
    }
    function shouldProfile(current2) {
      return (current2.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        let updateQueue = finishedWork.updateQueue, lastEffect = updateQueue === null ? null : updateQueue.lastEffect;
        if (lastEffect !== null) {
          const firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags && ((flags & Passive) === NoFlags ? (flags & Layout) !== NoFlags && injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function" && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork) : injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function" && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork), lastEffect = undefined, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) === NoFlags ? (flags & Layout) !== NoFlags && injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function" && injectedProfilingHooks.markComponentLayoutEffectMountStopped() : injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function" && injectedProfilingHooks.markComponentPassiveEffectMountStopped(), lastEffect !== undefined && typeof lastEffect !== "function")) {
              let hookName;
              hookName = (updateQueue.tag & Layout) === 0 ? ((updateQueue.tag & Insertion) === 0 ? "useEffect" : "useInsertionEffect") : "useLayoutEffect";
              let addendum;
              addendum = lastEffect === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : (typeof lastEffect.then === "function" ? `

It looks like you wrote ` + hookName + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + hookName + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + lastEffect);
              runWithFiberInDEV(finishedWork, function(n, a) {
                console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
              }, hookName, addendum);
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
      try {
        let updateQueue = finishedWork.updateQueue, lastEffect = updateQueue === null ? null : updateQueue.lastEffect;
        if (lastEffect !== null) {
          const firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              const inst = updateQueue.inst, destroy = inst.destroy;
              destroy !== undefined && (inst.destroy = undefined, (flags & Passive) === NoFlags ? (flags & Layout) !== NoFlags && injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function" && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork) : injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function" && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(lastEffect, callDestroyInDEV, lastEffect, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) === NoFlags ? (flags & Layout) !== NoFlags && injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function" && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped() : injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function" && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped());
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitClassCallbacks(finishedWork) {
      const updateQueue = finishedWork.updateQueue;
      if (updateQueue !== null) {
        const instance = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
        try {
          runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, previousProperties, prevState) {
      return instance.getSnapshotBeforeUpdate(previousProperties, prevState);
    }
    function commitClassSnapshot(finishedWork, current2) {
      let { memoizedProps: previousProperties, memoizedState: prevState } = current2;
      current2 = finishedWork.stateNode;
      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current2.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
      try {
        const resolvedPrevProps = resolveClassComponentProps(finishedWork.type, previousProperties, finishedWork.elementType === finishedWork.type);
        const snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current2, resolvedPrevProps, prevState);
        previousProperties = didWarnAboutUndefinedSnapshotBeforeUpdate;
        snapshot !== undefined || previousProperties.has(finishedWork.type) || (previousProperties.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
        }));
        current2.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(current2.type, current2.memoizedProps);
      instance.state = current2.memoizedState;
      shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance);
    }
    function commitAttachReference(finishedWork) {
      const ref = finishedWork.ref;
      if (ref !== null) {
        switch (finishedWork.tag) {
          case 26:
          case 27:
          case 5: {
            var instanceToUse = finishedWork.stateNode;
            break;
          }
          case 30: {
            instanceToUse = finishedWork.stateNode;
            break;
          }
          default: {
            instanceToUse = finishedWork.stateNode;
          }
        }
        if (typeof ref === "function")
          if (shouldProfile(finishedWork))
            try {
              startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
            } finally {
              recordEffectDuration();
            }
          else
            finishedWork.refCleanup = ref(instanceToUse);
        else
          typeof ref === "string" ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;
      }
    }
    function safelyAttachRef(current2, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current2, commitAttachReference, current2);
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      }
    }
    function safelyDetachReference(current2, nearestMountedAncestor) {
      const { ref, refCleanup } = current2;
      if (ref !== null)
        if (typeof refCleanup === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, refCleanup);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          } finally {
            current2.refCleanup = null, current2 = current2.alternate, current2 != undefined && (current2.refCleanup = null);
          }
        else if (typeof ref === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, ref, null);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, ref, null);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        else
          ref.current = null;
    }
    function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
      let _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize === "function" && _finishedWork$memoize(id, current2, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime2);
      typeof onCommit === "function" && onCommit(finishedWork.memoizedProps.id, current2, effectDuration, commitStartTime2);
    }
    function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
      let _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize2 === "function" && _finishedWork$memoize2(finishedWork, current2, passiveEffectDuration, commitStartTime2);
    }
    function commitHostMount(finishedWork) {
      const { type, memoizedProps: props, stateNode: instance } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return fiber.tag === 5 || fiber.tag === 3 || fiber.tag === 26 || fiber.tag === 27 && isSingletonScope(fiber.type) || fiber.tag === 4;
    }
    function getHostSibling(fiber) {
      a:
        for (;; ) {
          for (;fiber.sibling === null; ) {
            if (fiber.return === null || isHostParent(fiber.return))
              return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling;fiber.tag !== 5 && fiber.tag !== 6 && fiber.tag !== 18; ) {
            if (fiber.tag === 27 && isSingletonScope(fiber.type))
              continue a;
            if (fiber.flags & 2)
              continue a;
            if (fiber.child === null || fiber.tag === 4)
              continue a;
            else
              fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2))
            return fiber.stateNode;
        }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      const tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? (parent.nodeType === 9 ? parent.body : (parent.nodeName === "HTML" ? parent.ownerDocument.body : parent)).insertBefore(node, before) : (before = parent.nodeType === 9 ? parent.body : (parent.nodeName === "HTML" ? parent.ownerDocument.body : parent), before.appendChild(node), parent = parent._reactRootContainer, parent !== null && parent !== undefined || before.onclick !== null || (before.onclick = noop$1));
      else if (tag !== 4 && (tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, node !== null))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      const tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (tag !== 4 && (tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, node !== null))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitPlacement(finishedWork) {
      for (var hostParentFiber, parentFiber = finishedWork.return;parentFiber !== null; ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (hostParentFiber == undefined)
        throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      switch (hostParentFiber.tag) {
        case 27: {
          hostParentFiber = hostParentFiber.stateNode;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, parentFiber, hostParentFiber);
          break;
        }
        case 5: {
          parentFiber = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
          hostParentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, hostParentFiber, parentFiber);
          break;
        }
        case 3:
        case 4: {
          hostParentFiber = hostParentFiber.stateNode.containerInfo;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, hostParentFiber);
          break;
        }
        default: {
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      const { stateNode: singleton, memoizedProps: props } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, singleton, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitBeforeMutationEffects(root2, firstChild) {
      root2 = root2.containerInfo;
      eventsEnabled = _enabled;
      root2 = getActiveElementDeep(root2);
      if (hasSelectionCapabilities(root2)) {
        if ("selectionStart" in root2)
          var JSCompiler_temp = {
            start: root2.selectionStart,
            end: root2.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
            let selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && selection.rangeCount !== 0) {
              JSCompiler_temp = selection.anchorNode;
              var { anchorOffset, focusNode } = selection;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch {
                JSCompiler_temp = null;
                break a;
              }
              let length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
              b:
                for (;; ) {
                  for (var next;; ) {
                    node !== JSCompiler_temp || anchorOffset !== 0 && node.nodeType !== 3 || (start = length + anchorOffset);
                    node !== focusNode || selection !== 0 && node.nodeType !== 3 || (end = length + selection);
                    node.nodeType === 3 && (length += node.nodeValue.length);
                    if ((next = node.firstChild) === null)
                      break;
                    parentNode = node;
                    node = next;
                  }
                  for (;; ) {
                    if (node === root2)
                      break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if ((next = node.nextSibling) !== null)
                      break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
              JSCompiler_temp = start === -1 || end === -1 ? null : { start, end };
            } else
              JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else
        JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root2,
        selectionRange: JSCompiler_temp
      };
      _enabled = false;
      for (nextEffect = firstChild;nextEffect !== null; )
        if (firstChild = nextEffect, root2 = firstChild.child, (firstChild.subtreeFlags & 1024) !== 0 && root2 !== null)
          root2.return = firstChild, nextEffect = root2;
        else
          for (;nextEffect !== null; ) {
            root2 = firstChild = nextEffect;
            JSCompiler_temp = root2.alternate;
            anchorOffset = root2.flags;
            switch (root2.tag) {
              case 0: {
                break;
              }
              case 11:
              case 15: {
                break;
              }
              case 1: {
                (anchorOffset & 1024) !== 0 && JSCompiler_temp !== null && commitClassSnapshot(root2, JSCompiler_temp);
                break;
              }
              case 3: {
                if ((anchorOffset & 1024) !== 0) {
                  if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, JSCompiler_temp === 9)
                    clearContainerSparingly(root2);
                  else if (JSCompiler_temp === 1)
                    switch (root2.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY": {
                        clearContainerSparingly(root2);
                        break;
                      }
                      default: {
                        root2.textContent = "";
                      }
                    }
                }
                break;
              }
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17: {
                break;
              }
              default: {
                if ((anchorOffset & 1024) !== 0)
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            root2 = firstChild.sibling;
            if (root2 !== null) {
              root2.return = firstChild.return;
              nextEffect = root2;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
      let flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15: {
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        }
        case 1: {
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, current2 === null)
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);
            else {
              var prevProps = resolveClassComponentProps(finishedWork.type, current2.memoizedProps);
              current2 = current2.memoizedState;
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
              shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate);
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        }
        case 3: {
          current2 = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (flags = finishedWork.updateQueue, flags !== null)) {
            prevProps = null;
            if (finishedWork.child !== null)
              switch (finishedWork.child.tag) {
                case 27:
                case 5: {
                  prevProps = finishedWork.child.stateNode;
                  break;
                }
                case 1: {
                  prevProps = finishedWork.child.stateNode;
                }
              }
            try {
              runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current2);
          break;
        }
        case 27: {
          current2 === null && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        }
        case 26:
        case 5: {
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          current2 === null && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        }
        case 12: {
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, finishedRoot.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        }
        case 13: {
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        }
        case 22: {
          flags = finishedWork.memoizedState !== null || offscreenSubtreeIsHidden;
          if (!flags) {
            current2 = current2 !== null && current2.memoizedState !== null || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, (finishedWork.subtreeFlags & 8772) !== 0) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        }
        case 30: {
          break;
        }
        default: {
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
    }
    function detachFiberAfterEffects(fiber) {
      let alternate = fiber.alternate;
      alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      fiber.tag === 5 && (alternate = fiber.stateNode, alternate !== null && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child;parent !== null; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function")
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (error) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %s", error));
        }
      switch (deletedFiber.tag) {
        case 26: {
          offscreenSubtreeWasHidden || safelyDetachReference(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        }
        case 27: {
          offscreenSubtreeWasHidden || safelyDetachReference(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          runWithFiberInDEV(deletedFiber, releaseSingletonInstance, deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        }
        case 5: {
          offscreenSubtreeWasHidden || safelyDetachReference(deletedFiber, nearestMountedAncestor);
        }
        case 6: {
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (hostParent !== null)
            if (hostParentIsContainer)
              try {
                runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
              }
            else
              try {
                runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
              }
          break;
        }
        case 18: {
          hostParent !== null && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(finishedRoot.nodeType === 9 ? finishedRoot.body : (finishedRoot.nodeName === "HTML" ? finishedRoot.ownerDocument.body : finishedRoot), deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        }
        case 4: {
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        }
        case 0:
        case 11:
        case 14:
        case 15: {
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        }
        case 1: {
          offscreenSubtreeWasHidden || (safelyDetachReference(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, typeof prevHostParent.componentWillUnmount === "function" && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        }
        case 21: {
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        }
        case 22: {
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || deletedFiber.memoizedState !== null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        }
        default: {
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null))))
        try {
          runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19: {
          var retryCache = finishedWork.stateNode;
          retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet);
          return retryCache;
        }
        case 22: {
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, retryCache === null && (retryCache = finishedWork._retryCache = new PossiblyWeakSet), retryCache;
        }
        default: {
          throw new Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
        }
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      const retryCache = getRetryCache(finishedWork);
      for (const wakeable of wakeables) {
        const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevelopmentToolsPresent)
            if (inProgressLanes !== null && inProgressRoot !== null)
              restorePendingUpdaters(inProgressRoot, inProgressLanes);
            else
              throw new Error("Expected finished root and lanes to be set. This is a bug in React.");
          wakeable.then(retry, retry);
        }
      }
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      const deletions = parentFiber.deletions;
      if (deletions !== null)
        for (const deletedFiber of deletions) {
          let root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a:
            for (;parent !== null; ) {
              switch (parent.tag) {
                case 27: {
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                }
                case 5: {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                case 3:
                case 4: {
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
                }
              }
              parent = parent.return;
            }
          if (hostParent === null)
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = false;
          root2 = deletedFiber;
          returnFiber = root2.alternate;
          returnFiber !== null && (returnFiber.return = null);
          root2.return = null;
        }
      if (parentFiber.subtreeFlags & 13_878)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    function commitMutationEffectsOnFiber(finishedWork, root2) {
      let { alternate: current2, flags } = finishedWork;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15: {
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
          break;
        }
        case 1: {
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachReference(current2, current2.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, finishedWork !== null && (flags = finishedWork.callbacks, flags !== null && (current2 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = current2 === null ? flags : current2.concat(flags))));
          break;
        }
        case 26: {
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachReference(current2, current2.return));
          if (flags & 4)
            if (root2 = current2 === null ? null : current2.memoizedState, flags = finishedWork.memoizedState, current2 === null)
              if (flags === null)
                if (finishedWork.stateNode === null) {
                  a: {
                    flags = finishedWork.type;
                    current2 = finishedWork.memoizedProps;
                    root2 = hoistableRoot.ownerDocument || hoistableRoot;
                    b:
                      switch (flags) {
                        case "title": {
                          hoistableRoot = root2.querySelectorAll("title")[0];
                          if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop"))
                            hoistableRoot = root2.createElement(flags), root2.head.insertBefore(hoistableRoot, root2.querySelector("head > title"));
                          setInitialProperties(hoistableRoot, flags, current2);
                          hoistableRoot[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(hoistableRoot);
                          flags = hoistableRoot;
                          break a;
                        }
                        case "link": {
                          var maybeNodes = getHydratableHoistableCache("link", "href", root2).get(flags + (current2.href || ""));
                          if (maybeNodes) {
                            for (var i = 0;i < maybeNodes.length; i++)
                              if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (current2.href == undefined || current2.href === "" ? null : current2.href) && hoistableRoot.getAttribute("rel") === (current2.rel == undefined ? null : current2.rel) && hoistableRoot.getAttribute("title") === (current2.title == undefined ? null : current2.title) && hoistableRoot.getAttribute("crossorigin") === (current2.crossOrigin == undefined ? null : current2.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          hoistableRoot = root2.createElement(flags);
                          setInitialProperties(hoistableRoot, flags, current2);
                          root2.head.append(hoistableRoot);
                          break;
                        }
                        case "meta": {
                          if (maybeNodes = getHydratableHoistableCache("meta", "content", root2).get(flags + (current2.content || ""))) {
                            for (i = 0;i < maybeNodes.length; i++)
                              if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(current2.content, "content"), hoistableRoot.getAttribute("content") === (current2.content == undefined ? null : "" + current2.content) && hoistableRoot.getAttribute("name") === (current2.name == undefined ? null : current2.name) && hoistableRoot.getAttribute("property") === (current2.property == undefined ? null : current2.property) && hoistableRoot.getAttribute("http-equiv") === (current2.httpEquiv == undefined ? null : current2.httpEquiv) && hoistableRoot.getAttribute("charset") === (current2.charSet == undefined ? null : current2.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          hoistableRoot = root2.createElement(flags);
                          setInitialProperties(hoistableRoot, flags, current2);
                          root2.head.append(hoistableRoot);
                          break;
                        }
                        default: {
                          throw new Error('getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.');
                        }
                      }
                    hoistableRoot[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(hoistableRoot);
                    flags = hoistableRoot;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
              else
                finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
            else
              root2 === flags ? flags === null && finishedWork.stateNode !== null && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps) : (root2 === null ? current2.stateNode !== null && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : root2.count--, flags === null ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps));
          break;
        }
        case 27: {
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachReference(current2, current2.return));
          current2 !== null && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps);
          break;
        }
        case 5: {
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachReference(current2, current2.return));
          if (finishedWork.flags & 32) {
            root2 = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, resetTextContent, root2);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && finishedWork.stateNode != undefined && (root2 = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root2, current2 === null ? root2 : current2.memoizedProps));
          flags & 1024 && (needsFormReset = true, finishedWork.type !== "form" && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          break;
        }
        case 6: {
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (finishedWork.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            flags = finishedWork.memoizedProps;
            current2 = current2 === null ? flags : current2.memoizedProps;
            root2 = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitTextUpdate, root2, current2, flags);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        }
        case 3: {
          hoistableRoot = pushNestedEffectDurations();
          tagCaches = null;
          maybeNodes = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root2.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          currentHoistableRoot = maybeNodes;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && current2 !== null && current2.memoizedState.isDehydrated)
            try {
              runWithFiberInDEV(finishedWork, commitHydratedContainer, root2.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          root2.effectDuration += popNestedEffectDurations(hoistableRoot);
          break;
        }
        case 4: {
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        }
        case 12: {
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
          break;
        }
        case 13: {
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && finishedWork.memoizedState !== null !== (current2 !== null && current2.memoizedState !== null) && (globalMostRecentFallbackTime = now$1());
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        }
        case 22: {
          hoistableRoot = finishedWork.memoizedState !== null;
          let wasHidden = current2 !== null && current2.memoizedState !== null, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a:
              for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, hoistableRoot && (current2 === null || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current2 = null, root2 = finishedWork;; ) {
                if (root2.tag === 5 || root2.tag === 26) {
                  if (current2 === null) {
                    wasHidden = current2 = root2;
                    try {
                      maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (root2.tag === 6) {
                  if (current2 === null) {
                    wasHidden = root2;
                    try {
                      i = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i) : runWithFiberInDEV(wasHidden, unhideTextInstance, i, wasHidden.memoizedProps);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((root2.tag !== 22 && root2.tag !== 23 || root2.memoizedState === null || root2 === finishedWork) && root2.child !== null) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork)
                  break a;
                for (;root2.sibling === null; ) {
                  if (root2.return === null || root2.return === finishedWork)
                    break a;
                  current2 === root2 && (current2 = null);
                  root2 = root2.return;
                }
                current2 === root2 && (current2 = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (current2 = flags.retryQueue, current2 !== null && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
          break;
        }
        case 19: {
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        }
        case 30: {
          break;
        }
        case 21: {
          break;
        }
        default: {
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
    }
    function commitReconciliationEffects(finishedWork) {
      const flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          const fiber = parentFiber;
          recursivelyResetForms(fiber);
          fiber.tag === 5 && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root2, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function disappearLayoutEffects(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15: {
          commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        }
        case 1: {
          safelyDetachReference(finishedWork, finishedWork.return);
          const instance = finishedWork.stateNode;
          typeof instance.componentWillUnmount === "function" && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        }
        case 27: {
          runWithFiberInDEV(finishedWork, releaseSingletonInstance, finishedWork.stateNode);
        }
        case 26:
        case 5: {
          safelyDetachReference(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        }
        case 22: {
          finishedWork.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        }
        case 30: {
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        }
        default: {
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
      }
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
    }
    function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
      let flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15: {
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        }
        case 1: {
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          current2 = finishedWork.stateNode;
          typeof current2.componentDidMount === "function" && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current2);
          current2 = finishedWork.updateQueue;
          if (current2 !== null) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current2, finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        }
        case 27: {
          commitHostSingletonAcquisition(finishedWork);
        }
        case 26:
        case 5: {
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && current2 === null && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        }
        case 12: {
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, includeWorkInProgressEffects.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          break;
        }
        case 13: {
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        }
        case 22: {
          finishedWork.memoizedState === null && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        }
        case 30: {
          break;
        }
        default: {
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        }
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & 8772) !== 0;
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function commitOffscreenPassiveMountEffects(current2, finishedWork) {
      let previousCache = null;
      current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (previousCache = current2.memoizedState.cachePool.pool);
      current2 = null;
      finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null && (current2 = finishedWork.memoizedState.cachePool.pool);
      current2 !== previousCache && (current2 != undefined && retainCache(current2), previousCache != undefined && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current2, finishedWork) {
      current2 = null;
      finishedWork.alternate !== null && (current2 = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current2 && (retainCache(finishedWork), current2 != undefined && releaseCache(current2));
    }
    function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10_256)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitPassiveMountOnFiber(root2, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      let flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15: {
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        }
        case 1: {
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          break;
        }
        case 3: {
          var previousEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && (committedLanes = null, finishedWork.alternate !== null && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), committedLanes != undefined && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration += popNestedEffectDurations(previousEffectDuration);
          break;
        }
        case 12: {
          if (flags & 2048) {
            flags = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          break;
        }
        case 13: {
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          break;
        }
        case 23: {
          break;
        }
        case 22: {
          previousEffectDuration = finishedWork.stateNode;
          const _current = finishedWork.alternate;
          finishedWork.memoizedState === null ? (previousEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (previousEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, (finishedWork.subtreeFlags & 10_256) !== 0))) : (previousEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork));
          flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
          break;
        }
        case 24: {
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        }
        default: {
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        }
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & 10_256) !== 0;
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
      const flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15: {
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        }
        case 23: {
          break;
        }
        case 22: {
          const _instance2 = finishedWork.stateNode;
          finishedWork.memoizedState === null ? (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects)) : (_instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        }
        case 24: {
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        }
        default: {
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        }
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10_256)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          const finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22: {
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
              break;
            }
            case 24: {
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            }
            default: {
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
          }
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26: {
          recursivelyAccumulateSuspenseyCommit(fiber);
          fiber.flags & suspenseyCommitFlag && fiber.memoizedState !== null && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
          break;
        }
        case 5: {
          recursivelyAccumulateSuspenseyCommit(fiber);
          break;
        }
        case 3:
        case 4: {
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(fiber);
          currentHoistableRoot = previousHoistableRoot;
          break;
        }
        case 22: {
          fiber.memoizedState === null && (previousHoistableRoot = fiber.alternate, previousHoistableRoot !== null && previousHoistableRoot.memoizedState !== null ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16_777_216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
          break;
        }
        default: {
          recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
    }
    function detachAlternateSiblings(parentFiber) {
      let previousFiber = parentFiber.alternate;
      if (previousFiber !== null && (parentFiber = previousFiber.child, parentFiber !== null)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (parentFiber !== null);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      const deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (const childToDelete of deletions) {
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10_256)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15: {
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
          break;
        }
        case 3: {
          var previousEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(previousEffectDuration);
          break;
        }
        case 12: {
          previousEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(previousEffectDuration);
          break;
        }
        case 22: {
          previousEffectDuration = finishedWork.stateNode;
          finishedWork.memoizedState !== null && previousEffectDuration._visibility & OffscreenPassiveEffectsConnected && (finishedWork.return === null || finishedWork.return.tag !== 13) ? (previousEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        }
        default: {
          recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      const deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (const childToDelete of deletions) {
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
    }
    function disconnectPassiveEffect(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15: {
          commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        }
        case 22: {
          const instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        }
        default: {
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
        }
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (;nextEffect !== null; ) {
        let fiber = nextEffect, current2 = fiber;
        switch (current2.tag) {
          case 0:
          case 11:
          case 15: {
            commitHookPassiveUnmountEffects(current2, nearestMountedAncestor, Passive);
            break;
          }
          case 23:
          case 22: {
            current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (current2 = current2.memoizedState.cachePool.pool, current2 != undefined && retainCache(current2));
            break;
          }
          case 24: {
            releaseCache(current2.memoizedState.cache);
          }
        }
        current2 = fiber.child;
        if (current2 === null)
          {a:
            for (fiber = deletedSubtreeRoot;nextEffect !== null; ) {
              current2 = nextEffect;
              const { sibling, return: returnFiber } = current2;
              detachFiberAfterEffects(current2);
              if (current2 === fiber) {
                nextEffect = null;
                break a;
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }}
        else
          {current2.return = fiber, nextEffect = current2;}
      }
    }
    function onCommitRoot() {
      for (const commitHook of commitHooks) {
         commitHook(); continue;
      }
    }
    function isConcurrentActEnvironment() {
      const isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT === "undefined" ? undefined : IS_REACT_ACT_ENVIRONMENT;
      isReactActEnvironmentGlobal || ReactSharedInternals.actQueue === null || console.error("The current testing environment is not configured to support act(...)");
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== 0)
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      const transition = ReactSharedInternals.T;
      return transition === null ? resolveUpdatePriority() : (transition._updatedFibers || (transition._updatedFibers = new Set), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, fiber === 0 ? requestTransitionLane() : fiber);
    }
    function requestDeferredLane() {
      workInProgressDeferredLane === 0 && (workInProgressDeferredLane = (workInProgressRootRenderLanes & 536_870_912) === 0 || isHydrating ? claimNextTransitionLane() : 536_870_912);
      const suspenseHandler = suspenseHandlerStackCursor.current;
      suspenseHandler !== null && (suspenseHandler.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root2, fiber, lane) {
      isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
      if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root2.cancelPendingCommit !== null)
        prepareFreshStack(root2, 0), markRootSuspended(root2, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
      markRootUpdated$1(root2, lane);
      if ((executionContext & RenderContext) !== 0 && root2 === workInProgressRoot) {
        if (isRendering)
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15: {
              root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
              didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root2, root2));
              break;
            }
            case 1: {
              didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = true);
            }
          }
      } else
        isDevelopmentToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root2, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root2);
    }
    function performWorkOnRoot(root2, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw new Error("Should not already be working.");
      let shouldTimeSlice = !forceSync && (lanes & 124) === 0 && (lanes & root2.expiredLanes) === 0 || checkIfRootIsPrerendering(root2, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (exitStatus === RootInProgress) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root2, lanes, 0, false);
          break;
        } else {
          forceSync = root2.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root2, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (exitStatus === RootErrored) {
            renderWasConcurrent = lanes;
            if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
              var errorRetryLanes = 0;
            else
              errorRetryLanes = root2.pendingLanes & -536_870_913, errorRetryLanes = errorRetryLanes === 0 ? (errorRetryLanes & 536_870_912 ? 536_870_912 : 0) : errorRetryLanes;
            if (errorRetryLanes !== 0) {
              lanes = errorRetryLanes;
              a: {
                exitStatus = root2;
                let errorRetryLanes$jscomp$0 = errorRetryLanes;
                errorRetryLanes = workInProgressRootConcurrentErrors;
                const wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);
                errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, false);
                if (errorRetryLanes$jscomp$0 !== RootErrored) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = RootSuspendedWithDelay;
                    break a;
                  }
                  exitStatus = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = errorRetryLanes;
                  exitStatus !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, exitStatus));
                }
                exitStatus = errorRetryLanes$jscomp$0;
              }
              renderWasConcurrent = false;
              if (exitStatus !== RootErrored)
                continue;
            }
          }
          if (exitStatus === RootFatalErrored) {
            prepareFreshStack(root2, 0);
            markRootSuspended(root2, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root2;
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootSuspendedWithDelay: {
                if ((lanes & 4_194_048) !== lanes)
                  break;
              }
              case RootSuspendedAtTheShell: {
                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                break a;
              }
              case RootErrored: {
                workInProgressRootRecoverableErrors = null;
                break;
              }
              case RootSuspended:
              case RootCompleted: {
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
            if (ReactSharedInternals.actQueue === null)
              {
              if ((lanes & 62_914_560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                if (getNextLanes(shouldTimeSlice, 0, true) !== 0)
                  break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, exitStatus, THROTTLED_COMMIT, renderStartTime, 0), renderWasConcurrent);
                break a;
              }
              commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, exitStatus, IMMEDIATE_COMMIT, renderStartTime, 0);
            }
            else {commitRoot(shouldTimeSlice, forceSync, lanes, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes);}
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root2);
    }
    function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root2.timeoutHandle = noTimeout;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if ((suspendedCommitReason & 8192 || (suspendedCommitReason & 16_785_408) === 16_785_408) && (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), suspendedCommitReason !== null)) {
          root2.cancelPendingCommit = suspendedCommitReason(commitRoot.bind(null, root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));
          markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (let node = finishedWork;; ) {
        let tag = node.tag;
        if ((tag === 0 || tag === 11 || tag === 15) && node.flags & 16_384 && (tag = node.updateQueue, tag !== null && (tag = tag.stores, tag !== null)))
          for (let check of tag) {
            const getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check))
                return false;
            } catch {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16_384 && tag !== null)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork)
            break;
          for (;node.sibling === null; ) {
            if (node.return === null || node.return === finishedWork)
              return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root2.suspendedLanes |= suspendedLanes;
      root2.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root2.expirationTimes;
      for (let lanes = suspendedLanes;0 < lanes; ) {
        const index = 31 - clz32(lanes), lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
    }
    function resetWorkInProgressStack() {
      if (workInProgress !== null) {
        if (workInProgressSuspendedReason === NotSuspended)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
        for (;interruptedWork !== null; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root2, lanes) {
      let timeoutHandle = root2.timeoutHandle;
      timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
      timeoutHandle = root2.cancelPendingCommit;
      timeoutHandle !== null && (root2.cancelPendingCommit = null, timeoutHandle());
      resetWorkInProgressStack();
      workInProgressRoot = root2;
      workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      (lanes & 8) !== 0 && (lanes |= lanes & 32);
      let allEntangledLanes = root2.entangledLanes;
      if (allEntangledLanes !== 0)
        for (root2 = root2.entanglements, allEntangledLanes &= lanes;0 < allEntangledLanes; ) {
          const index = 31 - clz32(allEntangledLanes), lane = 1 << index;
          lanes |= root2[index];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      lanes = getCurrentTime();
      1000 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
      ReactStrictModeWarnings.discardPendingWarnings();
      return timeoutHandle;
    }
    function handleThrow(root2, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = false;
      current = null;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : (thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function" ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError));
      workInProgressThrownValue = thrownValue;
      const erroredWork = workInProgress;
      if (erroredWork === null)
        workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current));
      else
        switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
          case SuspendedOnError: {
            injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function" && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
            break;
          }
          case SuspendedOnData:
          case SuspendedOnAction:
          case SuspendedOnImmediate:
          case SuspendedOnDeprecatedThrowPromise:
          case SuspendedAndReadyToContinue: {
            injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function" && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);
          }
        }
    }
    function pushDispatcher() {
      const previousDispatcher_ = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return previousDispatcher_ === null ? ContextOnlyDispatcher : previousDispatcher_;
    }
    function pushAsyncDispatcher() {
      const previousAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return previousAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4_194_048) !== workInProgressRootRenderLanes && suspenseHandlerStackCursor.current !== null || (workInProgressRootIsPrerendering = true);
      (workInProgressRootSkippedLanes & 134_217_727) === 0 && (workInProgressRootInterleavedUpdatedLanes & 134_217_727) === 0 || workInProgressRoot === null || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
    }
    function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
      const previousExecutionContext = executionContext;
      executionContext |= RenderContext;
      const prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
        if (isDevelopmentToolsPresent) {
          var memoizedUpdaters = root2.memoizedUpdaters;
          memoizedUpdaters.size > 0 && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root2, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root2, lanes);
      }
      markRenderStarted(lanes);
      lanes = false;
      memoizedUpdaters = workInProgressRootExitStatus;
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {
              const unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case SuspendedOnHydration: {
                  resetWorkInProgressStack();
                  memoizedUpdaters = RootSuspendedAtTheShell;
                  break a;
                }
                case SuspendedOnImmediate:
                case SuspendedOnData:
                case SuspendedOnAction:
                case SuspendedOnDeprecatedThrowPromise: {
                  suspenseHandlerStackCursor.current === null && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    memoizedUpdaters = RootInProgress;
                    break a;
                  }
                  break;
                }
                default: {
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                }
              }
            }
            workLoopSync();
            memoizedUpdaters = workInProgressRootExitStatus;
            break;
          } catch (error) {
            handleThrow(root2, error);
          }
        while (1);
      lanes && root2.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = previousExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      markRenderStopped();
      workInProgress === null && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (;workInProgress !== null; )
        performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root2, lanes) {
      const previousExecutionContext = executionContext;
      executionContext |= RenderContext;
      const prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
        if (isDevelopmentToolsPresent) {
          var memoizedUpdaters = root2.memoizedUpdaters;
          memoizedUpdaters.size > 0 && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root2, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root2, lanes);
      } else
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      markRenderStarted(lanes);
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null)
              b:
                switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError: {
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedOnError);
                    break;
                  }
                  case SuspendedOnData:
                  case SuspendedOnAction: {
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  }
                  case SuspendedOnImmediate: {
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  }
                  case SuspendedOnInstance: {
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  }
                  case SuspendedAndReadyToContinue: {
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
                    break;
                  }
                  case SuspendedOnInstanceAndReadyToContinue: {
                    let resource = null;
                    switch (workInProgress.tag) {
                      case 26: {
                        resource = workInProgress.memoizedState;
                      }
                      case 5:
                      case 27: {
                        const hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : 1) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          const sibling = hostFiber.sibling;
                          if (sibling === null)
                            {
                            const returnFiber = hostFiber.return;
                            returnFiber === null ? workInProgress = null : (workInProgress = returnFiber, completeUnitOfWork(returnFiber));
                          }
                          else {workInProgress = sibling;}
                          break b;
                        }
                        break;
                      }
                      default: {
                        console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
                      }
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
                    break;
                  }
                  case SuspendedOnDeprecatedThrowPromise: {
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
                    break;
                  }
                  case SuspendedOnHydration: {
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  }
                  default: {
                    throw new Error("Unexpected SuspendedReason. This is a bug in React.");
                  }
                }
            ReactSharedInternals.actQueue === null ? workLoopConcurrentByScheduler() : workLoopSync();
            break;
          } catch (error) {
            handleThrow(root2, error);
          }
        while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = previousExecutionContext;
      if (workInProgress !== null)
        return injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function" && injectedProfilingHooks.markRenderYielded(), RootInProgress;
      markRenderStopped();
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (;workInProgress !== null && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      let current2 = unitOfWork.alternate;
      (unitOfWork.mode & ProfileMode) === NoMode ? current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes) : (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork));
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      current2 === null ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      const next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replayBeginWork(unitOfWork) {
      let current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0: {
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, undefined, workInProgressRootRenderLanes);
          break;
        }
        case 11: {
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
          break;
        }
        case 5: {
          resetHooksOnUnwind(unitOfWork);
        }
        default: {
          unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
        }
      }
      isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current2;
    }
    function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState = null;
      thenableIndexCounter = 0;
      const returnFiber = unitOfWork.return;
      try {
        if (throwException(root2, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current));
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (returnFiber !== null)
          throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current));
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32_768) {
        if (isHydrating || suspendedReason === SuspendedOnError)
          root2 = true;
        else if (workInProgressRootIsPrerendering || (workInProgressRootRenderLanes & 536_870_912) !== 0)
          root2 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
          suspendedReason = suspenseHandlerStackCursor.current, suspendedReason !== null && suspendedReason.tag === 13 && (suspendedReason.flags |= 16_384);
        unwindUnitOfWork(unitOfWork, root2);
      } else
        completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      let completedWork = unitOfWork;
      do {
        if ((completedWork.flags & 32_768) !== 0) {
          unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
          return;
        }
        let current2 = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current2 = runWithFiberInDEV(completedWork, completeWork, current2, completedWork, entangledRenderLanes);
        (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (current2 !== null) {
          workInProgress = current2;
          return;
        }
        completedWork = completedWork.sibling;
        if (completedWork !== null) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (completedWork !== null);
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        let next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (next !== null) {
          next.flags &= 32_767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (let child = unitOfWork.child;child !== null; )
            next += child.actualDuration, child = child.sibling;
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        next !== null && (next.flags |= 32_768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, unitOfWork !== null)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (unitOfWork !== null);
      workInProgressRootExitStatus = RootSuspendedAtTheShell;
      workInProgress = null;
    }
    function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root2.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw new Error("Should not already be working.");
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function" && injectedProfilingHooks.markCommitStarted(lanes);
      if (finishedWork === null)
        markCommitStopped();
      else {
        lanes === 0 && console.error("finishedLanes should not be empty during a commit. This is a bug in React.");
        if (finishedWork === root2.current)
          throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(root2, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
        root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root2;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        (finishedWork.subtreeFlags & 10_256) !== 0 || (finishedWork.flags & 10_256) !== 0 ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          flushPassiveEffects(true);
          return null;
        })) : (root2.callbackNode = null, root2.callbackPriority = 0);
        commitStartTime = now();
        recoverableErrors = (finishedWork.flags & 13_878) !== 0;
        if ((finishedWork.subtreeFlags & 13_878) !== 0 || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          spawnedLane = executionContext;
          executionContext |= CommitContext;
          try {
            commitBeforeMutationEffects(root2, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = PENDING_MUTATION_PHASE;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        let root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = (finishedWork.flags & 13_878) !== 0;
        if ((finishedWork.subtreeFlags & 13_878) !== 0 || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          const previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          const previousExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = lanes;
            inProgressRoot = root2;
            commitMutationEffectsOnFiber(finishedWork, root2);
            inProgressRoot = inProgressLanes = null;
            lanes = selectionInformation;
            let curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                let { start, end } = priorSelectionRange;
                end === undefined && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);
                else {
                  var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = priorSelectionRange.end === undefined ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    const startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0), endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
                    if (startMarker && endMarker && (selection.rangeCount !== 1 || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      const range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem;selection = selection.parentNode; )
                selection.nodeType === 1 && doc.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              typeof priorFocusedElem.focus === "function" && priorFocusedElem.focus();
              for (priorFocusedElem = 0;priorFocusedElem < doc.length; priorFocusedElem++) {
                const info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = Boolean(eventsEnabled);
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = previousExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root2.current = finishedWork;
        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        let root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = (finishedWork.flags & 8772) !== 0;
        if ((finishedWork.subtreeFlags & 8772) !== 0 || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          const previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          const previousExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function" && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root2, commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork), inProgressRoot = inProgressLanes = null, injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function" && injectedProfilingHooks.markLayoutEffectsStopped();
          } finally {
            executionContext = previousExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
      }
    }
    function flushSpawnedWork() {
      if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        requestPaint();
        let root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = (finishedWork.subtreeFlags & 10_256) !== 0 || (finishedWork.flags & 10_256) !== 0;
        rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
        let remainingLanes = root2.pendingLanes;
        remainingLanes === 0 && (legacyErrorBoundariesThatAlreadyFailed = null);
        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root2);
        rootDidHavePassiveEffects = lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function")
          try {
            var didError = (finishedWork.current.flags & 128) === 128;
            switch (rootDidHavePassiveEffects) {
              case DiscreteEventPriority: {
                var schedulerPriority = ImmediatePriority;
                break;
              }
              case ContinuousEventPriority: {
                schedulerPriority = UserBlockingPriority;
                break;
              }
              case DefaultEventPriority: {
                schedulerPriority = NormalPriority$1;
                break;
              }
              case IdleEventPriority: {
                schedulerPriority = IdlePriority;
                break;
              }
              default: {
                schedulerPriority = NormalPriority$1;
              }
            }
            injectedHook.onCommitFiberRoot(rendererID, finishedWork, schedulerPriority, didError);
          } catch (error) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %s", error));
          }
        isDevelopmentToolsPresent && root2.memoizedUpdaters.clear();
        onCommitRoot();
        if (recoverableErrors !== null) {
          didError = ReactSharedInternals.T;
          schedulerPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          ReactSharedInternals.T = null;
          try {
            const onRecoverableError = root2.onRecoverableError;
            for (finishedWork = 0;finishedWork < recoverableErrors.length; finishedWork++) {
              const recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
              runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);
            }
          } finally {
            ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
          }
        }
        (pendingEffectsLanes & 3) !== 0 && flushPendingEffects();
        ensureRootIsScheduled(root2);
        remainingLanes = root2.pendingLanes;
        (lanes & 4_194_090) !== 0 && (remainingLanes & 42) !== 0 ? (nestedUpdateScheduled = true, root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2)) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0, false);
        markCommitStopped();
      }
    }
    function makeErrorInfo(componentStack) {
      componentStack = { componentStack };
      Object.defineProperty(componentStack, "digest", {
        get: function() {
          console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root2, remainingLanes) {
      (root2.pooledCacheLanes &= remainingLanes) === 0 && (remainingLanes = root2.pooledCache, remainingLanes != undefined && (root2.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects(wasDelayedCommit) {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects(wasDelayedCommit);
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return false;
      const root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      let renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = DefaultEventPriority === 0 || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
      renderPriority = ReactSharedInternals.T;
      const previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = priority;
        ReactSharedInternals.T = null;
        priority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        const root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw new Error("Cannot flush passive effects while already rendering.");
        isFlushingPassiveEffects = true;
        didScheduleUpdateDuringPassiveEffects = false;
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function" && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
        const previousExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function" && injectedProfilingHooks.markPassiveEffectsStopped();
        commitDoubleInvokeEffectsInDEV(root$jscomp$0);
        executionContext = previousExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, false);
        didScheduleUpdateDuringPassiveEffects ? (root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0)) : nestedPassiveUpdateCount = 0;
        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function")
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (error) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %s", error));
          }
        const stateNode = root$jscomp$0.current.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      rootFiber !== null && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      isRunningInsertionEffect = false;
      if (sourceFiber.tag === 3)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else {
        for (;nearestMountedAncestor !== null; ) {
          if (nearestMountedAncestor.tag === 3) {
            captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
            return;
          }
          if (nearestMountedAncestor.tag === 1) {
            let instance = nearestMountedAncestor.stateNode;
            if (typeof nearestMountedAncestor.type.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              instance !== null && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, error);
      }
    }
    function attachPingListener(root2, wakeable, lanes) {
      let pingCache = root2.pingCache;
      if (pingCache === null) {
        pingCache = root2.pingCache = new PossiblyWeakMap;
        var threadIDs = new Set;
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), threadIDs === undefined && (threadIDs = new Set, pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevelopmentToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root2, wakeable, pingedLanes) {
      const pingCache = root2.pingCache;
      pingCache !== null && pingCache.delete(wakeable);
      root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      root2.warmLanes &= ~pingedLanes;
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && console.error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`);
      workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62_914_560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root2);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      retryLane === 0 && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      boundaryFiber !== null && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      let suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      suspenseState !== null && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      let retryLane = 0;
      switch (boundaryFiber.tag) {
        case 13: {
          var retryCache = boundaryFiber.stateNode;
          const suspenseState = boundaryFiber.memoizedState;
          suspenseState !== null && (retryLane = suspenseState.retryLane);
          break;
        }
        case 19: {
          retryCache = boundaryFiber.stateNode;
          break;
        }
        case 22: {
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        }
        default: {
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
        }
      }
      retryCache !== null && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
      if ((parentFiber.subtreeFlags & 67_117_056) !== 0)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          let root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
          fiber.tag === 22 ? fiber.memoizedState === null && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root2, fiber) : fiber.subtreeFlags & 67_108_864 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root2, fiber, isStrictModeFiber)) : (fiber.flags & 67_108_864 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root2, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root2, fiber, isStrictModeFiber));
          parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root2, fiber) {
      const shouldDoubleInvokePassiveEffects = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : true;
      setIsStrictModeForDevtools(true);
      try {
        disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root2) {
      let doubleInvokeEffects = true;
      root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root2, root2.current, doubleInvokeEffects);
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        let tag = fiber.tag;
        if (tag === 3 || tag === 1 || tag === 0 || tag === 11 || tag === 14 || tag === 15) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent === null) {didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);} else
            {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag))
              return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          }
          runWithFiberInDEV(fiber, function() {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function restorePendingUpdaters(root2, lanes) {
      isDevelopmentToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
        addFiberToLanesMap(root2, schedulingFiber, lanes);
      });
    }
    function scheduleCallback$1(priorityLevel, callback) {
      const actQueue = ReactSharedInternals.actQueue;
      return actQueue === null ? scheduleCallback$3(priorityLevel, callback) : (actQueue.push(callback), fakeActCallbackNode$1);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && runWithFiberInDEV(fiber, function() {
        console.error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`, getComponentNameFromFiber(fiber));
      });
    }
    function ensureRootIsScheduled(root2) {
      root2 !== lastScheduledRoot && root2.next === null && (lastScheduledRoot === null ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
      mightHavePendingSyncWork = true;
      ReactSharedInternals.actQueue === null ? didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (let root2 = firstScheduledRoot;root2 !== null; ) {
            if (!onlyLegacy)
              if (syncTransitionLanes === 0) {nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? nextLanes : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== noTimeout), (nextLanes & 3) === 0 || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));} else
                {
                const pendingLanes = root2.pendingLanes;
                if (pendingLanes === 0)
                  var nextLanes = 0;
                else {
                  const { suspendedLanes, pingedLanes } = root2;
                  nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  nextLanes = nextLanes & 201_326_741 ? nextLanes & 201_326_741 | 1 : (nextLanes ? nextLanes | 2 : 0);
                }
                nextLanes !== 0 && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
              }
            root2 = root2.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
      let syncTransitionLanes = 0;
      currentEventTransitionLane !== 0 && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
      for (let currentTime = now$1(), previous = null, root2 = firstScheduledRoot;root2 !== null; ) {
        const next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
        if (nextLanes === 0)
          root2.next = null, previous === null ? firstScheduledRoot = next : previous.next = next, next === null && (lastScheduledRoot = previous);
        else if (previous = root2, syncTransitionLanes !== 0 || (nextLanes & 3) !== 0)
          mightHavePendingSyncWork = true;
        root2 = next;
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
    }
    function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
      for (var { suspendedLanes, pingedLanes, expirationTimes } = root2, lanes = root2.pendingLanes & -62_914_561;0 < lanes; ) {
        const index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
        if (expirationTime === -1) {
          if ((lane & suspendedLanes) === 0 || (lane & pingedLanes) !== 0)
            expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else
          expirationTime <= currentTime && (root2.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(root2, root2 === currentTime ? suspendedLanes : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== noTimeout);
      pingedLanes = root2.callbackNode;
      if (suspendedLanes === 0 || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root2.cancelPendingCommit !== null)
        return pingedLanes !== null && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
      if ((suspendedLanes & 3) === 0 || checkIfRootIsPrerendering(root2, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime !== root2.callbackPriority || ReactSharedInternals.actQueue !== null && pingedLanes !== fakeActCallbackNode)
          cancelCallback(pingedLanes);
        else
          return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case DiscreteEventPriority:
          case ContinuousEventPriority: {
            suspendedLanes = UserBlockingPriority;
            break;
          }
          case DefaultEventPriority: {
            suspendedLanes = NormalPriority$1;
            break;
          }
          case IdleEventPriority: {
            suspendedLanes = IdlePriority;
            break;
          }
          default: {
            suspendedLanes = NormalPriority$1;
          }
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
        ReactSharedInternals.actQueue === null ? suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes) : (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode);
        root2.callbackPriority = currentTime;
        root2.callbackNode = suspendedLanes;
        return currentTime;
      }
      pingedLanes !== null && cancelCallback(pingedLanes);
      root2.callbackPriority = 2;
      root2.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = false;
      if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return root2.callbackNode = null, root2.callbackPriority = 0, null;
      const originalCallbackNode = root2.callbackNode;
      if (flushPendingEffects(true) && root2.callbackNode !== originalCallbackNode)
        return null;
      let workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== noTimeout);
      if (workInProgressRootRenderLanes$jscomp$0 === 0)
        return null;
      performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root2, now$1());
      return root2.callbackNode != undefined && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
    }
    function performSyncWorkOnRoot(root2, lanes) {
      if (flushPendingEffects())
        return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = false;
      performWorkOnRoot(root2, lanes, true);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode && callbackNode !== null && cancelCallback$1(callbackNode);
    }
    function scheduleImmediateRootScheduleTask() {
      ReactSharedInternals.actQueue !== null && ReactSharedInternals.actQueue.push(function() {
        processRootScheduleInMicrotask();
        return null;
      });
      scheduleMicrotask(function() {
        (executionContext & (RenderContext | CommitContext)) === NoContext ? processRootScheduleInMicrotask() : scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask);
      });
    }
    function requestTransitionLane() {
      currentEventTransitionLane === 0 && (currentEventTransitionLane = claimNextTransitionLane());
      return currentEventTransitionLane;
    }
    function coerceFormActionProperty(actionProp) {
      if (actionProp == undefined || typeof actionProp === "symbol" || typeof actionProp === "boolean")
        return null;
      if (typeof actionProp === "function")
        return actionProp;
      checkAttributeStringCoercion(actionProp, "action");
      return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      const temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.remove();
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if (domEventName === "submit" && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        let action = coerceFormActionProperty((nativeEventTarget[internalPropertiesKey] || null).action), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropertiesKey] || null) ? coerceFormActionProperty(domEventName.formAction) : submitter.getAttribute("formAction"), domEventName !== null && (action = domEventName, submitter = null));
        const event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (currentEventTransitionLane !== 0) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    };
                    Object.freeze(pendingState);
                    startHostTransition(maybeTargetInst, pendingState, null, formData);
                  }
                } else
                  typeof action === "function" && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                    pending: true,
                    data: formData,
                    method: nativeEventTarget.method,
                    action
                  }, Object.freeze(pendingState), startHostTransition(maybeTargetInst, pendingState, action, formData));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    function executeDispatch(event, listener, currentTarget) {
      event.currentTarget = currentTarget;
      try {
        listener(event);
      } catch (error) {
        reportGlobalError(error);
      }
      event.currentTarget = null;
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = (eventSystemFlags & 4) !== 0;
      for (let _dispatchQueue$index of dispatchQueue) {
        a: {
          let previousInstance, event = _dispatchQueue$index.event;
          _dispatchQueue$index = _dispatchQueue$index.listeners;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$index.length - 1;0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$index[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              instance === null ? executeDispatch(event, _dispatchListeners$i, currentTarget) : runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0;i$jscomp$0 < _dispatchQueue$index.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$index[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              instance === null ? executeDispatch(event, _dispatchListeners$i, currentTarget) : runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) || console.error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
      let listenerSet = targetElement[internalEventHandlersKey];
      listenerSet === undefined && (listenerSet = targetElement[internalEventHandlersKey] = new Set);
      const listenerSetKey = domEventName + "__bubble";
      listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
      let eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    }
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        for (const domEventName of allNativeEvents) {
          domEventName !== "selectionchange" && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        }
        const ownerDocument = rootContainerElement.nodeType === 9 ? rootContainerElement : rootContainerElement.ownerDocument;
        ownerDocument === null || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case DiscreteEventPriority: {
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        }
        case ContinuousEventPriority: {
          listenerWrapper = dispatchContinuousEvent;
          break;
        }
        default: {
          listenerWrapper = dispatchEvent;
        }
      }
      eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      listenerWrapper = undefined;
      !passiveBrowserEventsSupported || domEventName !== "touchstart" && domEventName !== "touchmove" && domEventName !== "wheel" || (listenerWrapper = true);
      isCapturePhaseListener ? (listenerWrapper === undefined ? targetContainer.addEventListener(domEventName, eventSystemFlags, true) : targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      })) : (listenerWrapper === undefined ? targetContainer.addEventListener(domEventName, eventSystemFlags, false) : targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }));
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      let ancestorInst = targetInst$jscomp$0;
      if ((eventSystemFlags & 1) === 0 && (eventSystemFlags & 2) === 0 && targetInst$jscomp$0 !== null)
        a:
          for (;; ) {
            if (targetInst$jscomp$0 === null)
              return;
            let nodeTag = targetInst$jscomp$0.tag;
            if (nodeTag === 3 || nodeTag === 4) {
              let container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer)
                break;
              if (nodeTag === 4)
                for (nodeTag = targetInst$jscomp$0.return;nodeTag !== null; ) {
                  var grandTag = nodeTag.tag;
                  if ((grandTag === 3 || grandTag === 4) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (;container !== null; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (nodeTag === null)
                  return;
                grandTag = nodeTag.tag;
                if (grandTag === 5 || grandTag === 6 || grandTag === 26 || grandTag === 27) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
      batchedUpdates$1(function() {
        const targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName !== undefined) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress": {
                if (getEventCharCode(nativeEvent) === 0)
                  break a;
              }
              case "keydown":
              case "keyup": {
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              }
              case "focusin": {
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              }
              case "focusout": {
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              }
              case "beforeblur":
              case "afterblur": {
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              }
              case "click": {
                if (nativeEvent.button === 2)
                  break a;
              }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu": {
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              }
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop": {
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              }
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart": {
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              }
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START: {
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              }
              case TRANSITION_END: {
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              }
              case "scroll":
              case "scrollend": {
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              }
              case "wheel": {
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              }
              case "copy":
              case "cut":
              case "paste": {
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup": {
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              }
              case "toggle":
              case "beforetoggle": {
                SyntheticEventCtor = SyntheticToggleEvent;
              }
            }
            var inCapturePhase = (eventSystemFlags & 4) !== 0, accumulateTargetOnly = !inCapturePhase && (domEventName === "scroll" || domEventName === "scrollend"), reactEventName = inCapturePhase ? (reactName === null ? null : reactName + "Capture") : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent;instance !== null; ) {
              var _instance2 = instance;
              lastHostComponent = _instance2.stateNode;
              _instance2 = _instance2.tag;
              _instance2 !== 5 && _instance2 !== 26 && _instance2 !== 27 || lastHostComponent === null || reactEventName === null || (_instance2 = getListener(instance, reactEventName), _instance2 != undefined && inCapturePhase.push(createDispatchListener(instance, _instance2, lastHostComponent)));
              if (accumulateTargetOnly)
                break;
              instance = instance.return;
            }
            inCapturePhase.length > 0 && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
              event: reactName,
              listeners: inCapturePhase
            }));
          }
        }
        if ((eventSystemFlags & 7) === 0) {
          a: {
            reactName = domEventName === "mouseover" || domEventName === "pointerover";
            SyntheticEventCtor = domEventName === "mouseout" || domEventName === "pointerout";
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : ((reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : globalThis);
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, reactEventType !== null && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || inCapturePhase !== 5 && inCapturePhase !== 27 && inCapturePhase !== 6))
                  reactEventType = null;
              } else
                SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance2 = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if (domEventName === "pointerout" || domEventName === "pointerover")
                  inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = SyntheticEventCtor == undefined ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = reactEventType == undefined ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(_instance2, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance2 = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                accumulateTargetOnly = _instance2;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = SyntheticEventCtor;
                    reactEventName = reactEventType;
                    instance = 0;
                    for (lastHostComponent = inCapturePhase;lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                      instance++;
                    lastHostComponent = 0;
                    for (_instance2 = reactEventName;_instance2; _instance2 = getParent(_instance2))
                      lastHostComponent++;
                    for (;0 < instance - lastHostComponent; )
                      inCapturePhase = getParent(inCapturePhase), instance--;
                    for (;0 < lastHostComponent - instance; )
                      reactEventName = getParent(reactEventName), lastHostComponent--;
                    for (;instance--; ) {
                      if (inCapturePhase === reactEventName || reactEventName !== null && inCapturePhase === reactEventName.alternate)
                        break b;
                      inCapturePhase = getParent(inCapturePhase);
                      reactEventName = getParent(reactEventName);
                    }
                    inCapturePhase = null;
                  }
                else
                  inCapturePhase = null;
                SyntheticEventCtor !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, false);
                reactEventType !== null && accumulateTargetOnly !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, true);
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : globalThis;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if (SyntheticEventCtor === "select" || SyntheticEventCtor === "input" && reactName.type === "file")
              var getTargetInstFunction = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunction = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunction = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || SyntheticEventCtor.toLowerCase() !== "input" || reactName.type !== "checkbox" && reactName.type !== "radio" ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunction = getTargetInstForChangeEvent) : getTargetInstFunction = getTargetInstForClickEvent;
            if (getTargetInstFunction && (getTargetInstFunction = getTargetInstFunction(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunction, nativeEvent, nativeEventTarget);
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            domEventName === "focusout" && targetInst && reactName.type === "number" && targetInst.memoizedProps.value != undefined && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : globalThis;
          switch (domEventName) {
            case "focusin": {
              if (isTextInputElement(handleEventFunc) || handleEventFunc.contentEditable === "true")
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            }
            case "focusout": {
              lastSelection = activeElementInst = activeElement = null;
              break;
            }
            case "mousedown": {
              mouseDown = true;
              break;
            }
            case "contextmenu":
            case "mouseup":
            case "dragend": {
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            }
            case "selectionchange": {
              if (skipSelectionChangeEvent)
                break;
            }
            case "keydown":
            case "keyup": {
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          let fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart": {
                  var eventType = "onCompositionStart";
                  break b;
                }
                case "compositionend": {
                  eventType = "onCompositionEnd";
                  break b;
                }
                case "compositionupdate": {
                  eventType = "onCompositionUpdate";
                  break b;
                }
              }
              eventType = undefined;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && nativeEvent.locale !== "ko" && (isComposing || eventType !== "onCompositionStart" ? eventType === "onCompositionEnd" && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = ("value" in root) ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), handleEventFunc.length > 0 && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: eventType,
            listeners: handleEventFunc
          }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), fallbackData !== null && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), eventType.length > 0 && (handleEventFunc = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (let captureName = reactName + "Capture", listeners = [];targetFiber !== null; ) {
        let _instance3 = targetFiber, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        _instance3 !== 5 && _instance3 !== 26 && _instance3 !== 27 || stateNode === null || (_instance3 = getListener(targetFiber, captureName), _instance3 != undefined && listeners.unshift(createDispatchListener(targetFiber, _instance3, stateNode)), _instance3 = getListener(targetFiber, reactName), _instance3 != undefined && listeners.push(createDispatchListener(targetFiber, _instance3, stateNode)));
        if (targetFiber.tag === 3)
          return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (inst === null)
        return null;
      do
        inst = inst.return;
      while (inst && inst.tag !== 5 && inst.tag !== 27);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = [];target !== null && target !== common; ) {
        let _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
        _instance4 = _instance4.tag;
        if (alternate !== null && alternate === common)
          break;
        _instance4 !== 5 && _instance4 !== 26 && _instance4 !== 27 || stateNode === null || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), stateNode != undefined && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), stateNode != undefined && listeners.push(createDispatchListener(target, stateNode, alternate))));
        target = target.return;
      }
      listeners.length > 0 && dispatchQueue.push({ event, listeners });
    }
    function validatePropertiesInDevelopment(type, properties) {
      validateProperties$2(type, properties);
      type !== "input" && type !== "textarea" && type !== "select" || properties == undefined || properties.value !== null || didWarnValueNull || (didWarnValueNull = true, type === "select" && properties.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
      const eventRegistry = {
        registrationNameDependencies,
        possibleRegistrationNames
      };
      isCustomElement(type) || typeof properties.is === "string" || warnUnknownProperties(type, properties, eventRegistry);
      properties.contentEditable && !properties.suppressContentEditableWarning && properties.children != undefined && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
    }
    function warnForPropertyDifference(propName, serverValue, clientValue, serverDifferences) {
      serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
      for (const attributeName of attributeNames) {
        serverDifferences[getPropNameFromAttributeName(attributeName)] = attributeName === "style" ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
      }
    }
    function warnForInvalidEventListener(registrationName, listener) {
      listener === false ? console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    }
    function normalizeHTML(parent, html) {
      parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName) : parent.ownerDocument.createElement(parent.tagName);
      parent.innerHTML = html;
      return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
      willCoercionThrow(markup) && (console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(markup)), testStringCoercion(markup));
      return (typeof markup === "string" ? markup : "" + markup).replaceAll(NORMALIZE_NEWLINES_REGEX, `
`).replaceAll(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function noop$1() {}
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children": {
          if (typeof value === "string")
            validateTextNesting(value, tag, false), tag === "body" || tag === "textarea" && value === "" || setTextContent(domElement, value);
          else if (typeof value === "number" || typeof value === "bigint")
            validateTextNesting("" + value, tag, false), tag !== "body" && setTextContent(domElement, "" + value);
          break;
        }
        case "className": {
          setValueForKnownAttribute(domElement, "class", value);
          break;
        }
        case "tabIndex": {
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        }
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height": {
          setValueForKnownAttribute(domElement, key, value);
          break;
        }
        case "style": {
          setValueForStyles(domElement, value, prevValue);
          break;
        }
        case "data": {
          if (tag !== "object") {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        }
        case "src":
        case "href": {
          if (value === "" && (tag !== "a" || key !== "href")) {
            key === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key);
            domElement.removeAttribute(key);
            break;
          }
          if (value == undefined || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean") {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        }
        case "action":
        case "formAction": {
          value != undefined && (tag === "form" ? (key === "formAction" ? console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.") : typeof value === "function" && (props.encType == undefined && props.method == undefined || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")), props.target == undefined || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.")))) : tag === "input" || tag === "button" ? key === "action" ? console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.") : tag !== "input" || props.type === "submit" || props.type === "image" || didWarnFormActionType ? tag !== "button" || props.type == undefined || props.type === "submit" || didWarnFormActionType ? typeof value === "function" && (props.name == undefined || didWarnFormActionName || (didWarnFormActionName = true, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')), props.formEncType == undefined && props.formMethod == undefined || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")), props.formTarget == undefined || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))) : (didWarnFormActionType = true, console.error('A button can only specify a formAction along with type="submit" or no type.')) : (didWarnFormActionType = true, console.error('An input can only specify a formAction along with type="submit" or type="image".')) : key === "action" ? console.error("You can only pass the action prop to <form>.") : console.error("You can only pass the formAction prop to <input> or <button>."));
          if (typeof value === "function") {
            domElement.setAttribute(key, String.raw`javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')`);
            break;
          } else
            typeof prevValue === "function" && (key === "formAction" ? (tag !== "input" && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (value == undefined || typeof value === "symbol" || typeof value === "boolean") {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        }
        case "onClick": {
          value != undefined && (typeof value !== "function" && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        }
        case "onScroll": {
          value != undefined && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        }
        case "onScrollEnd": {
          value != undefined && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        }
        case "dangerouslySetInnerHTML": {
          if (value != undefined) {
            if (typeof value !== "object" || !("__html" in value))
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (key != undefined) {
              if (props.children != undefined)
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        }
        case "multiple": {
          domElement.multiple = value && typeof value !== "function" && typeof value !== "symbol";
          break;
        }
        case "muted": {
          domElement.muted = value && typeof value !== "function" && typeof value !== "symbol";
          break;
        }
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref": {
          break;
        }
        case "autoFocus": {
          break;
        }
        case "xlinkHref": {
          if (value == undefined || typeof value === "function" || typeof value === "boolean" || typeof value === "symbol") {
            domElement.removeAttribute("xlink:href");
            break;
          }
          checkAttributeStringCoercion(value, key);
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
          break;
        }
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha": {
          value != undefined && typeof value !== "function" && typeof value !== "symbol" ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
          break;
        }
        case "inert": {
          value !== "" || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", key));
        }
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope": {
          value && typeof value !== "function" && typeof value !== "symbol" ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        }
        case "capture":
        case "download": {
          value === true ? domElement.setAttribute(key, "") : (value !== false && value != undefined && typeof value !== "function" && typeof value !== "symbol" ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key));
          break;
        }
        case "cols":
        case "rows":
        case "size":
        case "span": {
          value != undefined && typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
          break;
        }
        case "rowSpan":
        case "start": {
          value == undefined || typeof value === "function" || typeof value === "symbol" || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
          break;
        }
        case "popover": {
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        }
        case "xlinkActuate": {
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:actuate", value);
          break;
        }
        case "xlinkArcrole": {
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:arcrole", value);
          break;
        }
        case "xlinkRole": {
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:role", value);
          break;
        }
        case "xlinkShow": {
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:show", value);
          break;
        }
        case "xlinkTitle": {
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:title", value);
          break;
        }
        case "xlinkType": {
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:type", value);
          break;
        }
        case "xmlBase": {
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:base", value);
          break;
        }
        case "xmlLang": {
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:lang", value);
          break;
        }
        case "xmlSpace": {
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:space", value);
          break;
        }
        case "is": {
          prevValue != undefined && console.error('Cannot update the "is" prop after it has been initialized.');
          setValueForAttribute(domElement, "is", value);
          break;
        }
        case "innerText":
        case "textContent": {
          break;
        }
        case "popoverTarget": {
          didWarnPopoverTargetObject || value == undefined || typeof value !== "object" || (didWarnPopoverTargetObject = true, console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.", value));
        }
        default: {
          !(2 < key.length) || key[0] !== "o" && key[0] !== "O" || key[1] !== "n" && key[1] !== "N" ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && value != undefined && typeof value !== "function" && warnForInvalidEventListener(key, value);
        }
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style": {
          setValueForStyles(domElement, value, prevValue);
          break;
        }
        case "dangerouslySetInnerHTML": {
          if (value != undefined) {
            if (typeof value !== "object" || !("__html" in value))
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (key != undefined) {
              if (props.children != undefined)
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        }
        case "children": {
          typeof value === "string" ? setTextContent(domElement, value) : (typeof value === "number" || typeof value === "bigint") && setTextContent(domElement, "" + value);
          break;
        }
        case "onScroll": {
          value != undefined && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        }
        case "onScrollEnd": {
          value != undefined && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        }
        case "onClick": {
          value != undefined && (typeof value !== "function" && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        }
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref": {
          break;
        }
        case "innerText":
        case "textContent": {
          break;
        }
        default: {
          if (registrationNameDependencies.hasOwnProperty(key))
            value != undefined && typeof value !== "function" && warnForInvalidEventListener(key, value);
          else
            a: {
              if (key[0] === "o" && key[1] === "n" && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : undefined), prevValue = domElement[internalPropertiesKey] || null, prevValue = prevValue == undefined ? null : prevValue[key], typeof prevValue === "function" && domElement.removeEventListener(tag, prevValue, props), typeof value === "function")) {
                typeof prevValue !== "function" && prevValue !== null && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : (value === true ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value));
            }
        }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      validatePropertiesInDevelopment(tag, props);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li": {
          break;
        }
        case "img": {
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (propValue != undefined)
                switch (propKey) {
                  case "src": {
                    hasSrc = true;
                    break;
                  }
                  case "srcSet": {
                    hasSrcSet = true;
                    break;
                  }
                  case "children":
                  case "dangerouslySetInnerHTML": {
                    throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  }
                  default: {
                    setProp(domElement, tag, propKey, propValue, props, null);
                  }
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        }
        case "input": {
          checkControlledValueProperties("input", props);
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var _propValue = props[hasSrc];
              if (_propValue != undefined)
                switch (hasSrc) {
                  case "name": {
                    hasSrcSet = _propValue;
                    break;
                  }
                  case "type": {
                    propValue = _propValue;
                    break;
                  }
                  case "checked": {
                    checked = _propValue;
                    break;
                  }
                  case "defaultChecked": {
                    defaultChecked = _propValue;
                    break;
                  }
                  case "value": {
                    propKey = _propValue;
                    break;
                  }
                  case "defaultValue": {
                    defaultValue = _propValue;
                    break;
                  }
                  case "children":
                  case "dangerouslySetInnerHTML": {
                    if (_propValue != undefined)
                      throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                    break;
                  }
                  default: {
                    setProp(domElement, tag, hasSrc, _propValue, props, null);
                  }
                }
            }
          validateInputProperties(domElement, props);
          initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, false);
          track(domElement);
          return;
        }
        case "select": {
          checkControlledValueProperties("select", props);
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], defaultValue != undefined))
              switch (hasSrcSet) {
                case "value": {
                  propKey = defaultValue;
                  break;
                }
                case "defaultValue": {
                  propValue = defaultValue;
                  break;
                }
                case "multiple": {
                  hasSrc = defaultValue;
                }
                default: {
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
              }
          validateSelectProperties(domElement, props);
          tag = propKey;
          props = propValue;
          domElement.multiple = Boolean(hasSrc);
          tag == undefined ? props != undefined && updateOptions(domElement, Boolean(hasSrc), props, true) : updateOptions(domElement, Boolean(hasSrc), tag, false);
          return;
        }
        case "textarea": {
          checkControlledValueProperties("textarea", props);
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], defaultValue != undefined))
              switch (propValue) {
                case "value": {
                  hasSrc = defaultValue;
                  break;
                }
                case "defaultValue": {
                  hasSrcSet = defaultValue;
                  break;
                }
                case "children": {
                  propKey = defaultValue;
                  break;
                }
                case "dangerouslySetInnerHTML": {
                  if (defaultValue != undefined)
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  break;
                }
                default: {
                  setProp(domElement, tag, propValue, defaultValue, props, null);
                }
              }
          validateTextareaProperties(domElement, props);
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          track(domElement);
          return;
        }
        case "option": {
          validateOptionProperties(domElement, props);
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], hasSrc != undefined))
              switch (checked) {
                case "selected": {
                  domElement.selected = hasSrc && typeof hasSrc !== "function" && typeof hasSrc !== "symbol";
                  break;
                }
                default: {
                  setProp(domElement, tag, checked, hasSrc, props, null);
                }
              }
          return;
        }
        case "dialog": {
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        }
        case "iframe":
        case "object": {
          listenToNonDelegatedEvent("load", domElement);
          break;
        }
        case "video":
        case "audio": {
          for (hasSrc = 0;hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        }
        case "image": {
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        }
        case "details": {
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        }
        case "embed":
        case "source":
        case "link": {
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        }
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem": {
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], hasSrc != undefined))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML": {
                  throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                }
                default: {
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
              }
          return;
        }
        default: {
          if (isCustomElement(tag)) {
            for (_propValue in props)
              props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], hasSrc !== undefined && setPropOnCustomElement(domElement, tag, _propValue, hasSrc, props, undefined));
            return;
          }
        }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], hasSrc != undefined && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProperties, nextProperties) {
      validatePropertiesInDevelopment(tag, nextProperties);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li": {
          break;
        }
        case "input": {
          var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propertyKey in lastProperties) {
            var lastProperty = lastProperties[propertyKey];
            if (lastProperties.hasOwnProperty(propertyKey) && lastProperty != undefined)
              switch (propertyKey) {
                case "checked": {
                  break;
                }
                case "value": {
                  break;
                }
                case "defaultValue": {
                  lastDefaultValue = lastProperty;
                }
                default: {
                  nextProperties.hasOwnProperty(propertyKey) || setProp(domElement, tag, propertyKey, null, nextProperties, lastProperty);
                }
              }
          }
          for (var _propertyKey8 in nextProperties) {
            var propertyKey = nextProperties[_propertyKey8];
            lastProperty = lastProperties[_propertyKey8];
            if (nextProperties.hasOwnProperty(_propertyKey8) && (propertyKey != undefined || lastProperty != undefined))
              switch (_propertyKey8) {
                case "type": {
                  type = propertyKey;
                  break;
                }
                case "name": {
                  name = propertyKey;
                  break;
                }
                case "checked": {
                  checked = propertyKey;
                  break;
                }
                case "defaultChecked": {
                  defaultChecked = propertyKey;
                  break;
                }
                case "value": {
                  value = propertyKey;
                  break;
                }
                case "defaultValue": {
                  defaultValue = propertyKey;
                  break;
                }
                case "children":
                case "dangerouslySetInnerHTML": {
                  if (propertyKey != undefined)
                    throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  break;
                }
                default: {
                  propertyKey !== lastProperty && setProp(domElement, tag, _propertyKey8, propertyKey, nextProperties, lastProperty);
                }
              }
          }
          tag = lastProperties.type === "checkbox" || lastProperties.type === "radio" ? lastProperties.checked != undefined : lastProperties.value != undefined;
          nextProperties = nextProperties.type === "checkbox" || nextProperties.type === "radio" ? nextProperties.checked != undefined : nextProperties.value != undefined;
          tag || !nextProperties || didWarnUncontrolledToControlled || (console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnUncontrolledToControlled = true);
          !tag || nextProperties || didWarnControlledToUncontrolled || (console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnControlledToUncontrolled = true);
          updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
          return;
        }
        case "select": {
          propertyKey = value = defaultValue = _propertyKey8 = null;
          for (type in lastProperties)
            if (lastDefaultValue = lastProperties[type], lastProperties.hasOwnProperty(type) && lastDefaultValue != undefined)
              switch (type) {
                case "value": {
                  break;
                }
                case "multiple": {
                  propertyKey = lastDefaultValue;
                }
                default: {
                  nextProperties.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProperties, lastDefaultValue);
                }
              }
          for (name in nextProperties)
            if (type = nextProperties[name], lastDefaultValue = lastProperties[name], nextProperties.hasOwnProperty(name) && (type != undefined || lastDefaultValue != undefined))
              switch (name) {
                case "value": {
                  _propertyKey8 = type;
                  break;
                }
                case "defaultValue": {
                  defaultValue = type;
                  break;
                }
                case "multiple": {
                  value = type;
                }
                default: {
                  type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProperties, lastDefaultValue);
                }
              }
          nextProperties = defaultValue;
          tag = value;
          lastProperties = propertyKey;
          _propertyKey8 == undefined ? Boolean(lastProperties) !== Boolean(tag) && (nextProperties == undefined ? updateOptions(domElement, Boolean(tag), tag ? [] : "", false) : updateOptions(domElement, Boolean(tag), nextProperties, true)) : updateOptions(domElement, Boolean(tag), _propertyKey8, false);
          return;
        }
        case "textarea": {
          propertyKey = _propertyKey8 = null;
          for (defaultValue in lastProperties)
            if (name = lastProperties[defaultValue], lastProperties.hasOwnProperty(defaultValue) && name != undefined && !nextProperties.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value": {
                  break;
                }
                case "children": {
                  break;
                }
                default: {
                  setProp(domElement, tag, defaultValue, null, nextProperties, name);
                }
              }
          for (value in nextProperties)
            if (name = nextProperties[value], type = lastProperties[value], nextProperties.hasOwnProperty(value) && (name != undefined || type != undefined))
              switch (value) {
                case "value": {
                  _propertyKey8 = name;
                  break;
                }
                case "defaultValue": {
                  propertyKey = name;
                  break;
                }
                case "children": {
                  break;
                }
                case "dangerouslySetInnerHTML": {
                  if (name != undefined)
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  break;
                }
                default: {
                  name !== type && setProp(domElement, tag, value, name, nextProperties, type);
                }
              }
          updateTextarea(domElement, _propertyKey8, propertyKey);
          return;
        }
        case "option": {
          for (const _propKey13 in lastProperties)
            if (_propertyKey8 = lastProperties[_propKey13], lastProperties.hasOwnProperty(_propKey13) && _propertyKey8 != undefined && !nextProperties.hasOwnProperty(_propKey13))
              switch (_propKey13) {
                case "selected": {
                  domElement.selected = false;
                  break;
                }
                default: {
                  setProp(domElement, tag, _propKey13, null, nextProperties, _propertyKey8);
                }
              }
          for (lastDefaultValue in nextProperties)
            if (_propertyKey8 = nextProperties[lastDefaultValue], propertyKey = lastProperties[lastDefaultValue], nextProperties.hasOwnProperty(lastDefaultValue) && _propertyKey8 !== propertyKey && (_propertyKey8 != undefined || propertyKey != undefined))
              switch (lastDefaultValue) {
                case "selected": {
                  domElement.selected = _propertyKey8 && typeof _propertyKey8 !== "function" && typeof _propertyKey8 !== "symbol";
                  break;
                }
                default: {
                  setProp(domElement, tag, lastDefaultValue, _propertyKey8, nextProperties, propertyKey);
                }
              }
          return;
        }
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem": {
          for (const _propKey15 in lastProperties)
            _propertyKey8 = lastProperties[_propKey15], lastProperties.hasOwnProperty(_propKey15) && _propertyKey8 != undefined && !nextProperties.hasOwnProperty(_propKey15) && setProp(domElement, tag, _propKey15, null, nextProperties, _propertyKey8);
          for (checked in nextProperties)
            if (_propertyKey8 = nextProperties[checked], propertyKey = lastProperties[checked], nextProperties.hasOwnProperty(checked) && _propertyKey8 !== propertyKey && (_propertyKey8 != undefined || propertyKey != undefined))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML": {
                  if (_propertyKey8 != undefined)
                    throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  break;
                }
                default: {
                  setProp(domElement, tag, checked, _propertyKey8, nextProperties, propertyKey);
                }
              }
          return;
        }
        default: {
          if (isCustomElement(tag)) {
            for (const _propKey17 in lastProperties)
              _propertyKey8 = lastProperties[_propKey17], lastProperties.hasOwnProperty(_propKey17) && _propertyKey8 !== undefined && !nextProperties.hasOwnProperty(_propKey17) && setPropOnCustomElement(domElement, tag, _propKey17, undefined, nextProperties, _propertyKey8);
            for (defaultChecked in nextProperties)
              _propertyKey8 = nextProperties[defaultChecked], propertyKey = lastProperties[defaultChecked], !nextProperties.hasOwnProperty(defaultChecked) || _propertyKey8 === propertyKey || _propertyKey8 === undefined && propertyKey === undefined || setPropOnCustomElement(domElement, tag, defaultChecked, _propertyKey8, nextProperties, propertyKey);
            return;
          }
        }
      }
      for (const _propKey19 in lastProperties)
        _propertyKey8 = lastProperties[_propKey19], lastProperties.hasOwnProperty(_propKey19) && _propertyKey8 != undefined && !nextProperties.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProperties, _propertyKey8);
      for (lastProperty in nextProperties)
        _propertyKey8 = nextProperties[lastProperty], propertyKey = lastProperties[lastProperty], !nextProperties.hasOwnProperty(lastProperty) || _propertyKey8 === propertyKey || _propertyKey8 == undefined && propertyKey == undefined || setProp(domElement, tag, lastProperty, _propertyKey8, nextProperties, propertyKey);
    }
    function getPropNameFromAttributeName(attributeName) {
      switch (attributeName) {
        case "class": {
          return "className";
        }
        case "for": {
          return "htmlFor";
        }
        default: {
          return attributeName;
        }
      }
    }
    function getStylesObjectFromElement(domElement) {
      const serverValueInObjectForm = {};
      domElement = domElement.style;
      for (let index_ = 0;index_ < domElement.length; index_++) {
        const styleName = domElement[index_];
        serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
      }
      return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
      if (value$jscomp$0 != undefined && typeof value$jscomp$0 !== "object")
        console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      else {
        let clientValue;
        let delimiter = clientValue = "", styleName;
        for (styleName in value$jscomp$0)
          if (value$jscomp$0.hasOwnProperty(styleName)) {
            const value = value$jscomp$0[styleName];
            value != undefined && typeof value !== "boolean" && value !== "" && (styleName.indexOf("--") === 0 ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : (typeof value !== "number" || value === 0 || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replaceAll(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replaceAll(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px"), delimiter = ";");
          }
        clientValue = clientValue || null;
        value$jscomp$0 = domElement.getAttribute("style");
        value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
      }
    }
    function hydrateAttribute(domElement, propertyKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean": {
            return;
          }
        }
      else if (value != undefined)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean": {
            break;
          }
          default: {
            if (checkAttributeStringCoercion(value, propertyKey), domElement === "" + value)
              return;
          }
        }
      warnForPropertyDifference(propertyKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(domElement, propertyKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null) {
        switch (typeof value) {
          case "function":
          case "symbol": {
            return;
          }
        }
        if (!value)
          return;
      } else
        switch (typeof value) {
          case "function":
          case "symbol": {
            break;
          }
          default: {
            if (value)
              return;
          }
        }
      warnForPropertyDifference(propertyKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(domElement, propertyKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol": {
            return;
          }
        }
      else if (value != undefined)
        switch (typeof value) {
          case "function":
          case "symbol": {
            break;
          }
          default: {
            if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
              return;
          }
        }
      warnForPropertyDifference(propertyKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(domElement, propertyKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean": {
            return;
          }
          default: {
            if (isNaN(value))
              return;
          }
        }
      else if (value != undefined)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean": {
            break;
          }
          default: {
            if (!isNaN(value) && (checkAttributeStringCoercion(value, propertyKey), domElement === "" + value))
              return;
          }
        }
      warnForPropertyDifference(propertyKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(domElement, propertyKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean": {
            return;
          }
        }
      else if (value != undefined)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean": {
            break;
          }
          default: {
            if (checkAttributeStringCoercion(value, propertyKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
              return;
          }
        }
      warnForPropertyDifference(propertyKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, properties, hostContext) {
      for (var serverDifferences = {}, extraAttributes = new Set, attributes = domElement.attributes, index_ = 0;index_ < attributes.length; index_++)
        switch (attributes[index_].name.toLowerCase()) {
          case "value": {
            break;
          }
          case "checked": {
            break;
          }
          case "selected": {
            break;
          }
          default: {
            extraAttributes.add(attributes[index_].name);
          }
        }
      if (isCustomElement(tag))
        for (var propertyKey in properties) {
          if (properties.hasOwnProperty(propertyKey)) {
            var value = properties[propertyKey];
            if (value != undefined) {
              if (registrationNameDependencies.hasOwnProperty(propertyKey))
                typeof value !== "function" && warnForInvalidEventListener(propertyKey, value);
              else if (properties.suppressHydrationWarning !== true)
                switch (propertyKey) {
                  case "children": {
                    typeof value !== "string" && typeof value !== "number" || warnForPropertyDifference("children", domElement.textContent, value, serverDifferences);
                    continue;
                  }
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref": {
                    continue;
                  }
                  case "dangerouslySetInnerHTML": {
                    attributes = domElement.innerHTML;
                    value = value ? value.__html : undefined;
                    value != undefined && (value = normalizeHTML(domElement, value), warnForPropertyDifference(propertyKey, attributes, value, serverDifferences));
                    continue;
                  }
                  case "style": {
                    extraAttributes.delete(propertyKey);
                    diffHydratedStyles(domElement, value, serverDifferences);
                    continue;
                  }
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML": {
                    extraAttributes.delete(propertyKey.toLowerCase());
                    console.error("Assignment to read-only property will result in a no-op: `%s`", propertyKey);
                    continue;
                  }
                  case "className": {
                    extraAttributes.delete("class");
                    attributes = getValueForAttributeOnCustomComponent(domElement, "class", value);
                    warnForPropertyDifference("className", attributes, value, serverDifferences);
                    continue;
                  }
                  default: {
                    hostContext.context === HostContextNamespaceNone && tag !== "svg" && tag !== "math" ? extraAttributes.delete(propertyKey.toLowerCase()) : extraAttributes.delete(propertyKey), attributes = getValueForAttributeOnCustomComponent(domElement, propertyKey, value), warnForPropertyDifference(propertyKey, attributes, value, serverDifferences);
                  }
                }
            }
          }
        }
      else
        for (value in properties)
          if (properties.hasOwnProperty(value) && (propertyKey = properties[value], propertyKey != undefined)) {
            if (registrationNameDependencies.hasOwnProperty(value))
              typeof propertyKey !== "function" && warnForInvalidEventListener(value, propertyKey);
            else if (properties.suppressHydrationWarning !== true)
              switch (value) {
                case "children": {
                  typeof propertyKey !== "string" && typeof propertyKey !== "number" || warnForPropertyDifference("children", domElement.textContent, propertyKey, serverDifferences);
                  continue;
                }
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref": {
                  continue;
                }
                case "dangerouslySetInnerHTML": {
                  attributes = domElement.innerHTML;
                  propertyKey = propertyKey ? propertyKey.__html : undefined;
                  propertyKey != undefined && (propertyKey = normalizeHTML(domElement, propertyKey), attributes !== propertyKey && (serverDifferences[value] = { __html: attributes }));
                  continue;
                }
                case "className": {
                  hydrateAttribute(domElement, value, "class", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "tabIndex": {
                  hydrateAttribute(domElement, value, "tabindex", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "style": {
                  extraAttributes.delete(value);
                  diffHydratedStyles(domElement, propertyKey, serverDifferences);
                  continue;
                }
                case "multiple": {
                  extraAttributes.delete(value);
                  warnForPropertyDifference(value, domElement.multiple, propertyKey, serverDifferences);
                  continue;
                }
                case "muted": {
                  extraAttributes.delete(value);
                  warnForPropertyDifference(value, domElement.muted, propertyKey, serverDifferences);
                  continue;
                }
                case "autoFocus": {
                  extraAttributes.delete("autofocus");
                  warnForPropertyDifference(value, domElement.autofocus, propertyKey, serverDifferences);
                  continue;
                }
                case "data": {
                  if (tag !== "object") {
                    extraAttributes.delete(value);
                    attributes = domElement.getAttribute("data");
                    warnForPropertyDifference(value, attributes, propertyKey, serverDifferences);
                    continue;
                  }
                }
                case "src":
                case "href": {
                  if (!(propertyKey !== "" || tag === "a" && value === "href" || tag === "object" && value === "data")) {
                    value === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value);
                    continue;
                  }
                  hydrateSanitizedAttribute(domElement, value, value, propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "action":
                case "formAction": {
                  attributes = domElement.getAttribute(value);
                  if (typeof propertyKey === "function") {
                    extraAttributes.delete(value.toLowerCase());
                    value === "formAction" ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                    continue;
                  } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                    extraAttributes.delete(value.toLowerCase());
                    warnForPropertyDifference(value, "function", propertyKey, serverDifferences);
                    continue;
                  }
                  hydrateSanitizedAttribute(domElement, value, value.toLowerCase(), propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xlinkHref": {
                  hydrateSanitizedAttribute(domElement, value, "xlink:href", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "contentEditable": {
                  hydrateBooleanishAttribute(domElement, value, "contenteditable", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "spellCheck": {
                  hydrateBooleanishAttribute(domElement, value, "spellcheck", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha": {
                  hydrateBooleanishAttribute(domElement, value, value, propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope": {
                  hydrateBooleanAttribute(domElement, value, value.toLowerCase(), propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "capture":
                case "download": {
                  a: {
                    index_ = domElement;
                    var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    index_ = index_.getAttribute(attributeName);
                    if (index_ === null)
                      switch (typeof propertyKey) {
                        case "undefined":
                        case "function":
                        case "symbol": {
                          break a;
                        }
                        default: {
                          if (propertyKey === false)
                            break a;
                        }
                      }
                    else if (propertyKey != undefined)
                      switch (typeof propertyKey) {
                        case "function":
                        case "symbol": {
                          break;
                        }
                        case "boolean": {
                          if (propertyKey === true && index_ === "")
                            break a;
                          break;
                        }
                        default: {
                          if (checkAttributeStringCoercion(propertyKey, attributes), index_ === "" + propertyKey)
                            break a;
                        }
                      }
                    warnForPropertyDifference(attributes, index_, propertyKey, serverDifferences$jscomp$0);
                  }
                  continue;
                }
                case "cols":
                case "rows":
                case "size":
                case "span": {
                  a: {
                    index_ = domElement;
                    attributeName = attributes = value;
                    serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    index_ = index_.getAttribute(attributeName);
                    if (index_ === null)
                      switch (typeof propertyKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean": {
                          break a;
                        }
                        default: {
                          if (isNaN(propertyKey) || 1 > propertyKey)
                            break a;
                        }
                      }
                    else if (propertyKey != undefined)
                      switch (typeof propertyKey) {
                        case "function":
                        case "symbol":
                        case "boolean": {
                          break;
                        }
                        default: {
                          if (!(isNaN(propertyKey) || 1 > propertyKey) && (checkAttributeStringCoercion(propertyKey, attributes), index_ === "" + propertyKey))
                            break a;
                        }
                      }
                    warnForPropertyDifference(attributes, index_, propertyKey, serverDifferences$jscomp$0);
                  }
                  continue;
                }
                case "rowSpan": {
                  hydrateNumericAttribute(domElement, value, "rowspan", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "start": {
                  hydrateNumericAttribute(domElement, value, value, propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xHeight": {
                  hydrateAttribute(domElement, value, "x-height", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xlinkActuate": {
                  hydrateAttribute(domElement, value, "xlink:actuate", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xlinkArcrole": {
                  hydrateAttribute(domElement, value, "xlink:arcrole", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xlinkRole": {
                  hydrateAttribute(domElement, value, "xlink:role", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xlinkShow": {
                  hydrateAttribute(domElement, value, "xlink:show", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xlinkTitle": {
                  hydrateAttribute(domElement, value, "xlink:title", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xlinkType": {
                  hydrateAttribute(domElement, value, "xlink:type", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xmlBase": {
                  hydrateAttribute(domElement, value, "xml:base", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xmlLang": {
                  hydrateAttribute(domElement, value, "xml:lang", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "xmlSpace": {
                  hydrateAttribute(domElement, value, "xml:space", propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                case "inert": {
                  propertyKey !== "" || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", value));
                  hydrateBooleanAttribute(domElement, value, value, propertyKey, extraAttributes, serverDifferences);
                  continue;
                }
                default: {
                  if (!(2 < value.length) || value[0] !== "o" && value[0] !== "O" || value[1] !== "n" && value[1] !== "N") {
                    index_ = getAttributeAlias(value);
                    attributes = false;
                    hostContext.context === HostContextNamespaceNone && tag !== "svg" && tag !== "math" ? extraAttributes.delete(index_.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(attributeName) ? possibleStandardNames[attributeName] || null : null, attributeName !== null && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(index_));
                    a:
                      if (attributeName = domElement, serverDifferences$jscomp$0 = index_, index_ = propertyKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                        if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                          attributeName = attributeName.getAttribute(serverDifferences$jscomp$0), checkAttributeStringCoercion(index_, serverDifferences$jscomp$0), index_ = attributeName === "" + index_ ? index_ : attributeName;
                        else {
                          switch (typeof index_) {
                            case "function":
                            case "symbol": {
                              break a;
                            }
                            case "boolean": {
                              if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), attributeName !== "data-" && attributeName !== "aria-")
                                break a;
                            }
                          }
                          index_ = index_ === undefined ? undefined : null;
                        }
                      else
                        index_ = undefined;
                    attributes || warnForPropertyDifference(value, index_, propertyKey, serverDifferences);
                  }
                }
              }
          }
      extraAttributes.size > 0 && properties.suppressHydrationWarning !== true && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
      return Object.keys(serverDifferences).length === 0 ? null : serverDifferences;
    }
    function propertyNamesListJoin(list, combinator) {
      switch (list.length) {
        case 0: {
          return "";
        }
        case 1: {
          return list[0];
        }
        case 2: {
          return list[0] + " " + combinator + " " + list[1];
        }
        default: {
          return list.slice(0, -1).join(", ") + ", " + combinator + " " + list.at(-1);
        }
      }
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return rootContainerElement.nodeType === 9 ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case SVG_NAMESPACE: {
          return HostContextNamespaceSvg;
        }
        case MATH_NAMESPACE: {
          return HostContextNamespaceMath;
        }
        default: {
          return HostContextNamespaceNone;
        }
      }
    }
    function getChildHostContextProduction(parentNamespace, type) {
      if (parentNamespace === HostContextNamespaceNone)
        switch (type) {
          case "svg": {
            return HostContextNamespaceSvg;
          }
          case "math": {
            return HostContextNamespaceMath;
          }
          default: {
            return HostContextNamespaceNone;
          }
        }
      return parentNamespace === HostContextNamespaceSvg && type === "foreignObject" ? HostContextNamespaceNone : parentNamespace;
    }
    function shouldSetTextContent(type, properties) {
      return type === "textarea" || type === "noscript" || typeof properties.children === "string" || typeof properties.children === "number" || typeof properties.children === "bigint" || typeof properties.dangerouslySetInnerHTML === "object" && properties.dangerouslySetInnerHTML !== null && properties.dangerouslySetInnerHTML.__html != undefined;
    }
    function shouldAttemptEagerTransition() {
      const event = window.event;
      if (event && event.type === "popstate") {
        if (event === currentPopstateTransitionEvent)
          return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function commitMount(domElement, type, newProperties) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea": {
          newProperties.autoFocus && domElement.focus();
          break;
        }
        case "img": {
          newProperties.src ? domElement.src = newProperties.src : newProperties.srcSet && (domElement.srcset = newProperties.srcSet);
        }
      }
    }
    function commitUpdate(domElement, type, oldProperties, newProperties) {
      updateProperties(domElement, type, oldProperties, newProperties);
      domElement[internalPropertiesKey] = newProperties;
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function isSingletonScope(type) {
      return type === "head";
    }
    function removeChild(parentInstance, child) {
      child.remove();
    }
    function removeChildFromContainer(container, child) {
      child.remove();
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      let node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
      do {
        const nextNode = node.nextSibling;
        node.remove();
        if (nextNode && nextNode.nodeType === 8)
          if (node = nextNode.data, node === SUSPENSE_END_DATA) {
            if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
              node = possiblePreambleContribution;
              let ownerDocument = parentInstance.ownerDocument;
              node & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);
              node & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);
              if (node & PREAMBLE_CONTRIBUTION_HEAD)
                for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild;ownerDocument; ) {
                  const { nextSibling: nextNode$jscomp$0, nodeName } = ownerDocument;
                  ownerDocument[internalHoistableMarker] || nodeName === "SCRIPT" || nodeName === "STYLE" || nodeName === "LINK" && ownerDocument.rel.toLowerCase() === "stylesheet" || node.removeChild(ownerDocument);
                  ownerDocument = nextNode$jscomp$0;
                }
            }
            if (depth === 0) {
              nextNode.remove();
              retryIfBlockedOn(suspenseInstance);
              return;
            }
            depth--;
          } else
            node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
        else
          possiblePreambleContribution = 0;
        node = nextNode;
      } while (node);
      retryIfBlockedOn(suspenseInstance);
    }
    function hideInstance(instance) {
      instance = instance.style;
      typeof instance.setProperty === "function" ? instance.setProperty("display", "none", "important") : instance.display = "none";
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideInstance(instance, properties) {
      properties = properties[STYLE];
      properties = properties !== undefined && properties !== null && properties.hasOwnProperty("display") ? properties.display : null;
      instance.style.display = properties == undefined || typeof properties === "boolean" ? "" : ("" + properties).trim();
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
      let nextNode = container.firstChild;
      nextNode && nextNode.nodeType === 10 && (nextNode = nextNode.nextSibling);
      for (;nextNode; ) {
        const node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY": {
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          }
          case "SCRIPT":
          case "STYLE": {
            continue;
          }
          case "LINK": {
            if (node.rel.toLowerCase() === "stylesheet")
              continue;
          }
        }
        node.remove();
      }
    }
    function canHydrateInstance(instance, type, properties, inRootOrSingleton) {
      for (;instance.nodeType === 1; ) {
        const anyProperties = properties;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && (instance.nodeName !== "INPUT" || instance.type !== "hidden"))
            break;
        } else if (!inRootOrSingleton)
          if (type === "input" && instance.type === "hidden") {
            checkAttributeStringCoercion(anyProperties.name, "name");
            var name = anyProperties.name == undefined ? null : "" + anyProperties.name;
            if (anyProperties.type === "hidden" && instance.getAttribute("name") === name)
              return instance;
          } else
            return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta": {
              if (!instance.hasAttribute("itemprop"))
                break;
              return instance;
            }
            case "link": {
              name = instance.getAttribute("rel");
              if (name === "stylesheet" && Object.hasOwn(instance.dataset, "precedence"))
                break;
              else if (name !== anyProperties.rel || instance.getAttribute("href") !== (anyProperties.href == undefined || anyProperties.href === "" ? null : anyProperties.href) || instance.getAttribute("crossorigin") !== (anyProperties.crossOrigin == undefined ? null : anyProperties.crossOrigin) || instance.getAttribute("title") !== (anyProperties.title == undefined ? null : anyProperties.title))
                break;
              return instance;
            }
            case "style": {
              if (Object.hasOwn(instance.dataset, "precedence"))
                break;
              return instance;
            }
            case "script": {
              name = instance.getAttribute("src");
              if ((name !== (anyProperties.src == undefined ? null : anyProperties.src) || instance.getAttribute("type") !== (anyProperties.type == undefined ? null : anyProperties.type) || instance.getAttribute("crossorigin") !== (anyProperties.crossOrigin == undefined ? null : anyProperties.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            }
            default: {
              return instance;
            }
          }
        instance = getNextHydratable(instance.nextSibling);
        if (instance === null)
          break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if (text === "")
        return null;
      for (;instance.nodeType !== 3; ) {
        if ((instance.nodeType !== 1 || instance.nodeName !== "INPUT" || instance.type !== "hidden") && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (instance === null)
          return null;
      }
      return instance;
    }
    function isSuspenseInstanceFallback(instance) {
      return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      const ownerDocument = instance.ownerDocument;
      if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
        callback();
      else {
        const listener = function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (;node != undefined; node = node.nextSibling) {
        let nodeType = node.nodeType;
        if (nodeType === 1 || nodeType === 3)
          break;
        if (nodeType === 8) {
          nodeType = node.data;
          if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
            break;
          if (nodeType === SUSPENSE_END_DATA)
            return null;
        }
      }
      return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
      if (instance.nodeType === 1) {
        for (var JSCompiler_temporary_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, index_ = 0;index_ < attributes.length; index_++) {
          const attribute = attributes[index_];
          serverDifferences[getPropNameFromAttributeName(attribute.name)] = attribute.name.toLowerCase() === "style" ? getStylesObjectFromElement(instance) : attribute.value;
        }
        return { type: JSCompiler_temporary_const, props: serverDifferences };
      }
      return instance.nodeType === 8 ? { type: "Suspense", props: {} } : instance.nodeValue;
    }
    function diffHydratedTextForDevelopmentWarnings(textInstance, text, parentProperties) {
      return parentProperties === null || parentProperties[SUPPRESS_HYDRATION_WARNING] !== true ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
      suspenseInstance = suspenseInstance.nextSibling;
      for (let depth = 0;suspenseInstance; ) {
        if (suspenseInstance.nodeType === 8) {
          const data = suspenseInstance.data;
          if (data === SUSPENSE_END_DATA) {
            if (depth === 0)
              return getNextHydratable(suspenseInstance.nextSibling);
            depth--;
          } else
            data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
        }
        suspenseInstance = suspenseInstance.nextSibling;
      }
      return null;
    }
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (let depth = 0;targetInstance; ) {
        if (targetInstance.nodeType === 8) {
          const data = targetInstance.data;
          if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
            if (depth === 0)
              return targetInstance;
            depth--;
          } else
            data === SUSPENSE_END_DATA && depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(type, properties, rootContainerInstance, hostContext, validateDOMNestingDevelopment) {
      validateDOMNestingDevelopment && validateDOMNesting(type, hostContext.ancestorInfo);
      properties = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html": {
          type = properties.documentElement;
          if (!type)
            throw new Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        }
        case "head": {
          type = properties.head;
          if (!type)
            throw new Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        }
        case "body": {
          type = properties.body;
          if (!type)
            throw new Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        }
        default: {
          throw new Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.");
        }
      }
    }
    function acquireSingletonInstance(type, properties, instance, internalInstanceHandle) {
      if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
        var tagName = instance.tagName.toLowerCase();
        console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.", tagName, tagName, tagName);
      }
      switch (type) {
        case "html":
        case "head":
        case "body": {
          break;
        }
        default: {
          console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.");
        }
      }
      for (tagName = instance.attributes;tagName.length > 0; )
        instance.removeAttributeNode(tagName[0]);
      setInitialProperties(instance, type, properties);
      instance[internalInstanceKey] = internalInstanceHandle;
      instance[internalPropertiesKey] = properties;
    }
    function releaseSingletonInstance(instance) {
      for (let attributes = instance.attributes;attributes.length > 0; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    function getHoistableRoot(container) {
      return typeof container.getRootNode === "function" ? container.getRootNode() : (container.nodeType === 9 ? container : container.ownerDocument);
    }
    function preconnectAs(rel, href, crossOrigin) {
      const ownerDocument = globalDocument;
      if (ownerDocument && typeof href === "string" && href) {
        let limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        typeof crossOrigin === "string" && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, ownerDocument.querySelector(limitedEscapedHref) === null && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function getResource(type, currentProperties, pendingProperties, currentResource) {
      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
      if (!resourceRoot)
        throw new Error('"resourceRoot" was expected to exist. This is a bug in React.');
      switch (type) {
        case "meta":
        case "title": {
          return null;
        }
        case "style": {
          return typeof pendingProperties.precedence === "string" && typeof pendingProperties.href === "string" ? (pendingProperties = getStyleKey(pendingProperties.href), currentProperties = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProperties.get(pendingProperties), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, currentProperties.set(pendingProperties, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        }
        case "link": {
          if (pendingProperties.rel === "stylesheet" && typeof pendingProperties.href === "string" && typeof pendingProperties.precedence === "string") {
            type = getStyleKey(pendingProperties.href);
            let _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
            if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: NotLoaded, preload: null }
            }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(getStylesheetSelectorFromKey(type))) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropertiesMap.has(type))) {
              const preloadProperties = {
                rel: "preload",
                as: "style",
                href: pendingProperties.href,
                crossOrigin: pendingProperties.crossOrigin,
                integrity: pendingProperties.integrity,
                media: pendingProperties.media,
                hrefLang: pendingProperties.hrefLang,
                referrerPolicy: pendingProperties.referrerPolicy
              };
              preloadPropertiesMap.set(type, preloadProperties);
              _styles || preloadStylesheet(resourceRoot, type, preloadProperties, _resource.state);
            }
            if (currentProperties && currentResource === null)
              throw pendingProperties = `

  - ` + describeLinkForResourceErrorDEV(currentProperties) + `
  + ` + describeLinkForResourceErrorDEV(pendingProperties), new Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProperties);
            return _resource;
          }
          if (currentProperties && currentResource !== null)
            throw pendingProperties = `

  - ` + describeLinkForResourceErrorDEV(currentProperties) + `
  + ` + describeLinkForResourceErrorDEV(pendingProperties), new Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProperties);
          return null;
        }
        case "script": {
          return currentProperties = pendingProperties.async, pendingProperties = pendingProperties.src, typeof pendingProperties === "string" && currentProperties && typeof currentProperties !== "function" && typeof currentProperties !== "symbol" ? (pendingProperties = getScriptKey(pendingProperties), currentProperties = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProperties.get(pendingProperties), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, currentProperties.set(pendingProperties, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        }
        default: {
          throw new Error('getResource encountered a type it did not expect: "' + type + '". this is a bug in React.');
        }
      }
    }
    function describeLinkForResourceErrorDEV(properties) {
      let describedProperties = 0, description = "<link";
      typeof properties.rel === "string" ? (describedProperties++, description += ' rel="' + properties.rel + '"') : hasOwnProperty.call(properties, "rel") && (describedProperties++, description += ' rel="' + (properties.rel === null ? "null" : "invalid type " + typeof properties.rel) + '"');
      typeof properties.href === "string" ? (describedProperties++, description += ' href="' + properties.href + '"') : hasOwnProperty.call(properties, "href") && (describedProperties++, description += ' href="' + (properties.href === null ? "null" : "invalid type " + typeof properties.href) + '"');
      typeof properties.precedence === "string" ? (describedProperties++, description += ' precedence="' + properties.precedence + '"') : hasOwnProperty.call(properties, "precedence") && (describedProperties++, description += " precedence={" + (properties.precedence === null ? "null" : "invalid type " + typeof properties.precedence) + "}");
      Object.getOwnPropertyNames(properties).length > describedProperties && (description += " ...");
      return description + " />";
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropertiesFromRawProperties(rawProperties) {
      return assign({}, rawProperties, {
        "data-precedence": rawProperties.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProperties, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
        return state.loading |= Loaded;
      }), key.addEventListener("error", function() {
        return state.loading |= Errored;
      }), setInitialProperties(key, "link", preloadProperties), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(source) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(source) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, properties) {
      resource.count++;
      if (resource.instance === null)
        switch (resource.type) {
          case "style": {
            var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(properties.href) + '"]');
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProperties = assign({}, properties, {
              "data-href": properties.href,
              "data-precedence": properties.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProperties);
            insertStylesheet(instance, properties.precedence, hoistableRoot);
            return resource.instance = instance;
          }
          case "stylesheet": {
            styleProperties = getStyleKey(properties.href);
            var _instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProperties));
            if (_instance)
              return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
            instance = stylesheetPropertiesFromRawProperties(properties);
            (styleProperties = preloadPropertiesMap.get(styleProperties)) && adoptPreloadPropertiesForStylesheet(instance, styleProperties);
            _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(_instance);
            const linkInstance = _instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.addEventListener('load', resolve);
              linkInstance.onerror = reject;
            });
            setInitialProperties(_instance, "link", instance);
            resource.state.loading |= Inserted;
            insertStylesheet(_instance, properties.precedence, hoistableRoot);
            return resource.instance = _instance;
          }
          case "script": {
            _instance = getScriptKey(properties.src);
            if (styleProperties = hoistableRoot.querySelector(getScriptSelectorFromKey(_instance)))
              return resource.instance = styleProperties, markNodeAsHoistable(styleProperties), styleProperties;
            instance = properties;
            if (styleProperties = preloadPropertiesMap.get(_instance))
              instance = assign({}, properties), adoptPreloadPropertiesForScript(instance, styleProperties);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProperties = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProperties);
            setInitialProperties(styleProperties, "link", instance);
            hoistableRoot.head.append(styleProperties);
            return resource.instance = styleProperties;
          }
          case "void": {
            return null;
          }
          default: {
            throw new Error('acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.');
          }
        }
      else
        resource.type === "stylesheet" && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, properties.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root2) {
      for (var nodes = root2.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length > 0 ? nodes.at(-1) : null, prior = last, index_ = 0;index_ < nodes.length; index_++) {
        const node = nodes[index_];
        if (node.dataset.precedence === precedence)
          prior = node;
        else if (prior !== last)
          break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = root2.nodeType === 9 ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropertiesForStylesheet(stylesheetProperties, preloadProperties) {
      stylesheetProperties.crossOrigin == undefined && (stylesheetProperties.crossOrigin = preloadProperties.crossOrigin);
      stylesheetProperties.referrerPolicy == undefined && (stylesheetProperties.referrerPolicy = preloadProperties.referrerPolicy);
      stylesheetProperties.title == undefined && (stylesheetProperties.title = preloadProperties.title);
    }
    function adoptPreloadPropertiesForScript(scriptProperties, preloadProperties) {
      scriptProperties.crossOrigin == undefined && (scriptProperties.crossOrigin = preloadProperties.crossOrigin);
      scriptProperties.referrerPolicy == undefined && (scriptProperties.referrerPolicy = preloadProperties.referrerPolicy);
      scriptProperties.integrity == undefined && (scriptProperties.integrity = preloadProperties.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (tagCaches === null) {
        var cache = new Map;
        var caches = tagCaches = new Map;
        caches.set(ownerDocument, cache);
      } else
        caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map, caches.set(ownerDocument, cache));
      if (cache.has(type))
        return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0;caches < ownerDocument.length; caches++) {
        const node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || type === "link" && node.getAttribute("rel") === "stylesheet") && node.namespaceURI !== SVG_NAMESPACE) {
          let nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          const existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(instance, type === "title" ? hoistableRoot.querySelector("head > title") : null);
    }
    function isHostHoistableType(type, properties, hostContext) {
      const outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
      if (hostContext.context === HostContextNamespaceSvg || properties.itemProp != undefined)
        return !outsideHostContainerContext || properties.itemProp == undefined || type !== "meta" && type !== "title" && type !== "style" && type !== "link" && type !== "script" || console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.", type, type), false;
      switch (type) {
        case "meta":
        case "title": {
          return true;
        }
        case "style": {
          if (typeof properties.precedence !== "string" || typeof properties.href !== "string" || properties.href === "") {
            outsideHostContainerContext && console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.');
            break;
          }
          return true;
        }
        case "link": {
          if (typeof properties.rel !== "string" || typeof properties.href !== "string" || properties.href === "" || properties.onLoad || properties.onError) {
            if (properties.rel === "stylesheet" && typeof properties.precedence === "string") {
              type = properties.href;
              let { onError, disabled } = properties;
              hostContext = [];
              properties.onLoad && hostContext.push("`onLoad`");
              onError && hostContext.push("`onError`");
              disabled != undefined && hostContext.push("`disabled`");
              onError = propertyNamesListJoin(hostContext, "and");
              onError += hostContext.length === 1 ? " prop" : " props";
              disabled = hostContext.length === 1 ? "an " + onError : "the " + onError;
              hostContext.length && console.error('React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', type, disabled, onError);
            }
            outsideHostContainerContext && (typeof properties.rel !== "string" || typeof properties.href !== "string" || properties.href === "" ? console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag") : (properties.onError || properties.onLoad) && console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));
            break;
          }
          switch (properties.rel) {
            case "stylesheet": {
              return type = properties.precedence, properties = properties.disabled, typeof type !== "string" && outsideHostContainerContext && console.error('Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'), typeof type === "string" && properties == undefined;
            }
            default: {
              return true;
            }
          }
        }
        case "script": {
          type = properties.async && typeof properties.async !== "function" && typeof properties.async !== "symbol";
          if (!type || properties.onLoad || properties.onError || !properties.src || typeof properties.src !== "string") {
            outsideHostContainerContext && (type ? (properties.onLoad || properties.onError ? console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.")) : console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'));
            break;
          }
          return true;
        }
        case "noscript":
        case "template": {
          outsideHostContainerContext && console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.", type);
        }
      }
      return false;
    }
    function preloadResource(resource) {
      return resource.type === "stylesheet" && (resource.state.loading & Settled) === NotLoaded ? false : true;
    }
    function noop() {}
    function suspendResource(hoistableRoot, resource, properties) {
      if (suspendedState === null)
        throw new Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
      let state = suspendedState;
      if (resource.type === "stylesheet" && (typeof properties.media !== "string" || matchMedia(properties.media).matches !== false) && (resource.state.loading & Inserted) === NotLoaded) {
        if (resource.instance === null) {
          let key = getStyleKey(properties.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
          if (instance) {
            hoistableRoot = instance._p;
            hoistableRoot !== null && typeof hoistableRoot === "object" && typeof hoistableRoot.then === "function" && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= Inserted;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          properties = stylesheetPropertiesFromRawProperties(properties);
          (key = preloadPropertiesMap.get(key)) && adoptPreloadPropertiesForStylesheet(properties, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          const linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.addEventListener('load', resolve);
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", properties);
          resource.instance = instance;
        }
        state.stylesheets === null && (state.stylesheets = new Map);
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady() {
      if (suspendedState === null)
        throw new Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
      const state = suspendedState;
      state.stylesheets && state.count === 0 && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count ? function(commit) {
        const stylesheetTimer = setTimeout(function() {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            const unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 60_000);
        state.unsuspend = commit;
        return function() {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (this.count === 0) {
        if (this.stylesheets)
          insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          const unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      state.unsuspend !== null && (state.count++, precedencesByRoot = new Map, resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root2, resource) {
      if (!(resource.state.loading & Inserted)) {
        let precedences = precedencesByRoot.get(root2);
        if (precedences)
          var last = precedences.get(LAST_PRECEDENCE);
        else {
          precedences = new Map;
          precedencesByRoot.set(root2, precedences);
          for (var nodes = root2.querySelectorAll("link[data-precedence],style[data-precedence]"), index_ = 0;index_ < nodes.length; index_++) {
            var node = nodes[index_];
            if (node.nodeName === "LINK" || node.getAttribute("media") !== "not all")
              precedences.set(node.dataset.precedence, node), last = node;
          }
          last && precedences.set(LAST_PRECEDENCE, last);
        }
        nodes = resource.instance;
        node = nodes.dataset.precedence;
        index_ = precedences.get(node) || last;
        index_ === last && precedences.set(LAST_PRECEDENCE, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        index_ ? index_.parentNode.insertBefore(nodes, index_.nextSibling) : (root2 = root2.nodeType === 9 ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
        resource.state.loading |= Inserted;
      }
    }
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map;
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set;
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0;31 > tag; tag++)
        containerInfo.push(new Set);
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
      containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
      tag = ConcurrentMode;
      isStrictMode === true && (tag |= StrictLegacyMode | StrictEffectsMode);
      isDevelopmentToolsPresent && (tag |= ProfileMode);
      isStrictMode = createFiber(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent)
        return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function")
        try {
          injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (error) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %s", error));
        }
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function" && injectedProfilingHooks.markRenderScheduled(lane);
      parentComponent = getContextForSubtree(parentComponent);
      container.context === null ? container.context = parentComponent : container.pendingContext = parentComponent;
      isRendering && current !== null && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, getComponentNameFromFiber(current) || "Unknown"));
      container = createUpdate(lane);
      container.payload = { element };
      callback = callback === undefined ? null : callback;
      callback !== null && (typeof callback !== "function" && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      element !== null && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (fiber !== null && fiber.dehydrated !== null) {
        const a = fiber.retryLane;
        fiber.retryLane = a !== 0 && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (fiber.tag === 13) {
        const root2 = enqueueConcurrentRenderForLane(fiber, 67_108_864);
        root2 !== null && scheduleUpdateOnFiber(root2, fiber, 67_108_864);
        markRetryLaneIfNotHydrated(fiber, 67_108_864);
      }
    }
    function getCurrentFiberForDevelopmentTools() {
      return current;
    }
    function getLaneLabelMap() {
      for (var map = new Map, lane = 1, index = 0;31 > index; index++) {
        const label = getLabelForLane(lane);
        map.set(lane, label);
        lane *= 2;
      }
      return map;
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      const previousTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      const previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = previousTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      const previousTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      const previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = previousTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        let blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (blockedOn === null)
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (;blockedOn !== null; ) {
            let fiber = getInstanceFromNode(blockedOn);
            if (fiber !== null)
              switch (fiber.tag) {
                case 3: {
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    let lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (lanes !== 0) {
                      var root2 = fiber;
                      root2.pendingLanes |= 2;
                      for (root2.entangledLanes |= 2;lanes; ) {
                        const lane = 1 << 31 - clz32(lanes);
                        root2.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                    }
                  }
                  break;
                }
                case 13: {
                  root2 = enqueueConcurrentRenderForLane(fiber, 2), root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            fiber === null && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            if (fiber === blockedOn)
              break;
            blockedOn = fiber;
          }
          blockedOn !== null && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (targetNode !== null) {
        const nearestMounted = getNearestMountedFiber(targetNode);
        if (nearestMounted === null)
          targetNode = null;
        else {
          const tag = nearestMounted.tag;
          if (tag === 13) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (targetNode !== null)
              return targetNode;
            targetNode = null;
          } else if (tag === 3) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return nearestMounted.tag === 3 ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else
            nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart": {
          return DiscreteEventPriority;
        }
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave": {
          return ContinuousEventPriority;
        }
        case "message": {
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority: {
              return DiscreteEventPriority;
            }
            case UserBlockingPriority: {
              return ContinuousEventPriority;
            }
            case NormalPriority$1:
            case LowPriority: {
              return DefaultEventPriority;
            }
            case IdlePriority: {
              return IdleEventPriority;
            }
            default: {
              return DefaultEventPriority;
            }
          }
        }
        default: {
          return DefaultEventPriority;
        }
      }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout": {
          queuedFocus = null;
          break;
        }
        case "dragenter":
        case "dragleave": {
          queuedDrag = null;
          break;
        }
        case "mouseover":
        case "mouseout": {
          queuedMouse = null;
          break;
        }
        case "pointerover":
        case "pointerout": {
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, blockedOn !== null && (blockedOn = getInstanceFromNode(blockedOn), blockedOn !== null && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      targetContainer !== null && !blockedOn.includes(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin": {
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
        }
        case "dragenter": {
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
        }
        case "mouseover": {
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
        }
        case "pointerover": {
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
          return true;
        }
        case "gotpointercapture": {
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true;
        }
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      let targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (targetInst !== null) {
        const nearestMounted = getNearestMountedFiber(targetInst);
        if (nearestMounted !== null) {
          if (targetInst = nearestMounted.tag, targetInst === 13) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), targetInst !== null) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                if (nearestMounted.tag === 13) {
                  let lane = requestUpdateLane(nearestMounted);
                  lane = getBumpedLaneForHydrationByLane(lane);
                  const root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                  root2 !== null && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                  markRetryLaneIfNotHydrated(nearestMounted, lane);
                }
              });
              return;
            }
          } else if (targetInst === 3 && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = nearestMounted.tag === 3 ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (queuedEvent.blockedOn !== null)
        return false;
      for (let targetContainers = queuedEvent.targetContainers;targetContainers.length > 0; ) {
        let nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (nextBlockedOn === null) {
          nextBlockedOn = queuedEvent.nativeEvent;
          const nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn), event = nativeEventClone;
          currentReplayingEvent !== null && console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = event;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent === null && console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), targetContainers !== null && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
        for (let index_ = 0;index_ < formReplayingQueue.length; index_ += 3) {
          let form = formReplayingQueue[index_], submitterOrAction = formReplayingQueue[index_ + 1], formData = formReplayingQueue[index_ + 2];
          if (typeof submitterOrAction !== "function")
            if (findInstanceBlockingTarget(submitterOrAction || form) === null)
              continue;
            else
              break;
          const formInst = getInstanceFromNode(form);
          formInst !== null && (formReplayingQueue.splice(index_, 3), index_ -= 3, form = {
            pending: true,
            data: formData,
            method: form.method,
            action: submitterOrAction
          }, Object.freeze(form), startHostTransition(formInst, form, submitterOrAction, formData));
        }
      }));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var index_ = 0;index_ < queuedExplicitHydrationTargets.length; index_++) {
        var queuedTarget = queuedExplicitHydrationTargets[index_];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (;queuedExplicitHydrationTargets.length > 0 && (index_ = queuedExplicitHydrationTargets[0], index_.blockedOn === null); )
        attemptExplicitHydrationTarget(index_), index_.blockedOn === null && queuedExplicitHydrationTargets.shift();
      index_ = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (index_ != undefined)
        for (queuedTarget = 0;queuedTarget < index_.length; queuedTarget += 3) {
          let form = index_[queuedTarget], submitterOrAction = index_[queuedTarget + 1], formProperties = form[internalPropertiesKey] || null;
          if (typeof submitterOrAction === "function")
            formProperties || scheduleReplayQueueIfNeeded(index_);
          else if (formProperties) {
            let action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProperties = submitterOrAction[internalPropertiesKey] || null)
                action = formProperties.formAction;
              else {
                if (findInstanceBlockingTarget(form) !== null)
                  continue;
              }
            else
              action = formProperties.action;
            typeof action === "function" ? index_[queuedTarget + 1] = action : (index_.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(index_);
          }
        }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
      container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
      pending: false,
      data: null,
      method: null,
      action: null
    }), valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue2 = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevelopmentToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined", clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log2 = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4_194_304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268_435_456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropertiesKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = new Set, registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
      button: true,
      checkbox: true,
      image: true,
      hidden: true,
      radio: true,
      reset: true,
      submit: true
    }, VALID_ATTRIBUTE_NAME_REGEX = new RegExp(String.raw`^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$`), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, disabledDepth = 0, previousLog, previousInfo, previousWarn, previousError, previousGroup, previousGroupCollapsed, previousGroupEnd;
    disabledLog.__reactDisabledLog = true;
    var prefix, suffix, reentry = false;
    var componentFrameCache = new (typeof WeakMap === "function" ? WeakMap : Map);
    var current = null, isRendering = false, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
    var didWarnValueDefaultValue = false;
    var valuePropertyNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /[\t\n"&'<>]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(" "), buttonScopeTags = new Set([...inScopeTags, "button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDevelopment = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null,
      implicitRootScope: false
    }, didWarn = {}, shorthandToLonghand = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), possibleStandardNames = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, ariaProperties = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, warnedProperties$1 = {}, rARIA$1 = new RegExp(String.raw`^(aria)-[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$`), rARIACamel$1 = new RegExp(String.raw`^(aria)[A-Z][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$`), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = new RegExp(String.raw`^(aria)-[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$`), rARIACamel = new RegExp(String.raw`^(aria)[A-Z][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$`), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\t\n\r]*a[\t\n\r]*v[\t\n\r]*a[\t\n\r]*s[\t\n\r]*c[\t\n\r]*r[\t\n\r]*i[\t\n\r]*p[\t\n\r]*t[\t\n\r]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !(globalThis.window === undefined || globalThis.document === undefined || globalThis.document.createElement === undefined), passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        const options$jscomp$0 = {};
        Object.defineProperty(options$jscomp$0, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        globalThis.addEventListener("test", options$jscomp$0, options$jscomp$0);
        globalThis.removeEventListener("test", options$jscomp$0, options$jscomp$0);
      } catch {
        passiveBrowserEventsSupported = false;
      }
    var root = null, startText = null, fallbackText = null, EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return event.relatedTarget === undefined ? (event.fromElement === event.srcElement ? event.toElement : event.fromElement) : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event)
          return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && event.type === "mousemove" ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : globalThis.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, KeyboardEventInterface = assign({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          const key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if (key !== "Unidentified")
            return key;
        }
        return nativeEvent.type === "keypress" ? (nativeEvent = getEventCharCode(nativeEvent), nativeEvent === 13 ? "Enter" : String.fromCharCode(nativeEvent)) : (nativeEvent.type === "keydown" || nativeEvent.type === "keyup" ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "");
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return event.type === "keypress" ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
      },
      which: function(event) {
        return event.type === "keypress" ? getEventCharCode(event) : (event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0);
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : (("wheelDeltaX" in event) ? -event.wheelDeltaX : 0);
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : ("wheelDeltaY" in event) ? -event.wheelDeltaY : ("wheelDelta" in event) ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = new Set([9, 13, 27, 32]), START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in globalThis, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in globalThis && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
    canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
    var objectIs = typeof Object.is === "function" ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    }, prefixedEventNames = {}, style = {};
    canUseDOM && (style = document.createElement("div").style, ("AnimationEvent" in globalThis) || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), ("TransitionEvent" in globalThis) || delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = new Map, simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    simpleEventPluginEvents.push("scrollEnd");
    var CapturedStacks = new WeakMap, OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64;
    var hasBadMapPolyfill = false;
    try {
      const nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch {
      hasBadMapPolyfill = true;
    }
    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = new Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), lastResetTime = 0;
    if (typeof performance === "object" && typeof performance.now === "function") {
      const localPerformance = performance;
      var getCurrentTime = function() {
        return localPerformance.now();
      };
    } else {
      const localDate = Date;
      getCurrentTime = function() {
        return localDate.now();
      };
    }
    var valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = typeof AbortController === "undefined" ? function() {
      const listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        for (const listener of listeners) {
           listener(); continue;
        }
      };
    } : AbortController, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, previousOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && entangleAsyncAction(transition, returnValue);
      previousOnStartTransitionFinish !== null && previousOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null), ReactStrictModeWarnings = {
      recordUnsafeLifecycleWarnings: function() {},
      flushPendingUnsafeLifecycleWarnings: function() {},
      recordLegacyContextWarning: function() {},
      flushLegacyContextWarning: function() {},
      discardPendingWarnings: function() {}
    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropertiesWarnings = [], pendingUNSAFE_ComponentWillReceivePropertiesWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set;
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) || (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function" && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true && pendingComponentWillReceivePropertiesWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function" && pendingUNSAFE_ComponentWillReceivePropertiesWarnings.push(fiber), typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function" && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
      const componentWillMountUniqueNames = new Set;
      pendingComponentWillMountWarnings.length > 0 && (pendingComponentWillMountWarnings.forEach(function(fiber) {
        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillMountWarnings = []);
      const UNSAFE_componentWillMountUniqueNames = new Set;
      pendingUNSAFE_ComponentWillMountWarnings.length > 0 && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillMountWarnings = []);
      const componentWillReceivePropertiesUniqueNames = new Set;
      pendingComponentWillReceivePropertiesWarnings.length > 0 && (pendingComponentWillReceivePropertiesWarnings.forEach(function(fiber) {
        componentWillReceivePropertiesUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillReceivePropertiesWarnings = []);
      const UNSAFE_componentWillReceivePropertiesUniqueNames = new Set;
      pendingUNSAFE_ComponentWillReceivePropertiesWarnings.length > 0 && (pendingUNSAFE_ComponentWillReceivePropertiesWarnings.forEach(function(fiber) {
        UNSAFE_componentWillReceivePropertiesUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillReceivePropertiesWarnings = []);
      const componentWillUpdateUniqueNames = new Set;
      pendingComponentWillUpdateWarnings.length > 0 && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillUpdateWarnings = []);
      const UNSAFE_componentWillUpdateUniqueNames = new Set;
      pendingUNSAFE_ComponentWillUpdateWarnings.length > 0 && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
      if (UNSAFE_componentWillMountUniqueNames.size > 0) {
        var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
        console.error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, sortedNames);
      }
      UNSAFE_componentWillReceivePropertiesUniqueNames.size > 0 && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropertiesUniqueNames), console.error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`, sortedNames));
      UNSAFE_componentWillUpdateUniqueNames.size > 0 && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, sortedNames));
      componentWillMountUniqueNames.size > 0 && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      componentWillReceivePropertiesUniqueNames.size > 0 && (sortedNames = setToSortedString(componentWillReceivePropertiesUniqueNames), console.warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      componentWillUpdateUniqueNames.size > 0 && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
    };
    let pendingLegacyContextWarning = new Map, didWarnAboutLegacyContext = new Set;
    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
      let strictRoot = null;
      for (var node = fiber;node !== null; )
        node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
      strictRoot === null ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), fiber.type.contextTypes != undefined || fiber.type.childContextTypes != undefined || instance !== null && typeof instance.getChildContext === "function") && (node === undefined && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
      for (const fiberArray of pendingLegacyContextWarning) {
        if (fiberArray.length > 0) {
          const firstFiber = fiberArray[0], uniqueNames = new Set;
          for (const fiber of fiberArray) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          }
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function() {
            console.error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`, sortedNames);
          });
        }
      }
    };
    ReactStrictModeWarnings.discardPendingWarnings = function() {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropertiesWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropertiesWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map;
    };
    var SuspenseException = new Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), SuspenseyCommitException = new Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), SuspenseActionException = new Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."), noopSuspenseyCommitThenable = {
      then: function() {
        console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
      }
    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
    var didWarnUpdateInsideUpdate = false;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set;
    var didWarnAboutUseWrappedInTryCatch = new Set;
    var didWarnAboutAsyncClientComponent = new Set;
    var didWarnAboutUseFormState = new Set;
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, createDeps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(createDeps);
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function(reference, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(reference, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useReducer: function(reducer, initialArgument, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArgument, init);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function(reference, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(reference, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useReducer: function(reducer, initialArgument, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArgument, init);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function(reference, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(reference, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useReducer: function(reducer, initialArgument, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArgument, init);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function(reference, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(reference, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useReducer: function(reducer, initialArgument, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArgument, init);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function(reference, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(reference, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useReducer: function(reducer, initialArgument, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArgument, init);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function(reference, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(reference, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useReducer: function(reducer, initialArgument, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArgument, init);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function(reference, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(reference, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useReducer: function(reducer, initialArgument, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArgument, init);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        const previousDispatcher_ = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = previousDispatcher_;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    var callComponent = {
      "react-stack-bottom-frame": function(Component, properties, secondArgument) {
        const wasRendering = isRendering;
        isRendering = true;
        try {
          return Component(properties, secondArgument);
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
      "react-stack-bottom-frame": function(instance) {
        const wasRendering = isRendering;
        isRendering = true;
        try {
          return instance.render();
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callComponentDidMount = {
      "react-stack-bottom-frame": function(finishedWork, instance) {
        try {
          instance.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount), callComponentDidUpdate = {
      "react-stack-bottom-frame": function(finishedWork, instance, previousProperties, previousState, snapshot) {
        try {
          instance.componentDidUpdate(previousProperties, previousState, snapshot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate), callComponentDidCatch = {
      "react-stack-bottom-frame": function(instance, errorInfo) {
        const stack = errorInfo.stack;
        instance.componentDidCatch(errorInfo.value, {
          componentStack: stack === null ? "" : stack
        });
      }
    }, callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch), callComponentWillUnmount = {
      "react-stack-bottom-frame": function(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount), callCreate = {
      "react-stack-bottom-frame": function(effect) {
        effect.resourceKind != undefined && console.error("Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s", effect.resourceKind);
        let create = effect.create;
        effect = effect.inst;
        create = create();
        return effect.destroy = create;
      }
    }, callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate), callDestroy = {
      "react-stack-bottom-frame": function(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy), callLazyInit = {
      "react-stack-bottom-frame": function(lazy) {
        const init = lazy._init;
        return init(lazy._payload);
      }
    }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), thenableState = null, thenableIndexCounter = 0, currentDebugInfo = null, didWarnAboutMaps;
    var didWarnAboutGenerators = didWarnAboutMaps = false;
    const ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function(returnFiber, workInProgress2, child) {
      if (child !== null && typeof child === "object" && child._store && (!child._store.validated && child.key == undefined || child._store.validated === 2)) {
        if (typeof child._store !== "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = 1;
        let componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = true;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          let currentComponentErrorInfo = "";
          returnFiber && typeof returnFiber.tag === "number" && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = `

Check the render method of \`` + componentKey + "`.");
          currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = `

Check the top-level render call using <` + componentName2 + ">.");
          let childOwnerAppendix = "";
          child != undefined && returnFiber !== child && (componentName2 = null, typeof child.tag === "number" ? componentName2 = getComponentNameFromFiber(child) : typeof child.name === "string" && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
          runWithFiberInDEV(workInProgress2, function() {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set;
    var didWarnAboutUninitializedState = new Set;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
    var didWarnAboutDirectlyAssigningPropsToState = new Set;
    var didWarnAboutUndefinedDerivedState = new Set;
    var didWarnAboutContextTypes$1 = new Set;
    var didWarnAboutChildContextTypes = new Set;
    var didWarnAboutInvalidateContextType = new Set;
    var didWarnOnInvalidCallback = new Set;
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        const lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        markStateUpdateScheduled(inst, lane);
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        const lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ReplaceState;
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        markStateUpdateScheduled(inst, lane);
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        const lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ForceUpdate;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        callback !== null && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function" && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
      }
    }, reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof globalThis.window === "object" && typeof globalThis.ErrorEvent === "function") {
        const event = new globalThis.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!globalThis.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = new Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), didReceiveUpdate = false;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = false;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, hasWarnedAboutUsingNoValuePropertyOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set;
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        let cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        cacheForType === undefined && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      getOwner: function() {
        return current;
      }
    };
    if (typeof Symbol === "function" && Symbol.for) {
      const symbolFor = Symbol.for;
      symbolFor("selector.component");
      symbolFor("selector.has_pseudo_class");
      symbolFor("selector.role");
      symbolFor("selector.test_id");
      symbolFor("selector.text");
    }
    var commitHooks = [], PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set;
    var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
    (function() {
      for (let eventName of simpleEventPluginEvents) {
        const domEventName = eventName.toLowerCase();
        eventName = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + eventName);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = 1, PREAMBLE_CONTRIBUTION_BODY = 2, PREAMBLE_CONTRIBUTION_HEAD = 4, FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_COMPLETE = "complete", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, scheduleTimeout = typeof setTimeout === "function" ? setTimeout : undefined, cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : undefined, noTimeout = -1, localPromise = typeof Promise === "function" ? Promise : undefined, scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : (localPromise === undefined ? scheduleTimeout : function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    }), previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropertiesMap = new Map, preconnectsSet = new Set, previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: function() {
        const previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      },
      r: function(form) {
        const formInst = getInstanceFromNode(form);
        formInst !== null && formInst.tag === 5 && formInst.type === "form" ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      },
      D: function(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      },
      C: function(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      },
      L: function(href, as, options) {
        previousDispatcher.L(href, as, options);
        const ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          let preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          as === "image" ? (options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', typeof options.imageSizes === "string" && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]') : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          let key = preloadSelector;
          switch (as) {
            case "style": {
              key = getStyleKey(href);
              break;
            }
            case "script": {
              key = getScriptKey(href);
            }
          }
          preloadPropertiesMap.has(key) || (href = assign({
            rel: "preload",
            href: as === "image" && options && options.imageSrcSet ? undefined : href,
            as
          }, options), preloadPropertiesMap.set(key, href), ownerDocument.querySelector(preloadSelector) !== null || as === "style" && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || as === "script" && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      },
      m: function(href, options) {
        previousDispatcher.m(href, options);
        const ownerDocument = globalDocument;
        if (ownerDocument && href) {
          let as = options && typeof options.as === "string" ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script": {
              key = getScriptKey(href);
            }
          }
          if (!preloadPropertiesMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropertiesMap.set(key, href), ownerDocument.querySelector(preloadSelector) === null)) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script": {
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
              }
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.append(as);
          }
        }
      },
      X: function(source, options) {
        previousDispatcher.X(source, options);
        const ownerDocument = globalDocument;
        if (ownerDocument && source) {
          let scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(source), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (source = assign({ src: source, async: true }, options), (options = preloadPropertiesMap.get(key)) && adoptPreloadPropertiesForScript(source, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", source), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      },
      S: function(href, precedence, options) {
        previousDispatcher.S(href, precedence, options);
        const ownerDocument = globalDocument;
        if (ownerDocument && href) {
          const styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          let resource = styles.get(key);
          if (!resource) {
            const state = { loading: NotLoaded, preload: null };
            if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key)))
              state.loading = Loaded | Inserted;
            else {
              href = assign({
                rel: "stylesheet",
                href,
                "data-precedence": precedence
              }, options);
              (options = preloadPropertiesMap.get(key)) && adoptPreloadPropertiesForStylesheet(href, options);
              const link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.addEventListener('load', resolve);
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= Loaded;
              });
              link.addEventListener("error", function() {
                state.loading |= Errored;
              });
              state.loading |= Inserted;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      },
      M: function(source, options) {
        previousDispatcher.M(source, options);
        const ownerDocument = globalDocument;
        if (ownerDocument && source) {
          let scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(source), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (source = assign({ src: source, async: true, type: "module" }, options), (options = preloadPropertiesMap.get(key)) && adoptPreloadPropertiesForScript(source, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", source), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
    };
    var globalDocument = typeof document === "undefined" ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: NotPendingTransition,
      _currentValue2: NotPendingTransition,
      _threadCount: 0
    }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = false;
    let overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProperties = null, overridePropertiesDeletePath = null, overridePropertiesRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
    overrideHookState = function(fiber, id, path, value) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function(fiber, id, path) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      id !== null && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProperties = function(fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropertiesDeletePath = function(fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropertiesRenamePath = function(fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function(fiber) {
      const root2 = enqueueConcurrentRenderForLane(fiber, 2);
      root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2);
    };
    setErrorHandler = function(newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function(newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map, queuedPointerCaptures = new Map, queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "), lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      const root2 = this._internalRoot;
      if (root2 === null)
        throw new Error("Cannot update an unmounted root.");
      let arguments_ = arguments;
      typeof arguments_[1] === "function" ? console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : (isValidContainer(arguments_[1]) ? console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : arguments_[1] !== undefined && console.error("You passed a second argument to root.render(...) but it only accepts one argument."));
      arguments_ = children;
      const current2 = root2.current, lane = requestUpdateLane(current2);
      updateContainerImpl(current2, lane, arguments_, root2, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      let arguments_ = arguments;
      typeof arguments_[0] === "function" && console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      arguments_ = this._internalRoot;
      if (arguments_ !== null) {
        this._internalRoot = null;
        const container = arguments_.containerInfo;
        (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
        updateContainerImpl(arguments_.current, 2, null, arguments_, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        const updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var index_ = 0;index_ < queuedExplicitHydrationTargets.length && updatePriority !== 0 && updatePriority < queuedExplicitHydrationTargets[index_].priority; index_++)
          ;
        queuedExplicitHydrationTargets.splice(index_, 0, target);
        index_ === 0 && attemptExplicitHydrationTarget(target);
      }
    };
    (function() {
      const isomorphicReactPackageVersion = React.version;
      if (isomorphicReactPackageVersion !== "19.1.0")
        throw new Error(`Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (isomorphicReactPackageVersion + `
  - react-dom:  19.1.0
Learn more: https://react.dev/warnings/version-mismatch`));
    })();
    typeof Map === "function" && Map.prototype != undefined && typeof Map.prototype.forEach === "function" && typeof Set === "function" && Set.prototype != undefined && typeof Set.prototype.clear === "function" && typeof Set.prototype.forEach === "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills");
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      const fiber = componentOrElement._reactInternals;
      if (fiber === undefined) {
        if (typeof componentOrElement.render === "function")
          throw new Error("Unable to find node on an unmounted component.");
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + componentOrElement);
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = componentOrElement === null ? null : findCurrentHostFiberImpl(componentOrElement);
      componentOrElement = componentOrElement === null ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    if (!function() {
      const internals = {
        bundleType: 1,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.1.0"
      };
      internals.overrideHookState = overrideHookState;
      internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
      internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
      internals.overrideProps = overrideProperties;
      internals.overridePropsDeletePath = overridePropertiesDeletePath;
      internals.overridePropsRenamePath = overridePropertiesRenamePath;
      internals.scheduleUpdate = scheduleUpdate;
      internals.setErrorHandler = setErrorHandler;
      internals.setSuspenseHandler = setSuspenseHandler;
      internals.scheduleRefresh = scheduleRefresh;
      internals.scheduleRoot = scheduleRoot;
      internals.setRefreshHandler = setRefreshHandler;
      internals.getCurrentFiber = getCurrentFiberForDevelopmentTools;
      internals.getLaneLabelMap = getLaneLabelMap;
      internals.injectProfilingHooks = injectProfilingHooks;
      return injectInternals(internals);
    }() && canUseDOM && window.top === globalThis.self && (-1 < navigator.userAgent.indexOf("Chrome") && !navigator.userAgent.includes("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
      const protocol = globalThis.location.protocol;
      /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (protocol === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    exports.createRoot = function(container, options) {
      if (!isValidContainer(container))
        throw new Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      let isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
      options !== null && options !== undefined && (options.hydrate ? console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof options === "object" && options !== null && options.$$typeof === REACT_ELEMENT_TYPE && console.error(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), options.unstable_strictMode === true && (isStrictMode = true), options.identifierPrefix !== undefined && (identifierPrefix = options.identifierPrefix), options.onUncaughtError !== undefined && (onUncaughtError = options.onUncaughtError), options.onCaughtError !== undefined && (onCaughtError = options.onCaughtError), options.onRecoverableError !== undefined && (onRecoverableError = options.onRecoverableError), options.unstable_transitionCallbacks !== undefined && (transitionCallbacks = options.unstable_transitionCallbacks));
      options = createFiberRoot(container, 1, false, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
      container[internalContainerInstanceKey] = options.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options);
    };
    exports.hydrateRoot = function(container, initialChildren, options) {
      if (!isValidContainer(container))
        throw new Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      initialChildren === undefined && console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      let isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
      options !== null && options !== undefined && (options.unstable_strictMode === true && (isStrictMode = true), options.identifierPrefix !== undefined && (identifierPrefix = options.identifierPrefix), options.onUncaughtError !== undefined && (onUncaughtError = options.onUncaughtError), options.onCaughtError !== undefined && (onCaughtError = options.onCaughtError), options.onRecoverableError !== undefined && (onRecoverableError = options.onRecoverableError), options.unstable_transitionCallbacks !== undefined && (transitionCallbacks = options.unstable_transitionCallbacks), options.formState !== undefined && (formState = options.formState));
      initialChildren = createFiberRoot(container, 1, true, initialChildren, options == undefined ? null : options, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
      initialChildren.context = getContextForSubtree(null);
      options = initialChildren.current;
      isStrictMode = requestUpdateLane(options);
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options, identifierPrefix, isStrictMode);
      options = isStrictMode;
      initialChildren.current.lanes = options;
      markRootUpdated$1(initialChildren, options);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.1.0";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  })();
});

// node_modules/react-dom/client.js
const require_client = __commonJS((exports, module) => {
  const react_dom_client_development = __toESM(require_react_dom_client_development(), 1);
  if (false) {} else {
    module.exports = react_dom_client_development;
  }
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
const require_react_jsx_development_runtime_development = __commonJS((exports) => {
  let React = __toESM(require_react(), 1);
  (function() {
    function getComponentNameFromType(type) {
      if (type == undefined)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE: {
          return "Fragment";
        }
        case REACT_PROFILER_TYPE: {
          return "Profiler";
        }
        case REACT_STRICT_MODE_TYPE: {
          return "StrictMode";
        }
        case REACT_SUSPENSE_TYPE: {
          return "Suspense";
        }
        case REACT_SUSPENSE_LIST_TYPE: {
          return "SuspenseList";
        }
        case REACT_ACTIVITY_TYPE: {
          return "Activity";
        }
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE: {
            return "Portal";
          }
          case REACT_CONTEXT_TYPE: {
            return (type.displayName || "Context") + ".Provider";
          }
          case REACT_CONSUMER_TYPE: {
            return (type._context.displayName || "Context") + ".Consumer";
          }
          case REACT_FORWARD_REF_TYPE: {
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type === "" ? "ForwardRef" : "ForwardRef(" + type + ")");
            return type;
          }
          case REACT_MEMO_TYPE: {
            return innerType = type.displayName || null, innerType === null ? getComponentNameFromType(type.type) || "Memo" : innerType;
          }
          case REACT_LAZY_TYPE: {
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch {}
          }
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        const JSCompiler_temporary_const = JSCompiler_inline_result.error;
        const JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temporary_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        const name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function getOwner() {
      const dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return new Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        const getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropertyWarningGetter(properties, displayName) {
      function warnAboutAccessingKey() {
        specialPropertyKeyWarningShown || (specialPropertyKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(properties, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementReferenceGetterWithDeprecationWarning() {
      let componentName = getComponentNameFromType(this.type);
      didWarnAboutElementReference[componentName] || (didWarnAboutElementReference[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName === undefined ? null : componentName;
    }
    function ReactElement(type, key, self, source, owner, properties, debugStack, debugTask) {
      self = properties.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props: properties,
        _owner: owner
      };
      (self === undefined ? null : self) === null ? Object.defineProperty(type, "ref", { enumerable: false, value: null }) : Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementReferenceGetterWithDeprecationWarning
      });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
      let children = config.children;
      if (children !== undefined)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0;isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        let keys = Object.keys(config).filter(function(k) {
          return k !== "key";
        });
        isStaticChildren = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      maybeKey !== undefined && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (const propertyName in config)
          propertyName !== "key" && (maybeKey[propertyName] = config[propertyName]);
      } else
        maybeKey = config;
      children && defineKeyPropertyWarningGetter(maybeKey, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
      typeof node === "object" && node !== null && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React = {
      "react-stack-bottom-frame": function(callStackForError) {
        return callStackForError();
      }
    };
    let specialPropertyKeyWarningShown;
    var didWarnAboutElementReference = {};
    const unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    const unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
      const trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? new Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  })();
});

// node_modules/react/jsx-dev-runtime.js
const require_jsx_development_runtime = __commonJS((exports, module) => {
  const react_jsx_development_runtime_development = __toESM(require_react_jsx_development_runtime_development(), 1);
  if (false) {} else {
    module.exports = react_jsx_development_runtime_development;
  }
});

// node_modules/abitype/dist/esm/version.js
const version = "1.0.8";

// node_modules/abitype/dist/esm/errors.js
let BaseError;
const init_errors = __esm(() => {
  BaseError = class BaseError extends Error {
    constructor(shortMessage, arguments_ = {}) {
      const details = arguments_.cause instanceof BaseError ? arguments_.cause.details : (arguments_.cause?.message ? arguments_.cause.message : arguments_.details);
      const docsPath = arguments_.cause instanceof BaseError ? arguments_.cause.docsPath || arguments_.docsPath : arguments_.docsPath;
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...arguments_.metaMessages ? [...arguments_.metaMessages, ""] : [],
        ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: abitype@${version}`
      ].join(`
`);
      super(message);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiTypeError"
      });
      if (arguments_.cause)
        this.cause = arguments_.cause;
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = arguments_.metaMessages;
      this.shortMessage = shortMessage;
    }
  };
});

// node_modules/abitype/dist/esm/regex.js
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match?.groups;
}
let bytesRegex, integerRegex, isTupleRegex;
const init_regex = __esm(() => {
  bytesRegex = /^bytes([1-9]|1\d|2\d|3[0-2])?$/;
  integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  isTupleRegex = /^\(.+?\).*?$/;
});

// node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let index_ = 0;index_ < length; index_++) {
      const component = abiParameter.components[index_];
      type += formatAbiParameter(component);
      if (index_ < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
let tupleRegex;
const init_formatAbiParameter = __esm(() => {
  init_regex();
  tupleRegex = /^tuple(?<array>(\[(\d*)])*)$/;
});

// node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
function formatAbiParameters(abiParameters) {
  let parameters = "";
  const length = abiParameters.length;
  for (let index_ = 0;index_ < length; index_++) {
    const abiParameter = abiParameters[index_];
    parameters += formatAbiParameter(abiParameter);
    if (index_ !== length - 1)
      parameters += ", ";
  }
  return parameters;
}
const init_formatAbiParameters = __esm(() => {
  init_formatAbiParameter();
});

// node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  return "receive() external payable";
}
const init_formatAbiItem = __esm(() => {
  init_formatAbiParameters();
});

// node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
function isErrorSignature(signature) {
  return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
  return execTyped(errorSignatureRegex, signature);
}
function isEventSignature(signature) {
  return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
  return execTyped(eventSignatureRegex, signature);
}
function isFunctionSignature(signature) {
  return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
  return execTyped(functionSignatureRegex, signature);
}
function isStructSignature(signature) {
  return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
  return execTyped(structSignatureRegex, signature);
}
function isConstructorSignature(signature) {
  return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
  return execTyped(constructorSignatureRegex, signature);
}
function isFallbackSignature(signature) {
  return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
  return execTyped(fallbackSignatureRegex, signature);
}
function isReceiveSignature(signature) {
  return receiveSignatureRegex.test(signature);
}
let errorSignatureRegex, eventSignatureRegex, functionSignatureRegex, structSignatureRegex, constructorSignatureRegex, fallbackSignatureRegex, receiveSignatureRegex, modifiers, eventModifiers, functionModifiers;
const init_signatures = __esm(() => {
  init_regex();
  errorSignatureRegex = /^error (?<name>[$A-Z_a-z][\w$]*)\((?<parameters>.*?)\)$/;
  eventSignatureRegex = /^event (?<name>[$A-Z_a-z][\w$]*)\((?<parameters>.*?)\)$/;
  functionSignatureRegex = /^function (?<name>[$A-Z_a-z][\w$]*)\((?<parameters>.*?)\)(?: (?<scope>external|public))?(?: (?<stateMutability>pure|view|nonpayable|payable))?(?: returns\s?\((?<returns>.*?)\))?$/;
  structSignatureRegex = /^struct (?<name>[$A-Z_a-z][\w$]*) {(?<properties>.*?)}$/;
  constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable))?$/;
  fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable))?$/;
  receiveSignatureRegex = /^receive\(\) external payable$/;
  modifiers = new Set([
    "memory",
    "indexed",
    "storage",
    "calldata"
  ]);
  eventModifiers = new Set(["indexed"]);
  functionModifiers = new Set([
    "calldata",
    "memory",
    "storage"
  ]);
});

// node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
let InvalidAbiItemError, UnknownTypeError, UnknownSolidityTypeError;
const init_abiItem = __esm(() => {
  init_errors();
  InvalidAbiItemError = class InvalidAbiItemError extends BaseError {
    constructor({ signature }) {
      super("Failed to parse ABI item.", {
        details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
        docsPath: "/api/human#parseabiitem-1"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiItemError"
      });
    }
  };
  UnknownTypeError = class UnknownTypeError extends BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [
          `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownTypeError"
      });
    }
  };
  UnknownSolidityTypeError = class UnknownSolidityTypeError extends BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [`Type "${type}" is not a valid ABI type.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSolidityTypeError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
let InvalidParameterError, SolidityProtectedKeywordError, InvalidModifierError, InvalidFunctionModifierError, InvalidAbiTypeParameterError;
const init_abiParameter = __esm(() => {
  init_errors();
  InvalidParameterError = class InvalidParameterError extends BaseError {
    constructor({ param }) {
      super("Invalid ABI parameter.", {
        details: param
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParameterError"
      });
    }
  };
  SolidityProtectedKeywordError = class SolidityProtectedKeywordError extends BaseError {
    constructor({ param, name }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SolidityProtectedKeywordError"
      });
    }
  };
  InvalidModifierError = class InvalidModifierError extends BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidModifierError"
      });
    }
  };
  InvalidFunctionModifierError = class InvalidFunctionModifierError extends BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
          `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidFunctionModifierError"
      });
    }
  };
  InvalidAbiTypeParameterError = class InvalidAbiTypeParameterError extends BaseError {
    constructor({ abiParameter }) {
      super("Invalid ABI parameter.", {
        details: JSON.stringify(abiParameter, null, 2),
        metaMessages: ["ABI parameter type is invalid."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiTypeParameterError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/signature.js
let InvalidSignatureError, UnknownSignatureError, InvalidStructSignatureError;
const init_signature = __esm(() => {
  init_errors();
  InvalidSignatureError = class InvalidSignatureError extends BaseError {
    constructor({ signature, type }) {
      super(`Invalid ${type} signature.`, {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSignatureError"
      });
    }
  };
  UnknownSignatureError = class UnknownSignatureError extends BaseError {
    constructor({ signature }) {
      super("Unknown signature.", {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSignatureError"
      });
    }
  };
  InvalidStructSignatureError = class InvalidStructSignatureError extends BaseError {
    constructor({ signature }) {
      super("Invalid struct signature.", {
        details: signature,
        metaMessages: ["No properties exist."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidStructSignatureError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/struct.js
let CircularReferenceError;
const init_struct = __esm(() => {
  init_errors();
  CircularReferenceError = class CircularReferenceError extends BaseError {
    constructor({ type }) {
      super("Circular reference detected.", {
        metaMessages: [`Struct "${type}" is a circular reference.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CircularReferenceError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
let InvalidParenthesisError;
const init_splitParameters = __esm(() => {
  init_errors();
  InvalidParenthesisError = class InvalidParenthesisError extends BaseError {
    constructor({ current, depth }) {
      super("Unbalanced parentheses.", {
        metaMessages: [
          `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
        ],
        details: `Depth "${depth}"`
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParenthesisError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/runtime/cache.js
function getParameterCacheKey(parameter, type, structs) {
  let structKey = "";
  if (structs)
    for (const struct of Object.entries(structs)) {
      if (!struct)
        continue;
      let propertyKey = "";
      for (const property of struct[1]) {
        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
      }
      structKey += `(${struct[0]}{${propertyKey}})`;
    }
  if (type)
    return `${type}:${parameter}${structKey}`;
  return parameter;
}
let parameterCache;
const init_cache = __esm(() => {
  parameterCache = new Map([
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: true }
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: true }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ]
  ]);
});

// node_modules/abitype/dist/esm/human-readable/runtime/utils.js
function parseSignature(signature, structs = {}) {
  if (isFunctionSignature(signature))
    return parseFunctionSignature(signature, structs);
  if (isEventSignature(signature))
    return parseEventSignature(signature, structs);
  if (isErrorSignature(signature))
    return parseErrorSignature(signature, structs);
  if (isConstructorSignature(signature))
    return parseConstructorSignature(signature, structs);
  if (isFallbackSignature(signature))
    return parseFallbackSignature(signature);
  if (isReceiveSignature(signature))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature });
}
function parseFunctionSignature(signature, structs = {}) {
  const match = execFunctionSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "function" });
  const inputParameters = splitParameters(match.parameters);
  const inputs = [];
  const inputLength = inputParameters.length;
  for (let index_ = 0;index_ < inputLength; index_++) {
    inputs.push(parseAbiParameter(inputParameters[index_], {
      modifiers: functionModifiers,
      structs,
      type: "function"
    }));
  }
  const outputs = [];
  if (match.returns) {
    const outputParameters = splitParameters(match.returns);
    const outputLength = outputParameters.length;
    for (let index_ = 0;index_ < outputLength; index_++) {
      outputs.push(parseAbiParameter(outputParameters[index_], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
  }
  return {
    name: match.name,
    type: "function",
    stateMutability: match.stateMutability ?? "nonpayable",
    inputs,
    outputs
  };
}
function parseEventSignature(signature, structs = {}) {
  const match = execEventSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "event" });
  const parameters = splitParameters(match.parameters);
  const abiParameters = [];
  const length = parameters.length;
  for (let index_ = 0;index_ < length; index_++)
    abiParameters.push(parseAbiParameter(parameters[index_], {
      modifiers: eventModifiers,
      structs,
      type: "event"
    }));
  return { name: match.name, type: "event", inputs: abiParameters };
}
function parseErrorSignature(signature, structs = {}) {
  const match = execErrorSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "error" });
  const parameters = splitParameters(match.parameters);
  const abiParameters = [];
  const length = parameters.length;
  for (let index_ = 0;index_ < length; index_++)
    abiParameters.push(parseAbiParameter(parameters[index_], { structs, type: "error" }));
  return { name: match.name, type: "error", inputs: abiParameters };
}
function parseConstructorSignature(signature, structs = {}) {
  const match = execConstructorSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "constructor" });
  const parameters = splitParameters(match.parameters);
  const abiParameters = [];
  const length = parameters.length;
  for (let index_ = 0;index_ < length; index_++)
    abiParameters.push(parseAbiParameter(parameters[index_], { structs, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: match.stateMutability ?? "nonpayable",
    inputs: abiParameters
  };
}
function parseFallbackSignature(signature) {
  const match = execFallbackSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: match.stateMutability ?? "nonpayable"
  };
}
function parseAbiParameter(parameter, options) {
  const parameterCacheKey = getParameterCacheKey(parameter, options?.type, options?.structs);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(parameter);
  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, parameter);
  if (!match)
    throw new InvalidParameterError({ param: parameter });
  if (match.name && isSolidityKeyword(match.name))
    throw new SolidityProtectedKeywordError({ param: parameter, name: match.name });
  const name = match.name ? { name: match.name } : {};
  const indexed = match.modifier === "indexed" ? { indexed: true } : {};
  const structs = options?.structs ?? {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const parameters = splitParameters(match.type);
    const components_ = [];
    const length = parameters.length;
    for (let index_ = 0;index_ < length; index_++) {
      components_.push(parseAbiParameter(parameters[index_], { structs }));
    }
    components = { components: components_ };
  } else if (match.type in structs) {
    type = "tuple";
    components = { components: structs[match.type] };
  } else if (dynamicIntegerRegex.test(match.type)) {
    type = `${match.type}256`;
  } else {
    type = match.type;
    if (!(options?.type === "struct") && !isSolidityType(type))
      throw new UnknownSolidityTypeError({ type });
  }
  if (match.modifier) {
    if (!options?.modifiers?.has?.(match.modifier))
      throw new InvalidModifierError({
        param: parameter,
        type: options?.type,
        modifier: match.modifier
      });
    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, Boolean(match.array)))
      throw new InvalidFunctionModifierError({
        param: parameter,
        type: options?.type,
        modifier: match.modifier
      });
  }
  const abiParameter = {
    type: `${type}${match.array ?? ""}`,
    ...name,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(parameters, result = [], current = "", depth = 0) {
  const length = parameters.trim().length;
  for (let index_ = 0;index_ < length; index_++) {
    const char = parameters[index_];
    const tail = parameters.slice(index_ + 1);
    switch (char) {
      case ",": {
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      }
      case "(": {
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      }
      case ")": {
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      }
      default: {
        return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
  }
  if (current === "")
    return result;
  if (depth !== 0)
    throw new InvalidParenthesisError({ current, depth });
  result.push(current.trim());
  return result;
}
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
}
function isSolidityKeyword(name) {
  return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
}
function isValidDataLocation(type, isArray) {
  return isArray || type === "bytes" || type === "string" || type === "tuple";
}
let abiParameterWithoutTupleRegex, abiParameterWithTupleRegex, dynamicIntegerRegex, protectedKeywordsRegex;
const init_utilities = __esm(() => {
  init_regex();
  init_abiItem();
  init_abiParameter();
  init_signature();
  init_splitParameters();
  init_cache();
  init_signatures();
  abiParameterWithoutTupleRegex = /^(?<type>[$A-Z_a-z][\w$]*)(?<array>(?:\[\d*?])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage))?(?:\s(?<name>[$A-Z_a-z][\w$]*))?$/;
  abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage))?(?:\s(?<name>[$A-Z_a-z][\w$]*))?$/;
  dynamicIntegerRegex = /^u?int$/;
  protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
});

// node_modules/abitype/dist/esm/human-readable/runtime/structs.js
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let index_ = 0;index_ < signaturesLength; index_++) {
    const signature = signatures[index_];
    if (!isStructSignature(signature))
      continue;
    const match = execStructSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "struct" });
    const properties = match.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k = 0;k < propertiesLength; k++) {
      const property = properties[k];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (components.length === 0)
      throw new InvalidStructSignatureError({ signature });
    shallowStructs[match.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let index_ = 0;index_ < entriesLength; index_++) {
    const [name, parameters] = entries[index_];
    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
function resolveStructs(abiParameters, structs, ancestors = new Set) {
  const components = [];
  const length = abiParameters.length;
  for (let index_ = 0;index_ < length; index_++) {
    const abiParameter = abiParameters[index_];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
      if (!match?.type)
        throw new InvalidAbiTypeParameterError({ abiParameter });
      const { array, type } = match;
      if (type in structs) {
        if (ancestors.has(type))
          throw new CircularReferenceError({ type });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))
        });
      } else {
        if (isSolidityType(type))
          components.push(abiParameter);
        else
          throw new UnknownTypeError({ type });
      }
    }
  }
  return components;
}
let typeWithoutTupleRegex;
const init_structs = __esm(() => {
  init_regex();
  init_abiItem();
  init_abiParameter();
  init_signature();
  init_struct();
  init_signatures();
  init_utilities();
  typeWithoutTupleRegex = /^(?<type>[$A-Z_a-z][\w$]*)(?<array>(?:\[\d*?])+?)?$/;
});

// node_modules/abitype/dist/esm/human-readable/parseAbi.js
function parseAbi(signatures) {
  const structs = parseStructs(signatures);
  const abi = [];
  const length = signatures.length;
  for (let index_ = 0;index_ < length; index_++) {
    const signature = signatures[index_];
    if (isStructSignature(signature))
      continue;
    abi.push(parseSignature(signature, structs));
  }
  return abi;
}
const init_parseAbi = __esm(() => {
  init_signatures();
  init_structs();
  init_utilities();
});

// node_modules/abitype/dist/esm/human-readable/parseAbiItem.js
function parseAbiItem(signature) {
  let abiItem;
  if (typeof signature === "string")
    abiItem = parseSignature(signature);
  else {
    const structs = parseStructs(signature);
    const length = signature.length;
    for (let index_ = 0;index_ < length; index_++) {
      const signature_ = signature[index_];
      if (isStructSignature(signature_))
        continue;
      abiItem = parseSignature(signature_, structs);
      break;
    }
  }
  if (!abiItem)
    throw new InvalidAbiItemError({ signature });
  return abiItem;
}
const init_parseAbiItem = __esm(() => {
  init_abiItem();
  init_signatures();
  init_structs();
  init_utilities();
});

// node_modules/abitype/dist/esm/exports/index.js
const init_exports = __esm(() => {
  init_formatAbiItem();
  init_parseAbi();
  init_parseAbiItem();
});

// node_modules/viem/_esm/utils/abi/formatAbiItem.js
function formatAbiItem2(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParameters_(abiItem.inputs, { includeName })})`;
}
function formatAbiParameters_(parameters, { includeName = false } = {}) {
  if (!parameters)
    return "";
  return parameters.map((parameter) => formatAbiParameter_(parameter, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParameter_(parameter, { includeName }) {
  if (parameter.type.startsWith("tuple")) {
    return `(${formatAbiParameters_(parameter.components, { includeName })})${parameter.type.slice("tuple".length)}`;
  }
  return parameter.type + (includeName && parameter.name ? ` ${parameter.name}` : "");
}
const init_formatAbiItem2 = __esm(() => {
  init_abi();
});

// node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[\dA-Fa-f]*$/.test(value) : value.startsWith("0x");
}

// node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
const init_size = () => {};

// node_modules/viem/_esm/errors/version.js
const version2 = "2.30.0";

// node_modules/viem/_esm/errors/base.js
function walk(error, function_) {
  if (function_?.(error))
    return error;
  if (error && typeof error === "object" && "cause" in error && error.cause !== undefined)
    return walk(error.cause, function_);
  return function_ ? null : error;
}
let errorConfig, BaseError2;
const init_base = __esm(() => {
  errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : undefined,
    version: `viem@${version2}`
  };
  BaseError2 = class BaseError2 extends Error {
    constructor(shortMessage, arguments_ = {}) {
      const details = (() => {
        if (arguments_.cause instanceof BaseError2)
          return arguments_.cause.details;
        if (arguments_.cause?.message)
          return arguments_.cause.message;
        return arguments_.details;
      })();
      const docsPath = (() => {
        if (arguments_.cause instanceof BaseError2)
          return arguments_.cause.docsPath || arguments_.docsPath;
        return arguments_.docsPath;
      })();
      const docsUrl = errorConfig.getDocsUrl?.({ ...arguments_, docsPath });
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...arguments_.metaMessages ? [...arguments_.metaMessages, ""] : [],
        ...docsUrl ? [`Docs: ${docsUrl}`] : [],
        ...details ? [`Details: ${details}`] : [],
        ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
      ].join(`
`);
      super(message, arguments_.cause ? { cause: arguments_.cause } : undefined);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseError"
      });
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = arguments_.metaMessages;
      this.name = arguments_.name ?? this.name;
      this.shortMessage = shortMessage;
      this.version = version2;
    }
    walk(function_) {
      return walk(this, function_);
    }
  };
});

// node_modules/viem/_esm/errors/abi.js
let AbiConstructorNotFoundError, AbiConstructorParametersNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorInputsNotFoundError, AbiErrorNotFoundError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiFunctionSignatureNotFoundError, AbiItemAmbiguityError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
var init_abi = __esm(() => {
  init_formatAbiItem2();
  init_size();
  init_base();
  AbiConstructorNotFoundError = class AbiConstructorNotFoundError extends BaseError2 {
    constructor({ docsPath }) {
      super([
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiConstructorNotFoundError"
      });
    }
  };
  AbiConstructorParametersNotFoundError = class AbiConstructorParametersNotFoundError_ extends BaseError2 {
    constructor({ docsPath }) {
      super([
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
      ].join(`
`), {
        docsPath,
        name: "AbiConstructorParamsNotFoundError"
      });
    }
  };
  AbiDecodingDataSizeTooSmallError = class AbiDecodingDataSizeTooSmallError extends BaseError2 {
    constructor({ data, params, size: size2 }) {
      super([`Data size of ${size2} bytes is too small for given parameters.`].join(`
`), {
        metaMessages: [
          `Params: (${formatAbiParameters_(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ],
        name: "AbiDecodingDataSizeTooSmallError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  AbiDecodingZeroDataError = class AbiDecodingZeroDataError extends BaseError2 {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.', {
        name: "AbiDecodingZeroDataError"
      });
    }
  };
  AbiEncodingArrayLengthMismatchError = class AbiEncodingArrayLengthMismatchError extends BaseError2 {
    constructor({ expectedLength, givenLength, type }) {
      super([
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
    }
  };
  AbiEncodingBytesSizeMismatchError = class AbiEncodingBytesSizeMismatchError extends BaseError2 {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
    }
  };
  AbiEncodingLengthMismatchError = class AbiEncodingLengthMismatchError extends BaseError2 {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
    }
  };
  AbiErrorInputsNotFoundError = class AbiErrorInputsNotFoundError extends BaseError2 {
    constructor(errorName, { docsPath }) {
      super([
        `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
        "Cannot encode error result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the inputs exist on it."
      ].join(`
`), {
        docsPath,
        name: "AbiErrorInputsNotFoundError"
      });
    }
  };
  AbiErrorNotFoundError = class AbiErrorNotFoundError extends BaseError2 {
    constructor(errorName, { docsPath } = {}) {
      super([
        `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiErrorNotFoundError"
      });
    }
  };
  AbiErrorSignatureNotFoundError = class AbiErrorSignatureNotFoundError extends BaseError2 {
    constructor(signature, { docsPath }) {
      super([
        `Encoded error signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join(`
`), {
        docsPath,
        name: "AbiErrorSignatureNotFoundError"
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.signature = signature;
    }
  };
  AbiEventSignatureEmptyTopicsError = class AbiEventSignatureEmptyTopicsError extends BaseError2 {
    constructor({ docsPath }) {
      super("Cannot extract event signature from empty topics.", {
        docsPath,
        name: "AbiEventSignatureEmptyTopicsError"
      });
    }
  };
  AbiEventSignatureNotFoundError = class AbiEventSignatureNotFoundError extends BaseError2 {
    constructor(signature, { docsPath }) {
      super([
        `Encoded event signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join(`
`), {
        docsPath,
        name: "AbiEventSignatureNotFoundError"
      });
    }
  };
  AbiEventNotFoundError = class AbiEventNotFoundError extends BaseError2 {
    constructor(eventName, { docsPath } = {}) {
      super([
        `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiEventNotFoundError"
      });
    }
  };
  AbiFunctionNotFoundError = class AbiFunctionNotFoundError extends BaseError2 {
    constructor(functionName, { docsPath } = {}) {
      super([
        `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionNotFoundError"
      });
    }
  };
  AbiFunctionOutputsNotFoundError = class AbiFunctionOutputsNotFoundError extends BaseError2 {
    constructor(functionName, { docsPath }) {
      super([
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionOutputsNotFoundError"
      });
    }
  };
  AbiFunctionSignatureNotFoundError = class AbiFunctionSignatureNotFoundError extends BaseError2 {
    constructor(signature, { docsPath }) {
      super([
        `Encoded function signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionSignatureNotFoundError"
      });
    }
  };
  AbiItemAmbiguityError = class AbiItemAmbiguityError extends BaseError2 {
    constructor(x, y) {
      super("Found ambiguous types in overloaded ABI items.", {
        metaMessages: [
          `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
          `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
          "",
          "These types encode differently and cannot be distinguished at runtime.",
          "Remove one of the ambiguous items in the ABI."
        ],
        name: "AbiItemAmbiguityError"
      });
    }
  };
  BytesSizeMismatchError = class BytesSizeMismatchError extends BaseError2 {
    constructor({ expectedSize, givenSize }) {
      super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
        name: "BytesSizeMismatchError"
      });
    }
  };
  DecodeLogDataMismatch = class DecodeLogDataMismatch extends BaseError2 {
    constructor({ abiItem, data, params, size: size2 }) {
      super([
        `Data size of ${size2} bytes is too small for non-indexed event parameters.`
      ].join(`
`), {
        metaMessages: [
          `Params: (${formatAbiParameters_(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ],
        name: "DecodeLogDataMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  DecodeLogTopicsMismatch = class DecodeLogTopicsMismatch extends BaseError2 {
    constructor({ abiItem, param }) {
      super([
        `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem2(abiItem, { includeName: true })}".`
      ].join(`
`), { name: "DecodeLogTopicsMismatch" });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
    }
  };
  InvalidAbiEncodingTypeError = class InvalidAbiEncodingTypeError extends BaseError2 {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join(`
`), { docsPath, name: "InvalidAbiEncodingType" });
    }
  };
  InvalidAbiDecodingTypeError = class InvalidAbiDecodingTypeError extends BaseError2 {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid decoding type.`,
        "Please provide a valid ABI type."
      ].join(`
`), { docsPath, name: "InvalidAbiDecodingType" });
    }
  };
  InvalidArrayError = class InvalidArrayError extends BaseError2 {
    constructor(value) {
      super([`Value "${value}" is not a valid array.`].join(`
`), {
        name: "InvalidArrayError"
      });
    }
  };
  InvalidDefinitionTypeError = class InvalidDefinitionTypeError extends BaseError2 {
    constructor(type) {
      super([
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join(`
`), { name: "InvalidDefinitionTypeError" });
    }
  };
});

// node_modules/viem/_esm/errors/data.js
let SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError, InvalidBytesLengthError;
const init_data = __esm(() => {
  init_base();
  SliceOffsetOutOfBoundsError = class SliceOffsetOutOfBoundsError extends BaseError2 {
    constructor({ offset, position, size: size2 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`, { name: "SliceOffsetOutOfBoundsError" });
    }
  };
  SizeExceedsPaddingSizeError = class SizeExceedsPaddingSizeError extends BaseError2 {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
    }
  };
  InvalidBytesLengthError = class InvalidBytesLengthError extends BaseError2 {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`, { name: "InvalidBytesLengthError" });
    }
  };
});

// node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes;
  if (bytes.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let index_ = 0;index_ < size2; index_++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? index_ : size2 - index_ - 1] = bytes[padEnd ? index_ : bytes.length - index_ - 1];
  }
  return paddedBytes;
}
const init_pad = __esm(() => {
  init_data();
});

// node_modules/viem/_esm/errors/encoding.js
let IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, SizeOverflowError;
const init_encoding = __esm(() => {
  init_base();
  IntegerOutOfRangeError = class IntegerOutOfRangeError extends BaseError2 {
    constructor({ max, min, signed, size: size2, value }) {
      super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
    }
  };
  InvalidBytesBooleanError = class InvalidBytesBooleanError extends BaseError2 {
    constructor(bytes) {
      super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
        name: "InvalidBytesBooleanError"
      });
    }
  };
  InvalidHexBooleanError = class InvalidHexBooleanError extends BaseError2 {
    constructor(hex) {
      super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: "InvalidHexBooleanError" });
    }
  };
  SizeOverflowError = class SizeOverflowError extends BaseError2 {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
    }
  };
});

// node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let index_ = 0;index_ < data.length - 1; index_++) {
    if (data[dir === "left" ? index_ : data.length - index_ - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

// node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size2 }) {
  if (size(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, options = {}) {
  const { signed } = options;
  if (options.size > 0)
    assertSize(hex, { size: options.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, options = {}) {
  let hex = hex_;
  if (options.size > 0) {
    assertSize(hex, { size: options.size });
    hex = trim(hex);
  }
  if (trim(hex) === "0x00")
    return false;
  if (trim(hex) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber(hex, options = {}) {
  return Number(hexToBigInt(hex, options));
}
const init_fromHex = __esm(() => {
  init_encoding();
  init_size();
});

// node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, options = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, options);
  if (typeof value === "string") {
    return stringToHex(value, options);
  }
  if (typeof value === "boolean")
    return boolToHex(value, options);
  return bytesToHex(value, options);
}
function boolToHex(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize(hex, { size: options.size });
    return pad(hex, { size: options.size });
  }
  return hex;
}
function bytesToHex(value, options = {}) {
  let string = "";
  for (const element of value) {
    string += hexes[element];
  }
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize(hex, { size: options.size });
    return pad(hex, { dir: "right", size: options.size });
  }
  return hex;
}
function numberToHex(value_, options = {}) {
  const { signed, size: size2 } = options;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    maxValue = signed ? (1n << BigInt(size2) * 8n - 1n) - 1n : 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
function stringToHex(value_, options = {}) {
  const value = encoder.encode(value_);
  return bytesToHex(value, options);
}
let hexes, encoder;
const init_toHex = __esm(() => {
  init_encoding();
  init_pad();
  init_fromHex();
  hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, index_) => index_.toString(16).padStart(2, "0"));
  encoder = /* @__PURE__ */ new TextEncoder;
});

// node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes(value, options = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, options);
  if (typeof value === "boolean")
    return boolToBytes(value, options);
  if (isHex(value))
    return hexToBytes(value, options);
  return stringToBytes(value, options);
}
function boolToBytes(value, options = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof options.size === "number") {
    assertSize(bytes, { size: options.size });
    return pad(bytes, { size: options.size });
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return;
}
function hexToBytes(hex_, options = {}) {
  let hex = hex_;
  if (options.size > 0) {
    assertSize(hex, { size: options.size });
    hex = pad(hex, { dir: "right", size: options.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, index_ = 0;index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(index_++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(index_++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError2(`Invalid byte sequence ("${hexString[index_ - 2]}${hexString[index_ - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, options) {
  const hex = numberToHex(value, options);
  return hexToBytes(hex);
}
function stringToBytes(value, options = {}) {
  const bytes = encoder2.encode(value);
  if (typeof options.size === "number") {
    assertSize(bytes, { size: options.size });
    return pad(bytes, { dir: "right", size: options.size });
  }
  return bytes;
}
let encoder2, charCodeMap;
const init_toBytes = __esm(() => {
  init_base();
  init_pad();
  init_fromHex();
  init_toHex();
  encoder2 = /* @__PURE__ */ new TextEncoder;
  charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
});

// node_modules/@noble/hashes/esm/_assert.js
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
const init__assert = () => {};

// node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const Ah = new Uint32Array(lst.length);
  const Al = new Uint32Array(lst.length);
  for (const [index_, element] of lst.entries()) {
    const { h, l } = fromBig(element, le);
    [Ah[index_], Al[index_]] = [h, l];
  }
  return [Ah, Al];
}
let U32_MASK64, _32n, rotlSH = (h, l, s) => h << s | l >>> 32 - s, rotlSL = (h, l, s) => l << s | h >>> 32 - s, rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s, rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
const init__u64 = __esm(() => {
  U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  _32n = /* @__PURE__ */ BigInt(32);
});

// node_modules/@noble/hashes/esm/crypto.js
let crypto2;
const init_crypto = __esm(() => {
  crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
});

// node_modules/@noble/hashes/esm/utils.js
function u32(array) {
  return new Uint32Array(array.buffer, array.byteOffset, Math.floor(array.byteLength / 4));
}
function createView(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function byteSwap(word) {
  return word << 24 & 4_278_190_080 | word << 8 & 16_711_680 | word >>> 8 & 65_280 | word >>> 24 & 255;
}
function byteSwap32(array) {
  for (let index_ = 0;index_ < array.length; index_++) {
    array[index_] = byteSwap(array[index_]);
  }
}
function utf8ToBytes(string_) {
  if (typeof string_ !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof string_);
  return new Uint8Array(new TextEncoder().encode(string_));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (const a of arrays) {
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let index_ = 0, pad2 = 0;index_ < arrays.length; index_++) {
    const a = arrays[index_];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}

class Hash {
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (message) => hashCons().update(toBytes2(message)).digest();
  const temporary = hashCons();
  hashC.outputLen = temporary.outputLen;
  hashC.blockLen = temporary.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOptions(hashCons) {
  const hashC = (message, options) => hashCons(options).update(toBytes2(message)).digest();
  const temporary = hashCons({});
  hashC.outputLen = temporary.outputLen;
  hashC.blockLen = temporary.blockLen;
  hashC.create = (options) => hashCons(options);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
let isLE, hasHexBuiltin;
const init_utilities2 = __esm(() => {
  init_crypto();
  init__assert();
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287_454_020]).buffer)[0] === 68)();
  hasHexBuiltin = typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function";
});

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const index1 = (x + 8) % 10;
      const index0 = (x + 2) % 10;
      const B0 = B[index0];
      const B1 = B[index0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[index1];
      const Tl = rotlL(B0, B1, 1) ^ B[index1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let currentH = s[2];
    let currentL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(currentH, currentL, shift);
      const Tl = rotlL(currentH, currentL, shift);
      const PI = SHA3_PI[t];
      currentH = s[PI];
      currentL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s), rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s), Keccak, gen = (suffix, blockLength, outputLength) => wrapConstructor(() => new Keccak(blockLength, suffix, outputLength)), sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake = (suffix, blockLength, outputLength) => wrapXOFConstructorWithOptions((options = {}) => new Keccak(blockLength, suffix, options.dkLen === undefined ? outputLength : options.dkLen, true)), shake128, shake256;
const init_sha3 = __esm(() => {
  init__assert();
  init__u64();
  init_utilities2();
  SHA3_PI = [];
  SHA3_ROTL = [];
  _SHA3_IOTA = [];
  _0n = /* @__PURE__ */ BigInt(0);
  _1n = /* @__PURE__ */ BigInt(1);
  _2n = /* @__PURE__ */ BigInt(2);
  _7n = /* @__PURE__ */ BigInt(7);
  _256n = /* @__PURE__ */ BigInt(256);
  _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let index_ = 0;index_ < 7; index_++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(index_)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  Keccak = class Keccak extends Hash {
    constructor(blockLength, suffix, outputLength, enableXOF = false, rounds = 24) {
      super();
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      this.enableXOF = false;
      this.blockLen = blockLength;
      this.suffix = suffix;
      this.outputLen = outputLength;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      anumber(outputLength);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      if (!isLE)
        byteSwap32(this.state32);
      keccakP(this.state32, this.rounds);
      if (!isLE)
        byteSwap32(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      aexists(this);
      const { blockLen, state } = this;
      data = toBytes2(data);
      const length = data.length;
      for (let pos = 0;pos < length; ) {
        const take = Math.min(blockLen - this.pos, length - pos);
        for (let index_ = 0;index_ < take; index_++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      aexists(this, false);
      abytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, length = out.length;pos < length; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, length - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      anumber(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      aoutput(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
});

// node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}
const init_keccak256 = __esm(() => {
  init_sha3();
  init_toBytes();
  init_toHex();
});

// node_modules/viem/_esm/utils/hash/hashSignature.js
function hashSignature(sig) {
  return hash(sig);
}
var hash = (value) => keccak256(toBytes(value));
const init_hashSignature = __esm(() => {
  init_toBytes();
  init_keccak256();
});

// node_modules/viem/_esm/utils/hash/normalizeSignature.js
function normalizeSignature(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let index_ = 0;index_ < signature.length; index_++) {
    const char = signature[index_];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[index_ - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError2("Unable to normalize signature.");
  return result;
}
const init_normalizeSignature = __esm(() => {
  init_base();
});

// node_modules/viem/_esm/utils/hash/toSignature.js
const toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem(def);
  })();
  return normalizeSignature(def_);
};
const init_toSignature = __esm(() => {
  init_exports();
  init_normalizeSignature();
});

// node_modules/viem/_esm/utils/hash/toSignatureHash.js
function toSignatureHash(function_) {
  return hashSignature(toSignature(function_));
}
const init_toSignatureHash = __esm(() => {
  init_hashSignature();
  init_toSignature();
});

// node_modules/viem/_esm/utils/hash/toEventSelector.js
let toEventSelector;
const init_toEventSelector = __esm(() => {
  init_toSignatureHash();
  toEventSelector = toSignatureHash;
});

// node_modules/viem/_esm/errors/address.js
let InvalidAddressError;
const init_address = __esm(() => {
  init_base();
  InvalidAddressError = class InvalidAddressError extends BaseError2 {
    constructor({ address }) {
      super(`Address "${address}" is invalid.`, {
        metaMessages: [
          "- Address must be a hex value of 20 bytes (40 hex characters).",
          "- Address must match its checksum counterpart."
        ],
        name: "InvalidAddressError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/lru.js
let LruMap;
const init_lru = __esm(() => {
  LruMap = class LruMap extends Map {
    constructor(size2) {
      super();
      Object.defineProperty(this, "maxSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.maxSize = size2;
    }
    get(key) {
      const value = super.get(key);
      if (super.has(key) && value !== undefined) {
        this.delete(key);
        super.set(key, value);
      }
      return value;
    }
    set(key, value) {
      super.set(key, value);
      if (this.maxSize && this.size > this.maxSize) {
        const firstKey = this.keys().next().value;
        if (firstKey)
          this.delete(firstKey);
      }
      return this;
    }
  };
});

// node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.slice(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.slice(`${chainId}0x`.length) : hexAddress).split("");
  for (let index_ = 0;index_ < 40; index_ += 2) {
    if (hash2[index_ >> 1] >> 4 >= 8 && address[index_]) {
      address[index_] = address[index_].toUpperCase();
    }
    if ((hash2[index_ >> 1] & 15) >= 8 && address[index_ + 1]) {
      address[index_ + 1] = address[index_ + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function getAddress(address, chainId) {
  if (!isAddress(address, { strict: false }))
    throw new InvalidAddressError({ address });
  return checksumAddress(address, chainId);
}
let checksumAddressCache;
const init_getAddress = __esm(() => {
  init_address();
  init_toBytes();
  init_keccak256();
  init_lru();
  init_isAddress();
  checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
});

// node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address, options) {
  const { strict = true } = options ?? {};
  const cacheKey = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey))
    return isAddressCache.get(cacheKey);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey, result);
  return result;
}
let addressRegex, isAddressCache;
var init_isAddress = __esm(() => {
  init_lru();
  init_getAddress();
  addressRegex = /^0x[\dA-Fa-f]{40}$/;
  isAddressCache = /* @__PURE__ */ new LruMap(8192);
});

// node_modules/viem/_esm/utils/data/concat.js
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes2(values);
}
function concatBytes2(values) {
  let length = 0;
  for (const array of values) {
    length += array.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const array of values) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((accumulator, x) => accumulator + x.replace("0x", ""), "")}`;
}

// node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
const init_slice = __esm(() => {
  init_data();
  init_size();
});

// node_modules/viem/_esm/utils/regex.js
let bytesRegex2, integerRegex2;
const init_regex2 = __esm(() => {
  bytesRegex2 = /^bytes([1-9]|1\d|2\d|3[0-2])?$/;
  integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
});

// node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters(parameters, values) {
  if (parameters.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: parameters.length,
      givenLength: values.length
    });
  const preparedParameters = prepareParameters_({
    params: parameters,
    values
  });
  const data = encodeParameters(preparedParameters);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParameters_({ params, values }) {
  const preparedParameters = [];
  for (const [index_, parameter] of params.entries()) {
    preparedParameters.push(prepareParameter_({ param: parameter, value: values[index_] }));
  }
  return preparedParameters;
}
function prepareParameter_({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    const [, , size2 = "256"] = integerRegex2.exec(param.type) ?? [];
    return encodeNumber(value, {
      signed,
      size: Number(size2)
    });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParameters(preparedParameters) {
  let staticSize = 0;
  for (const { dynamic, encoded } of preparedParameters) {
    staticSize += dynamic ? 32 : size(encoded);
  }
  const staticParameters = [];
  const dynamicParameters = [];
  let dynamicSize = 0;
  for (const { dynamic, encoded } of preparedParameters) {
    if (dynamic) {
      staticParameters.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParameters.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParameters.push(encoded);
    }
  }
  return concat([...staticParameters, ...dynamicParameters]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParameters = [];
  for (const element of value) {
    const preparedParameter = prepareParameter_({ param, value: element });
    if (preparedParameter.dynamic)
      dynamicChild = true;
    preparedParameters.push(preparedParameter);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParameters(preparedParameters);
    if (dynamic) {
      const length2 = numberToHex(preparedParameters.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParameters.length > 0 ? concat([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParameters.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, parameterSize] = param.type.split("bytes");
  const bytesSize = size(value);
  if (!parameterSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(parameterSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(parameterSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  if (typeof value !== "boolean")
    throw new BaseError2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed, size: size2 = 256 }) {
  if (typeof size2 === "number") {
    const max = 2n ** (BigInt(size2) - (signed ? 1n : 0n)) - 1n;
    const min = signed ? -max - 1n : 0n;
    if (value > max || value < min)
      throw new IntegerOutOfRangeError({
        max: max.toString(),
        min: min.toString(),
        signed,
        size: size2 / 8,
        value: value.toString()
      });
  }
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue) / 32);
  const parts = [];
  for (let index_ = 0;index_ < partsLength; index_++) {
    parts.push(padHex(slice(hexValue, index_ * 32, (index_ + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(size(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParameters = [];
  for (let index_ = 0;index_ < param.components.length; index_++) {
    const parameter_ = param.components[index_];
    const index = Array.isArray(value) ? index_ : parameter_.name;
    const preparedParameter = prepareParameter_({
      param: parameter_,
      value: value[index]
    });
    preparedParameters.push(preparedParameter);
    if (preparedParameter.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParameters(preparedParameters) : concat(preparedParameters.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}
const init_encodeAbiParameters = __esm(() => {
  init_abi();
  init_address();
  init_base();
  init_encoding();
  init_isAddress();
  init_pad();
  init_size();
  init_slice();
  init_toHex();
  init_regex2();
});

// node_modules/viem/_esm/utils/hash/toFunctionSelector.js
const toFunctionSelector = (function_) => slice(toSignatureHash(function_), 0, 4);
const init_toFunctionSelector = __esm(() => {
  init_slice();
  init_toSignatureHash();
});

// node_modules/viem/_esm/utils/abi/getAbiItem.js
function getAbiItem(parameters) {
  const { abi, args: arguments_ = [], name } = parameters;
  const isSelector = isHex(name, { strict: false });
  const abiItems = abi.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!arguments_ || arguments_.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== arguments_.length)
      continue;
    const matched = arguments_.every((argument, index) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
      if (!abiParameter)
        return false;
      return isArgumentOfType(argument, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, arguments_);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgumentOfType(argument, abiParameter) {
  const argumentType = typeof argument;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address": {
      return isAddress(argument, { strict: false });
    }
    case "bool": {
      return argumentType === "boolean";
    }
    case "function": {
      return argumentType === "string";
    }
    case "string": {
      return argumentType === "string";
    }
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index) => {
          return isArgumentOfType(Object.values(argument)[index], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argumentType === "number" || argumentType === "bigint";
      if (/^bytes([1-9]|1\d|2\d|3[0-2])?$/.test(abiParameterType))
        return argumentType === "string" || argument instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[\d*])+$/.test(abiParameterType)) {
        return Array.isArray(argument) && argument.every((x) => isArgumentOfType(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[\d*])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, arguments_) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, arguments_[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return isAddress(arguments_[parameterIndex], { strict: false });
      if (types.includes("address") && types.includes("bytes"))
        return isAddress(arguments_[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}
const init_getAbiItem = __esm(() => {
  init_abi();
  init_isAddress();
  init_toEventSelector();
  init_toFunctionSelector();
});

// node_modules/viem/_esm/accounts/utils/parseAccount.js
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}

// node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js
function prepareEncodeFunctionData(parameters) {
  const { abi, args, functionName } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath2 });
  return {
    abi: [abiItem],
    functionName: toFunctionSelector(formatAbiItem2(abiItem))
  };
}
var docsPath2 = "/docs/contract/encodeFunctionData";
const init_prepareEncodeFunctionData = __esm(() => {
  init_abi();
  init_toFunctionSelector();
  init_formatAbiItem2();
  init_getAbiItem();
});

// node_modules/viem/_esm/utils/abi/encodeFunctionData.js
function encodeFunctionData(parameters) {
  const { args } = parameters;
  const { abi, functionName } = (() => {
    if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
      return parameters;
    return prepareEncodeFunctionData(parameters);
  })();
  const abiItem = abi[0];
  const signature = functionName;
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : undefined;
  return concatHex([signature, data ?? "0x"]);
}
const init_encodeFunctionData = __esm(() => {
  init_encodeAbiParameters();
  init_prepareEncodeFunctionData();
});

// node_modules/viem/_esm/constants/solidity.js
let panicReasons, solidityError, solidityPanic;
const init_solidity = __esm(() => {
  panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmetic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
  };
  solidityError = {
    inputs: [
      {
        name: "message",
        type: "string"
      }
    ],
    name: "Error",
    type: "error"
  };
  solidityPanic = {
    inputs: [
      {
        name: "reason",
        type: "uint256"
      }
    ],
    name: "Panic",
    type: "error"
  };
});

// node_modules/viem/_esm/errors/cursor.js
let NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
const init_cursor = __esm(() => {
  init_base();
  NegativeOffsetError = class NegativeOffsetError extends BaseError2 {
    constructor({ offset }) {
      super(`Offset \`${offset}\` cannot be negative.`, {
        name: "NegativeOffsetError"
      });
    }
  };
  PositionOutOfBoundsError = class PositionOutOfBoundsError extends BaseError2 {
    constructor({ length, position }) {
      super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
    }
  };
  RecursiveReadLimitExceededError = class RecursiveReadLimitExceededError extends BaseError2 {
    constructor({ count, limit }) {
      super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
    }
  };
});

// node_modules/viem/_esm/utils/cursor.js
function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = new Map;
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
let staticCursor;
const init_cursor2 = __esm(() => {
  init_cursor();
  staticCursor = {
    bytes: new Uint8Array,
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map,
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
      if (this.recursiveReadCount >= this.recursiveReadLimit)
        throw new RecursiveReadLimitExceededError({
          count: this.recursiveReadCount + 1,
          limit: this.recursiveReadLimit
        });
    },
    assertPosition(position) {
      if (position < 0 || position > this.bytes.length - 1)
        throw new PositionOutOfBoundsError({
          length: this.bytes.length,
          position
        });
    },
    decrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position - offset;
      this.assertPosition(position);
      this.position = position;
    },
    getReadCount(position) {
      return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position + offset;
      this.assertPosition(position);
      this.position = position;
    },
    inspectByte(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectBytes(length, position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + length - 1);
      return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectUint16(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 1);
      return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 2);
      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 3);
      return this.dataView.getUint32(position);
    },
    pushByte(byte) {
      this.assertPosition(this.position);
      this.bytes[this.position] = byte;
      this.position++;
    },
    pushBytes(bytes) {
      this.assertPosition(this.position + bytes.length - 1);
      this.bytes.set(bytes, this.position);
      this.position += bytes.length;
    },
    pushUint8(value) {
      this.assertPosition(this.position);
      this.bytes[this.position] = value;
      this.position++;
    },
    pushUint16(value) {
      this.assertPosition(this.position + 1);
      this.dataView.setUint16(this.position, value);
      this.position += 2;
    },
    pushUint24(value) {
      this.assertPosition(this.position + 2);
      this.dataView.setUint16(this.position, value >> 8);
      this.dataView.setUint8(this.position + 2, value & ~4_294_967_040);
      this.position += 3;
    },
    pushUint32(value) {
      this.assertPosition(this.position + 3);
      this.dataView.setUint32(this.position, value);
      this.position += 4;
    },
    readByte() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectByte();
      this.position++;
      return value;
    },
    readBytes(length, size2) {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectBytes(length);
      this.position += size2 ?? length;
      return value;
    },
    readUint8() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint8();
      this.position += 1;
      return value;
    },
    readUint16() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint16();
      this.position += 2;
      return value;
    },
    readUint24() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint24();
      this.position += 3;
      return value;
    },
    readUint32() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint32();
      this.position += 4;
      return value;
    },
    get remaining() {
      return this.bytes.length - this.position;
    },
    setPosition(position) {
      const oldPosition = this.position;
      this.assertPosition(position);
      this.position = position;
      return () => this.position = oldPosition;
    },
    _touch() {
      if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
        return;
      const count = this.getReadCount();
      this.positionReadCount.set(this.position, count + 1);
      if (count > 0)
        this.recursiveReadCount++;
    }
  };
});

// node_modules/viem/_esm/utils/encoding/fromBytes.js
function bytesToBigInt(bytes, options = {}) {
  if (options.size !== undefined)
    assertSize(bytes, { size: options.size });
  const hex = bytesToHex(bytes, options);
  return hexToBigInt(hex, options);
}
function bytesToBool(bytes_, options = {}) {
  let bytes = bytes_;
  if (options.size !== undefined) {
    assertSize(bytes, { size: options.size });
    bytes = trim(bytes);
  }
  if (bytes.length > 1 || bytes[0] > 1)
    throw new InvalidBytesBooleanError(bytes);
  return Boolean(bytes[0]);
}
function bytesToNumber(bytes, options = {}) {
  if (options.size !== undefined)
    assertSize(bytes, { size: options.size });
  const hex = bytesToHex(bytes, options);
  return hexToNumber(hex, options);
}
function bytesToString(bytes_, options = {}) {
  let bytes = bytes_;
  if (options.size !== undefined) {
    assertSize(bytes, { size: options.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}
const init_fromBytes = __esm(() => {
  init_encoding();
  init_fromHex();
  init_toHex();
});

// node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
function decodeAbiParameters(parameters, data) {
  const bytes = typeof data === "string" ? hexToBytes(data) : data;
  const cursor = createCursor(bytes);
  if (size(bytes) === 0 && parameters.length > 0)
    throw new AbiDecodingZeroDataError;
  if (size(data) && size(data) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof data === "string" ? data : bytesToHex(data),
      params: parameters,
      size: size(data)
    });
  let consumed = 0;
  const values = [];
  for (const parameter of parameters) {
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, parameter, {
      staticPosition: 0
    });
    consumed += consumed_;
    values.push(data2);
  }
  return values;
}
function decodeParameter(cursor, parameter, { staticPosition }) {
  const arrayComponents = getArrayComponents(parameter.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(cursor, { ...parameter, type }, { length, staticPosition });
  }
  if (parameter.type === "tuple")
    return decodeTuple(cursor, parameter, { staticPosition });
  if (parameter.type === "address")
    return decodeAddress(cursor);
  if (parameter.type === "bool")
    return decodeBool(cursor);
  if (parameter.type.startsWith("bytes"))
    return decodeBytes(cursor, parameter, { staticPosition });
  if (parameter.type.startsWith("uint") || parameter.type.startsWith("int"))
    return decodeNumber(cursor, parameter);
  if (parameter.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidAbiDecodingTypeError(parameter.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(cursor) {
  const value = cursor.readBytes(32);
  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];
}
function decodeArray(cursor, parameter, { length, staticPosition }) {
  if (!length) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(parameter);
    let consumed2 = 0;
    const value2 = [];
    for (let index_ = 0;index_ < length2; ++index_) {
      cursor.setPosition(startOfData + (dynamicChild ? index_ * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, parameter, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(parameter)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const value2 = [];
    for (let index_ = 0;index_ < length; ++index_) {
      cursor.setPosition(start + index_ * 32);
      const [data] = decodeParameter(cursor, parameter, {
        staticPosition: start
      });
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let index_ = 0;index_ < length; ++index_) {
    const [data, consumed_] = decodeParameter(cursor, parameter, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data);
  }
  return [value, consumed];
}
function decodeBool(cursor) {
  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, parameter, { staticPosition }) {
  const [_, size2] = parameter.type.split("bytes");
  if (!size2) {
    const offset = bytesToNumber(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [bytesToHex(data), 32];
  }
  const value = bytesToHex(cursor.readBytes(Number.parseInt(size2), 32));
  return [value, 32];
}
function decodeNumber(cursor, parameter) {
  const signed = parameter.type.startsWith("int");
  const size2 = Number.parseInt(parameter.type.split("int")[1] || "256");
  const value = cursor.readBytes(32);
  return [
    size2 > 48 ? bytesToBigInt(value, { signed }) : bytesToNumber(value, { signed }),
    32
  ];
}
function decodeTuple(cursor, parameter, { staticPosition }) {
  const hasUnnamedChild = parameter.components.length === 0 || parameter.components.some(({ name }) => !name);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(parameter)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    for (let index_ = 0;index_ < parameter.components.length; ++index_) {
      const component = parameter.components[index_];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition: start
      });
      consumed += consumed_;
      value[hasUnnamedChild ? index_ : component?.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let index_ = 0;index_ < parameter.components.length; ++index_) {
    const component = parameter.components[index_];
    const [data, consumed_] = decodeParameter(cursor, component, {
      staticPosition
    });
    value[hasUnnamedChild ? index_ : component?.name] = data;
    consumed += consumed_;
  }
  return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset = bytesToNumber(cursor.readBytes(32));
  const start = staticPosition + offset;
  cursor.setPosition(start);
  const length = bytesToNumber(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value = bytesToString(trim(data));
  cursor.setPosition(staticPosition + 32);
  return [value, 32];
}
function hasDynamicChild(parameter) {
  const { type } = parameter;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return parameter.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(parameter.type);
  if (arrayComponents && hasDynamicChild({ ...parameter, type: arrayComponents[1] }))
    return true;
  return false;
}
var sizeOfLength = 32, sizeOfOffset = 32;
const init_decodeAbiParameters = __esm(() => {
  init_abi();
  init_getAddress();
  init_cursor2();
  init_size();
  init_slice();
  init_fromBytes();
  init_toBytes();
  init_toHex();
  init_encodeAbiParameters();
});

// node_modules/viem/_esm/utils/abi/decodeErrorResult.js
function decodeErrorResult(parameters) {
  const { abi, data } = parameters;
  const signature = slice(data, 0, 4);
  if (signature === "0x")
    throw new AbiDecodingZeroDataError;
  const abi_ = [...abi || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x) => x.type === "error" && signature === toFunctionSelector(formatAbiItem2(x)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : undefined,
    errorName: abiItem.name
  };
}
const init_decodeErrorResult = __esm(() => {
  init_solidity();
  init_abi();
  init_slice();
  init_toFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem2();
});

// node_modules/viem/_esm/utils/stringify.js
const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);

// node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
function formatAbiItemWithArguments({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, index_) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[index_] === "object" ? stringify(args[index_]) : args[index_]}`).join(", ")})`;
}
const init_formatAbiItemWithArguments = () => {};

// node_modules/viem/_esm/constants/unit.js
let etherUnits, gweiUnits;
const init_unit = __esm(() => {
  etherUnits = {
    gwei: 9,
    wei: 18
  };
  gweiUnits = {
    ether: -9,
    wei: 9
  };
});

// node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// node_modules/viem/_esm/utils/unit/formatEther.js
function formatEther2(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
const init_formatEther = __esm(() => {
  init_unit();
});

// node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
const init_formatGwei = __esm(() => {
  init_unit();
});

// node_modules/viem/_esm/errors/stateOverride.js
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}
`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state }) => {
    let value = `${pretty}    ${address}:
`;
    if (state.nonce)
      value += `      nonce: ${state.nonce}
`;
    if (state.balance)
      value += `      balance: ${state.balance}
`;
    if (state.code)
      value += `      code: ${state.code}
`;
    if (state.state) {
      value += `      state:
`;
      value += prettyStateMapping(state.state);
    }
    if (state.stateDiff) {
      value += `      stateDiff:
`;
      value += prettyStateMapping(state.stateDiff);
    }
    return value;
  }, `  State Override:
`).slice(0, -1);
}
let AccountStateConflictError, StateAssignmentConflictError;
const init_stateOverride = __esm(() => {
  init_base();
  AccountStateConflictError = class AccountStateConflictError extends BaseError2 {
    constructor({ address }) {
      super(`State for account "${address}" is set multiple times.`, {
        name: "AccountStateConflictError"
      });
    }
  };
  StateAssignmentConflictError = class StateAssignmentConflictError extends BaseError2 {
    constructor() {
      super("state and stateDiff are set on the same account.", {
        name: "StateAssignmentConflictError"
      });
    }
  };
});

// node_modules/viem/_esm/errors/transaction.js
function prettyPrint(arguments_) {
  const entries = Object.entries(arguments_).map(([key, value]) => {
    if (value === undefined || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((accumulator, [key]) => Math.max(accumulator, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(`
`);
}
let FeeConflictError, InvalidSerializableTransactionError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
const init_transaction = __esm(() => {
  init_formatEther();
  init_formatGwei();
  init_base();
  FeeConflictError = class FeeConflictError extends BaseError2 {
    constructor() {
      super([
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
      ].join(`
`), { name: "FeeConflictError" });
    }
  };
  InvalidSerializableTransactionError = class InvalidSerializableTransactionError extends BaseError2 {
    constructor({ transaction }) {
      super("Cannot infer a transaction type from provided transaction.", {
        metaMessages: [
          "Provided Transaction:",
          "{",
          prettyPrint(transaction),
          "}",
          "",
          "To infer the type, either provide:",
          "- a `type` to the Transaction, or",
          "- an EIP-1559 Transaction with `maxFeePerGas`, or",
          "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
          "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
          "- an EIP-7702 Transaction with `authorizationList`, or",
          "- a Legacy Transaction with `gasPrice`"
        ],
        name: "InvalidSerializableTransactionError"
      });
    }
  };
  TransactionExecutionError = class TransactionExecutionError extends BaseError2 {
    constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
      const prettyArguments = prettyPrint({
        chain: chain && `${chain?.name} (id: ${chain?.id})`,
        from: account?.address,
        to,
        value: value !== undefined && `${formatEther2(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: gasPrice !== undefined && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: maxFeePerGas !== undefined && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: maxPriorityFeePerGas !== undefined && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Request Arguments:",
          prettyArguments
        ].filter(Boolean),
        name: "TransactionExecutionError"
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.cause = cause;
    }
  };
  TransactionNotFoundError = class TransactionNotFoundError extends BaseError2 {
    constructor({ blockHash, blockNumber, blockTag, hash: hash2, index }) {
      let identifier = "Transaction";
      if (blockTag && index !== undefined)
        identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
      if (blockHash && index !== undefined)
        identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
      if (blockNumber && index !== undefined)
        identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
      if (hash2)
        identifier = `Transaction with hash "${hash2}"`;
      super(`${identifier} could not be found.`, {
        name: "TransactionNotFoundError"
      });
    }
  };
  TransactionReceiptNotFoundError = class TransactionReceiptNotFoundError extends BaseError2 {
    constructor({ hash: hash2 }) {
      super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`, {
        name: "TransactionReceiptNotFoundError"
      });
    }
  };
  WaitForTransactionReceiptTimeoutError = class WaitForTransactionReceiptTimeoutError extends BaseError2 {
    constructor({ hash: hash2 }) {
      super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
    }
  };
});

// node_modules/viem/_esm/errors/utils.js
const getContractAddress = (address) => address, getUrl = (url) => url;

// node_modules/viem/_esm/errors/contract.js
let CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, CounterfactualDeploymentFailedError, RawContractError;
const init_contract = __esm(() => {
  init_solidity();
  init_decodeErrorResult();
  init_formatAbiItem2();
  init_formatAbiItemWithArguments();
  init_getAbiItem();
  init_formatEther();
  init_formatGwei();
  init_abi();
  init_base();
  init_stateOverride();
  init_transaction();
  CallExecutionError = class CallExecutionError extends BaseError2 {
    constructor(cause, { account: account_, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
      const account = account_ ? parseAccount(account_) : undefined;
      let prettyArguments = prettyPrint({
        from: account?.address,
        to,
        value: value !== undefined && `${formatEther2(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: gasPrice !== undefined && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: maxFeePerGas !== undefined && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: maxPriorityFeePerGas !== undefined && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      if (stateOverride) {
        prettyArguments += `
${prettyStateOverride(stateOverride)}`;
      }
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Raw Call Arguments:",
          prettyArguments
        ].filter(Boolean),
        name: "CallExecutionError"
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.cause = cause;
    }
  };
  ContractFunctionExecutionError = class ContractFunctionExecutionError extends BaseError2 {
    constructor(cause, { abi, args, contractAddress, docsPath: docsPath3, functionName, sender }) {
      const abiItem = getAbiItem({ abi, args, name: functionName });
      const formattedArguments = abiItem ? formatAbiItemWithArguments({
        abiItem,
        args,
        includeFunctionName: false,
        includeName: false
      }) : undefined;
      const functionWithParameters = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
      const prettyArguments = prettyPrint({
        address: contractAddress && getContractAddress(contractAddress),
        function: functionWithParameters,
        args: formattedArguments && formattedArguments !== "()" && `${[...new Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArguments}`,
        sender
      });
      super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          prettyArguments && "Contract Call:",
          prettyArguments
        ].filter(Boolean),
        name: "ContractFunctionExecutionError"
      });
      Object.defineProperty(this, "abi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "args", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "contractAddress", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "formattedArgs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "functionName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "sender", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abi = abi;
      this.args = args;
      this.cause = cause;
      this.contractAddress = contractAddress;
      this.functionName = functionName;
      this.sender = sender;
    }
  };
  ContractFunctionRevertedError = class ContractFunctionRevertedError extends BaseError2 {
    constructor({ abi, data, functionName, message }) {
      let cause;
      let decodedData;
      let metaMessages;
      let reason;
      if (data && data !== "0x") {
        try {
          decodedData = decodeErrorResult({ abi, data });
          const { abiItem, errorName, args: errorArguments } = decodedData;
          if (errorName === "Error") {
            reason = errorArguments[0];
          } else if (errorName === "Panic") {
            const [firstArgument] = errorArguments;
            reason = panicReasons[firstArgument];
          } else {
            const errorWithParameters = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
            const formattedArguments = abiItem && errorArguments ? formatAbiItemWithArguments({
              abiItem,
              args: errorArguments,
              includeFunctionName: false,
              includeName: false
            }) : undefined;
            metaMessages = [
              errorWithParameters ? `Error: ${errorWithParameters}` : "",
              formattedArguments && formattedArguments !== "()" ? `       ${[...new Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArguments}` : ""
            ];
          }
        } catch (error) {
          cause = error;
        }
      } else if (message)
        reason = message;
      let signature;
      if (cause instanceof AbiErrorSignatureNotFoundError) {
        signature = cause.signature;
        metaMessages = [
          `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ];
      }
      super(reason && reason !== "execution reverted" || signature ? [
        `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
        reason || signature
      ].join(`
`) : `The contract function "${functionName}" reverted.`, {
        cause,
        metaMessages,
        name: "ContractFunctionRevertedError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "raw", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "reason", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = decodedData;
      this.raw = data;
      this.reason = reason;
      this.signature = signature;
    }
  };
  ContractFunctionZeroDataError = class ContractFunctionZeroDataError extends BaseError2 {
    constructor({ functionName }) {
      super(`The contract function "${functionName}" returned no data ("0x").`, {
        metaMessages: [
          "This could be due to any of the following:",
          `  - The contract does not have the function "${functionName}",`,
          "  - The parameters passed to the contract function may be invalid, or",
          "  - The address is not a contract."
        ],
        name: "ContractFunctionZeroDataError"
      });
    }
  };
  CounterfactualDeploymentFailedError = class CounterfactualDeploymentFailedError extends BaseError2 {
    constructor({ factory }) {
      super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ""}`, {
        metaMessages: [
          "Please ensure:",
          "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
          "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
        ],
        name: "CounterfactualDeploymentFailedError"
      });
    }
  };
  RawContractError = class RawContractError extends BaseError2 {
    constructor({ data, message }) {
      super(message || "", { name: "RawContractError" });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
    }
  };
});

// node_modules/viem/_esm/errors/request.js
let HttpRequestError, RpcRequestError, TimeoutError;
const init_request = __esm(() => {
  init_base();
  HttpRequestError = class HttpRequestError extends BaseError2 {
    constructor({ body, cause, details, headers, status, url }) {
      super("HTTP request failed.", {
        cause,
        details,
        metaMessages: [
          status && `Status: ${status}`,
          `URL: ${getUrl(url)}`,
          body && `Request body: ${stringify(body)}`
        ].filter(Boolean),
        name: "HttpRequestError"
      });
      Object.defineProperty(this, "body", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "headers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "status", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "url", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.body = body;
      this.headers = headers;
      this.status = status;
      this.url = url;
    }
  };
  RpcRequestError = class RpcRequestError extends BaseError2 {
    constructor({ body, error, url }) {
      super("RPC Request failed.", {
        cause: error,
        details: error.message,
        metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
        name: "RpcRequestError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.code = error.code;
      this.data = error.data;
    }
  };
  TimeoutError = class TimeoutError extends BaseError2 {
    constructor({ body, url }) {
      super("The request took too long to respond.", {
        details: "The request timed out.",
        metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
        name: "TimeoutError"
      });
    }
  };
});

// node_modules/viem/_esm/errors/rpc.js
let unknownErrorCode = -1, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParametersRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnsupportedNonOptionalCapabilityError, UnsupportedChainIdError, DuplicateIdError, UnknownBundleIdError, BundleTooLargeError, AtomicReadyWalletRejectedUpgradeError, AtomicityNotSupportedError, UnknownRpcError;
const init_rpc = __esm(() => {
  init_base();
  init_request();
  RpcError = class RpcError extends BaseError2 {
    constructor(cause, { code, docsPath: docsPath3, metaMessages, name, shortMessage }) {
      super(shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: metaMessages || cause?.metaMessages,
        name: name || "RpcError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.name = name || cause.name;
      this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
    }
  };
  ProviderRpcError = class ProviderRpcError extends RpcError {
    constructor(cause, options) {
      super(cause, options);
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = options.data;
    }
  };
  ParseRpcError = class ParseRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ParseRpcError.code,
        name: "ParseRpcError",
        shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      });
    }
  };
  Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_700
  });
  InvalidRequestRpcError = class InvalidRequestRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidRequestRpcError.code,
        name: "InvalidRequestRpcError",
        shortMessage: "JSON is not a valid request object."
      });
    }
  };
  Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_600
  });
  MethodNotFoundRpcError = class MethodNotFoundRpcError extends RpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: MethodNotFoundRpcError.code,
        name: "MethodNotFoundRpcError",
        shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
      });
    }
  };
  Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_601
  });
  InvalidParametersRpcError = class InvalidParametersRpcError_ extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidParametersRpcError_.code,
        name: "InvalidParamsRpcError",
        shortMessage: [
          "Invalid parameters were provided to the RPC method.",
          "Double check you have provided the correct parameters."
        ].join(`
`)
      });
    }
  };
  Object.defineProperty(InvalidParametersRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_602
  });
  InternalRpcError = class InternalRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InternalRpcError.code,
        name: "InternalRpcError",
        shortMessage: "An internal error was received."
      });
    }
  };
  Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_603
  });
  InvalidInputRpcError = class InvalidInputRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidInputRpcError.code,
        name: "InvalidInputRpcError",
        shortMessage: [
          "Missing or invalid parameters.",
          "Double check you have provided the correct parameters."
        ].join(`
`)
      });
    }
  };
  Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_000
  });
  ResourceNotFoundRpcError = class ResourceNotFoundRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceNotFoundRpcError.code,
        name: "ResourceNotFoundRpcError",
        shortMessage: "Requested resource not found."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ResourceNotFoundRpcError"
      });
    }
  };
  Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_001
  });
  ResourceUnavailableRpcError = class ResourceUnavailableRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceUnavailableRpcError.code,
        name: "ResourceUnavailableRpcError",
        shortMessage: "Requested resource not available."
      });
    }
  };
  Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_002
  });
  TransactionRejectedRpcError = class TransactionRejectedRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: TransactionRejectedRpcError.code,
        name: "TransactionRejectedRpcError",
        shortMessage: "Transaction creation failed."
      });
    }
  };
  Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_003
  });
  MethodNotSupportedRpcError = class MethodNotSupportedRpcError extends RpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: MethodNotSupportedRpcError.code,
        name: "MethodNotSupportedRpcError",
        shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
      });
    }
  };
  Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_004
  });
  LimitExceededRpcError = class LimitExceededRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: LimitExceededRpcError.code,
        name: "LimitExceededRpcError",
        shortMessage: "Request exceeds defined limit."
      });
    }
  };
  Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_005
  });
  JsonRpcVersionUnsupportedError = class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: JsonRpcVersionUnsupportedError.code,
        name: "JsonRpcVersionUnsupportedError",
        shortMessage: "Version of JSON-RPC protocol is not supported."
      });
    }
  };
  Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32_006
  });
  UserRejectedRequestError = class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UserRejectedRequestError.code,
        name: "UserRejectedRequestError",
        shortMessage: "User rejected the request."
      });
    }
  };
  Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
  });
  UnauthorizedProviderError = class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnauthorizedProviderError.code,
        name: "UnauthorizedProviderError",
        shortMessage: "The requested method and/or account has not been authorized by the user."
      });
    }
  };
  Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
  });
  UnsupportedProviderMethodError = class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: UnsupportedProviderMethodError.code,
        name: "UnsupportedProviderMethodError",
        shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
      });
    }
  };
  Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
  });
  ProviderDisconnectedError = class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ProviderDisconnectedError.code,
        name: "ProviderDisconnectedError",
        shortMessage: "The Provider is disconnected from all chains."
      });
    }
  };
  Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
  });
  ChainDisconnectedError = class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ChainDisconnectedError.code,
        name: "ChainDisconnectedError",
        shortMessage: "The Provider is not connected to the requested chain."
      });
    }
  };
  Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
  });
  SwitchChainError = class SwitchChainError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: SwitchChainError.code,
        name: "SwitchChainError",
        shortMessage: "An error occurred when attempting to switch chain."
      });
    }
  };
  Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
  });
  UnsupportedNonOptionalCapabilityError = class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnsupportedNonOptionalCapabilityError.code,
        name: "UnsupportedNonOptionalCapabilityError",
        shortMessage: "This Wallet does not support a capability that was not marked as optional."
      });
    }
  };
  Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5700
  });
  UnsupportedChainIdError = class UnsupportedChainIdError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnsupportedChainIdError.code,
        name: "UnsupportedChainIdError",
        shortMessage: "This Wallet does not support the requested chain ID."
      });
    }
  };
  Object.defineProperty(UnsupportedChainIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5710
  });
  DuplicateIdError = class DuplicateIdError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: DuplicateIdError.code,
        name: "DuplicateIdError",
        shortMessage: "There is already a bundle submitted with this ID."
      });
    }
  };
  Object.defineProperty(DuplicateIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5720
  });
  UnknownBundleIdError = class UnknownBundleIdError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnknownBundleIdError.code,
        name: "UnknownBundleIdError",
        shortMessage: "This bundle id is unknown / has not been submitted"
      });
    }
  };
  Object.defineProperty(UnknownBundleIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5730
  });
  BundleTooLargeError = class BundleTooLargeError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: BundleTooLargeError.code,
        name: "BundleTooLargeError",
        shortMessage: "The call bundle is too large for the Wallet to process."
      });
    }
  };
  Object.defineProperty(BundleTooLargeError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5740
  });
  AtomicReadyWalletRejectedUpgradeError = class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: AtomicReadyWalletRejectedUpgradeError.code,
        name: "AtomicReadyWalletRejectedUpgradeError",
        shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
      });
    }
  };
  Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5750
  });
  AtomicityNotSupportedError = class AtomicityNotSupportedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: AtomicityNotSupportedError.code,
        name: "AtomicityNotSupportedError",
        shortMessage: "The wallet does not support atomic execution but the request requires it."
      });
    }
  };
  Object.defineProperty(AtomicityNotSupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5760
  });
  UnknownRpcError = class UnknownRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        name: "UnknownRpcError",
        shortMessage: "An unknown RPC error occurred."
      });
    }
  };
});

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4_294_967_295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
let HashMD;
const init__md = __esm(() => {
  init__assert();
  init_utilities2();
  HashMD = class HashMD extends Hash {
    constructor(blockLength, outputLength, padOffset, isLE2) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLength;
      this.outputLen = outputLength;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.buffer = new Uint8Array(blockLength);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes2(data);
      const length = data.length;
      for (let pos = 0;pos < length; ) {
        const take = Math.min(blockLen - this.pos, length - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (;blockLen <= length - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let index_ = pos;index_ < blockLen; index_++)
        buffer[index_] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const length = this.outputLen;
      if (length % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLength = length / 4;
      const state = this.get();
      if (outLength > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let index_ = 0;index_ < outLength; index_++)
        oview.setUint32(4 * index_, state[index_], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };
});

// node_modules/@noble/hashes/esm/sha256.js
let SHA256_K, SHA256_IV, SHA256_W, SHA256, sha256;
const init_sha256 = __esm(() => {
  init__md();
  init_utilities2();
  SHA256_K = /* @__PURE__ */ new Uint32Array([
    1_116_352_408,
    1_899_447_441,
    3_049_323_471,
    3_921_009_573,
    961_987_163,
    1_508_970_993,
    2_453_635_748,
    2_870_763_221,
    3_624_381_080,
    310_598_401,
    607_225_278,
    1_426_881_987,
    1_925_078_388,
    2_162_078_206,
    2_614_888_103,
    3_248_222_580,
    3_835_390_401,
    4_022_224_774,
    264_347_078,
    604_807_628,
    770_255_983,
    1_249_150_122,
    1_555_081_692,
    1_996_064_986,
    2_554_220_882,
    2_821_834_349,
    2_952_996_808,
    3_210_313_671,
    3_336_571_891,
    3_584_528_711,
    113_926_993,
    338_241_895,
    666_307_205,
    773_529_912,
    1_294_757_372,
    1_396_182_291,
    1_695_183_700,
    1_986_661_051,
    2_177_026_350,
    2_456_956_037,
    2_730_485_921,
    2_820_302_411,
    3_259_730_800,
    3_345_764_771,
    3_516_065_817,
    3_600_352_804,
    4_094_571_909,
    275_423_344,
    430_227_734,
    506_948_616,
    659_060_556,
    883_997_877,
    958_139_571,
    1_322_822_218,
    1_537_002_063,
    1_747_873_779,
    1_955_562_222,
    2_024_104_815,
    2_227_730_452,
    2_361_852_424,
    2_428_436_474,
    2_756_734_187,
    3_204_031_479,
    3_329_325_298
  ]);
  SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1_779_033_703,
    3_144_134_277,
    1_013_904_242,
    2_773_480_762,
    1_359_893_119,
    2_600_822_924,
    528_734_635,
    1_541_459_225
  ]);
  SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  SHA256 = class SHA256 extends HashMD {
    constructor(outputLength = 32) {
      super(64, outputLength, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let index_ = 0;index_ < 16; index_++, offset += 4)
        SHA256_W[index_] = view.getUint32(offset, false);
      for (let index_ = 16;index_ < 64; index_++) {
        const W15 = SHA256_W[index_ - 15];
        const W2 = SHA256_W[index_ - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[index_] = s1 + SHA256_W[index_ - 7] + s0 + SHA256_W[index_ - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let index_ = 0;index_ < 64; index_++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[index_] + SHA256_W[index_] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256);
});

// node_modules/@noble/hashes/esm/sha2.js
const init_sha2 = __esm(() => {
  init_sha256();
});

// node_modules/@noble/hashes/esm/hmac.js
let HMAC, hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
const init_hmac = __esm(() => {
  init__assert();
  init_utilities2();
  HMAC = class HMAC extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash(hash2);
      const key = toBytes2(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLength = this.blockLen;
      const pad2 = new Uint8Array(blockLength);
      pad2.set(key.length > blockLength ? hash2.create().update(key).digest() : key);
      for (let index_ = 0;index_ < pad2.length; index_++)
        pad2[index_] ^= 54;
      this.iHash.update(pad2);
      this.oHash = hash2.create();
      for (let index_ = 0;index_ < pad2.length; index_++)
        pad2[index_] ^= 54 ^ 92;
      this.oHash.update(pad2);
      pad2.fill(0);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  hmac.create = (hash2, key) => new HMAC(hash2, key);
});

// node_modules/@noble/curves/esm/abstract/utils.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded(number_) {
  const hex = number_.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n2 : BigInt("0x" + hex);
}
function bytesToHex2(bytes) {
  abytes2(bytes);
  if (hasHexBuiltin2)
    return bytes.toHex();
  let hex = "";
  for (const byte of bytes) {
    hex += hexes2[byte];
  }
  return hex;
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes) {
  return hexToNumber2(bytesToHex2(bytes));
}
function bytesToNumberLE(bytes) {
  abytes2(bytes);
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, length) {
  return hexToBytes2(n.toString(16).padStart(length * 2, "0"));
}
function numberToBytesLE(n, length) {
  return numberToBytesBE(n, length).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (error) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + error);
    }
  } else if (isBytes2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const length = res.length;
  if (typeof expectedLength === "number" && length !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + length);
  return res;
}
function concatBytes3(...arrays) {
  let sum = 0;
  for (const a of arrays) {
    abytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let index_ = 0, pad2 = 0;index_ < arrays.length; index_++) {
    const a = arrays[index_];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
function utf8ToBytes2(string_) {
  if (typeof string_ !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(string_));
}
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLength(n) {
  let length;
  for (length = 0;n > _0n2; n >>= _1n2, length += 1)
    ;
  return length;
}
function createHmacDrbg(hashLength, qByteLength, hmacFunction) {
  if (typeof hashLength !== "number" || hashLength < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLength !== "number" || qByteLength < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFunction !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLength);
  let k = u8n(hashLength);
  let index_ = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    index_ = 0;
  };
  const h = (...b) => hmacFunction(k, v, ...b);
  const reseed = (seed = u8n(0)) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (index_++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let length = 0;
    const out = [];
    while (length < qByteLength) {
      v = h();
      const sl = [...v];
      out.push(sl);
      length += v.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkValue = validatorFns[type];
    if (typeof checkValue !== "function")
      throw new Error("invalid validator function");
    const value = object[fieldName];
    if (isOptional && value === undefined)
      return;
    if (!checkValue(value, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + value);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
function memoized(function_) {
  const map = new WeakMap;
  return (argument, ...arguments_) => {
    const value = map.get(argument);
    if (value !== undefined)
      return value;
    const computed = function_(argument, ...arguments_);
    map.set(argument, computed);
    return computed;
  };
}
var _0n2, _1n2, hasHexBuiltin2, hexes2, asciis, isPosBig = (n) => typeof n === "bigint" && _0n2 <= n, bitMask = (n) => (_1n2 << BigInt(n)) - _1n2, u8n = (length) => new Uint8Array(length), u8fr = (array) => Uint8Array.from(array), validatorFns;
const init_utilities3 = __esm(() => {
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n2 = /* @__PURE__ */ BigInt(0);
  _1n2 = /* @__PURE__ */ BigInt(1);
  hasHexBuiltin2 = typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function";
  hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, index_) => index_.toString(16).padStart(2, "0"));
  asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  validatorFns = {
    bigint: (value) => typeof value === "bigint",
    function: (value) => typeof value === "function",
    boolean: (value) => typeof value === "boolean",
    string: (value) => typeof value === "string",
    stringOrUint8Array: (value) => typeof value === "string" || isBytes2(value),
    isSafeInteger: (value) => Number.isSafeInteger(value),
    array: (value) => Array.isArray(value),
    field: (value, object) => object.Fp.isValid(value),
    hash: (value) => typeof value === "function" && Number.isSafeInteger(value.outputLen)
  };
});

// node_modules/@noble/curves/esm/abstract/modular.js
function module_(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(number_, power, modulo) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n3)
    throw new Error("invalid modulus");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * number_ % modulo;
    number_ = number_ * number_ % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n3)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n3)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = module_(number, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return module_(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0;Q % _2n2 === _0n3; Q /= _2n2, S++)
    ;
  for (Z = _2n2;Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++) {
    if (Z > 1000)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n2;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b);m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3module4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5module8(Fp, n) {
      const n2 = Fp.mul(n, _2n2);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const index_ = Fp.mul(Fp.mul(nv, _2n2), v);
      const root = Fp.mul(nv, Fp.sub(index_, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {}
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const options = FIELD_FIELDS.reduce((map, value) => {
    map[value] = "function";
    return map;
  }, initial);
  return validateObject(field, options);
}
function FpPow(f, number_, power) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n3)
    return f.ONE;
  if (power === _1n3)
    return number_;
  let p = f.ONE;
  let d = number_;
  while (power > _0n3) {
    if (power & _1n3)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const temporary = Array.from({length: nums.length});
  const lastMultiplied = nums.reduce((accumulator, number_, index_) => {
    if (f.is0(number_))
      return accumulator;
    temporary[index_] = accumulator;
    return f.mul(accumulator, number_);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((accumulator, number_, index_) => {
    if (f.is0(number_))
      return accumulator;
    temporary[index_] = f.mul(accumulator, temporary[index_]);
    return f.mul(accumulator, number_);
  }, inverted);
  return temporary;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength === undefined ? n.toString(2).length : nBitLength;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLength2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLength2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (number_) => module_(number_, ORDER),
    isValid: (number_) => {
      if (typeof number_ !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof number_);
      return _0n3 <= number_ && number_ < ORDER;
    },
    is0: (number_) => number_ === _0n3,
    isOdd: (number_) => (number_ & _1n3) === _1n3,
    neg: (number_) => module_(-number_, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (number_) => module_(number_ * number_, ORDER),
    add: (lhs, rhs) => module_(lhs + rhs, ORDER),
    sub: (lhs, rhs) => module_(lhs - rhs, ORDER),
    mul: (lhs, rhs) => module_(lhs * rhs, ORDER),
    pow: (number_, power) => FpPow(f, number_, power),
    div: (lhs, rhs) => module_(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (number_) => number_ * number_,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (number_) => invert(number_, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (number_) => isLE2 ? numberToBytesLE(number_, BYTES) : numberToBytesBE(number_, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const length = key.length;
  const fieldLength = getFieldBytesLength(fieldOrder);
  const minLength = getMinHashLength(fieldOrder);
  if (length < 16 || length < minLength || length > 1024)
    throw new Error("expected " + minLength + "-1024 bytes of input, got " + length);
  const number_ = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = module_(number_, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLength) : numberToBytesBE(reduced, fieldLength);
}
let _0n3, _1n3, _2n2, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
const init_modular = __esm(() => {
  init_utilities3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n3 = BigInt(0);
  _1n3 = BigInt(1);
  _2n2 = /* @__PURE__ */ BigInt(2);
  _3n = /* @__PURE__ */ BigInt(3);
  _4n = /* @__PURE__ */ BigInt(4);
  _5n = /* @__PURE__ */ BigInt(5);
  _8n = /* @__PURE__ */ BigInt(8);
  _9n = /* @__PURE__ */ BigInt(9);
  _16n = /* @__PURE__ */ BigInt(16);
  FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
});

// node_modules/@noble/curves/esm/abstract/curve.js
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOptions(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOptions) {
  const { windowSize, mask, maxNumber, shiftBy } = wOptions;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n4;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  for (const [index_, p] of points.entries()) {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + index_);
  }
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  for (const [index_, s] of scalars.entries()) {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + index_);
  }
}
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOptions(W, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let index_ = 1;index_ < windowSize; index_++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      let p = c.ZERO;
      let f = c.BASE;
      const wo = calcWOptions(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(constTimeNegate(isNeg, precomputes[offset]));
        }
      }
      return { p, f };
    },
    wNAFUnsafe(W, precomputes, n, accumulator = c.ZERO) {
      const wo = calcWOptions(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        if (n === _0n4)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          accumulator = accumulator.add(isNeg ? item.negate() : item);
        }
      }
      return accumulator;
    },
    getPrecomputes(W, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return comp;
    },
    wNAFCached(P, n, transform) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
    },
    wNAFCachedUnsafe(P, n, transform, previous) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, previous);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, previous);
    },
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLength(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = bitMask(windowSize);
  const buckets = Array.from({length: Number(MASK) + 1}).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let index_ = lastBits;index_ >= 0; index_ -= windowSize) {
    buckets.fill(zero);
    for (const [index__, scalar] of scalars.entries()) {
      const wbits2 = Number(scalar >> BigInt(index_) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[index__]);
    }
    let resI = zero;
    for (let index__ = buckets.length - 1, sumI = zero;index__ > 0; index__--) {
      sumI = sumI.add(buckets[index__]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (index_ !== 0)
      for (let index_ = 0;index_ < windowSize; index_++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
     p: curve.Fp.ORDER 
  });
}
let _0n4, _1n4, pointPrecomputes, pointWindowSizes;
const init_curve = __esm(() => {
  init_modular();
  init_utilities3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n4 = BigInt(0);
  _1n4 = BigInt(1);
  pointPrecomputes = new WeakMap;
  pointWindowSizes = new WeakMap;
});

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVersionOptions(options) {
  if (options.lowS !== undefined)
    abool("lowS", options.lowS);
  if (options.prehash !== undefined)
    abool("prehash", options.prehash);
}
function validatePointOptions(curve) {
  const options = validateBasic(curve);
  validateObject(options, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = options;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new TypeError("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...options });
}
function weierstrassPoints(options) {
  const CURVE = validatePointOptions(options);
  const { Fp } = CURVE;
  const Function_ = Field(CURVE.n, CURVE.nBitLength);
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes3(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(number_) {
    return inRange(number_, _1n5, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let number_;
    try {
      number_ = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      number_ = module_(number_, N);
    aInRange("private key", number_, _1n5, N);
    return number_;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp.eql(z, Fp.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == undefined)
      iz = is0 ? Fp.ONE : Fp.inv(z);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y, iz);
    const zz = Fp.mul(z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not FE");
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    if (!Fp.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });

  class Point {
    constructor(px, py, pz) {
      if (px == undefined || !Fp.isValid(px))
        throw new Error("x required");
      if (py == undefined || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == undefined || !Fp.isValid(pz))
        throw new Error("z required");
      this.px = px;
      this.py = py;
      this.pz = pz;
      Object.freeze(this);
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (index_) => Fp.eql(index_, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, index_) => p.toAffine(toInv[index_])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    static msm(points, scalars) {
      return pippenger(Point, Function_, points, scalars);
    }
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      let t0 = Fp.mul(X1, X1);
      const t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    multiplyUnsafe(sc) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", sc, _0n5, N);
      const I = Point.ZERO;
      if (sc === _0n5)
        return I;
      if (this.is0() || sc === _1n5)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n5, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? undefined : sum;
    }
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes3(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOptions(curve) {
  const options = validateBasic(curve);
  validateObject(options, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...options });
}
function weierstrass(curveDef) {
  const CURVE = validateOptions(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLength = Fp.BYTES + 1;
  const uncompressedLength = 2 * Fp.BYTES + 1;
  function moduleN(a) {
    return module_(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes3;
      abool("isCompressed", isCompressed);
      return isCompressed ? cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x) : cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
    },
    fromBytes(bytes) {
      const length = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (length === compressedLength && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n5, Fp.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (length === uncompressedLength && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        const cl = compressedLength;
        const ul = uncompressedLength;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + length);
      }
    }
  });
  const numberToNByteHex = (number_) => bytesToHex2(numberToBytesBE(number_, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n5;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? moduleN(-s) : s;
  }
  const slcNumber = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature {
    constructor(r, s, recovery) {
      aInRange("r", r, _1n5, CURVE_ORDER);
      aInRange("s", s, _1n5, CURVE_ORDER);
      this.r = r;
      this.s = s;
      if (recovery != undefined)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNumber(hex, 0, l), slcNumber(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {}
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_moduleN(ensureBytes("msgHash", messageHash));
      if (rec == undefined || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numberToNByteHex(radj));
      const ir = invN(radj);
      const u1 = moduleN(-h * ir);
      const u2 = moduleN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, moduleN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numberToNByteHex(this.r) + numberToNByteHex(this.s);
    }
  }
  const utilities = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const array = isBytes2(item);
    const string_ = typeof item === "string";
    const length = (array || string_) && item.length;
    if (array)
      return length === compressedLength || length === uncompressedLength;
    if (string_)
      return length === 2 * compressedLength || length === 2 * uncompressedLength;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const number_ = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? number_ >> BigInt(delta) : number_;
  };
  const bits2int_moduleN = CURVE.bits2int_modN || function(bytes) {
    return moduleN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(number_) {
    aInRange("num < 2^" + CURVE.nBitLength, number_, _0n5, ORDER_MASK);
    return numberToBytesBE(number_, CURVE.nByteLength);
  }
  function prepSig(messageHash, privateKey, options = defaultSigOptions) {
    if (["recovered", "canonical"].some((k) => (k in options)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = options;
    if (lowS == undefined)
      lowS = true;
    messageHash = ensureBytes("msgHash", messageHash);
    validateSigVersionOptions(options);
    if (prehash)
      messageHash = ensureBytes("prehashed msgHash", hash2(messageHash));
    const h1int = bits2int_moduleN(messageHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArguments = [int2octets(d), int2octets(h1int)];
    if (ent != undefined && ent !== false) {
      const e = ent === true ? randomBytes2(Fp.BYTES) : ent;
      seedArguments.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes3(...seedArguments);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = moduleN(q.x);
      if (r === _0n5)
        return;
      const s = moduleN(ik * moduleN(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOptions = { lowS: CURVE.lowS, prehash: false };
  const defaultVersionOptions = { lowS: CURVE.lowS, prehash: false };
  function sign(messageHash, privKey, options = defaultSigOptions) {
    const { seed, k2sig } = prepSig(messageHash, privKey, options);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, messageHash, publicKey, options = defaultVersionOptions) {
    const sg = signature;
    messageHash = ensureBytes("msgHash", messageHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format } = options;
    validateSigVersionOptions(options);
    if ("strict" in options)
      throw new Error("options.strict was renamed to lowS");
    if (format !== undefined && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex2 = typeof sg === "string" || isBytes2(sg);
    const isObject = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObject)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig;
    let P;
    try {
      if (isObject)
        _sig = new Signature(sg.r, sg.s);
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P = Point.fromHex(publicKey);
    } catch {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      messageHash = CURVE.hash(messageHash);
    const { r, s } = _sig;
    const h = bits2int_moduleN(messageHash);
    const is = invN(s);
    const u1 = moduleN(h * is);
    const u2 = moduleN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = moduleN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils: utilities
  };
}
function SWUFpSqrtRatio(Fp, Z) {
  const q = Fp.ORDER;
  let l = _0n5;
  for (let o = q - _1n5;o % _2n3 === _0n5; o /= _2n3)
    l += _1n5;
  const c1 = l;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q - _1n5) / _2n_pow_c1;
  const c3 = (c2 - _1n5) / _2n3;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp.pow(Z, c2);
  const c7 = Fp.pow(Z, (c2 + _1n5) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp.pow(v, c4);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v);
    let tv5 = Fp.mul(u, tv3);
    tv5 = Fp.pow(tv5, c3);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v);
    tv3 = Fp.mul(tv5, u);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c5);
    const isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c7);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let index_ = c1;index_ > _1n5; index_--) {
      let tv52 = index_ - _2n3;
      tv52 = _2n3 << tv52 - _1n5;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n2) {
    const c12 = (Fp.ORDER - _3n2) / _4n2;
    const c22 = Fp.sqrt(Fp.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp.sqr(v);
      const tv2 = Fp.mul(u, v);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c12);
      y1 = Fp.mul(y1, tv2);
      const y2 = Fp.mul(y1, c22);
      const tv3 = Fp.mul(Fp.sqr(y1), v);
      const isQR = Fp.eql(tv3, u);
      const y = Fp.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, options) {
  validateField(Fp);
  if (!Fp.isValid(options.A) || !Fp.isValid(options.B) || !Fp.isValid(options.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, options.Z);
  if (!Fp.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, options.Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, options.B);
    tv4 = Fp.cmov(options.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, options.A);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, options.A);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, options.B);
    tv2 = Fp.add(tv2, tv5);
    x = Fp.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp.mul(tv1, u);
    y = Fp.mul(y, value);
    x = Fp.cmov(x, tv3, isValid);
    y = Fp.cmov(y, value, isValid);
    const e1 = Fp.isOdd(u) === Fp.isOdd(y);
    y = Fp.cmov(Fp.neg(y), y, e1);
    x = Fp.div(x, tv4);
    return { x, y };
  };
}
let DERError, DER, _0n5, _1n5, _2n3, _3n2, _4n2;
const init_weierstrass = __esm(() => {
  init_curve();
  init_modular();
  init_utilities3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  DERError = class DERError_ extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  DER = {
    Err: DERError,
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLength = data.length / 2;
        const length = numberToHexUnpadded(dataLength);
        if (length.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lengthLength = dataLength > 127 ? numberToHexUnpadded(length.length / 2 | 128) : "";
        const t = numberToHexUnpadded(tag);
        return t + lengthLength + length + data;
      },
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = Boolean(first & 128);
        let length = 0;
        if (isLong)
          {
          const lengthLength = first & 127;
          if (!lengthLength)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lengthLength > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lengthLength);
          if (lengthBytes.length !== lengthLength)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length = length << 8 | b;
          pos += lengthLength;
          if (length < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        else {length = first;}
        const v = data.subarray(pos, pos + length);
        if (v.length !== length)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length) };
      }
    },
    _int: {
      encode(number_) {
        const { Err: E } = DER;
        if (number_ < _0n5)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(number_);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = ensureBytes("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length > 0)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length > 0)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  _0n5 = BigInt(0);
  _1n5 = BigInt(1);
  _2n3 = BigInt(2);
  _3n2 = BigInt(3);
  _4n2 = BigInt(4);
});

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return { ...create(defHash), create };
}
const init__shortw_utilities = __esm(() => {
  init_hmac();
  init_utilities2();
  init_weierstrass();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
});

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function index2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let index_ = length - 1;index_ >= 0; index_--) {
    res[index_] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const array = new Uint8Array(a.length);
  for (const [index_, element] of a.entries()) {
    array[index_] = element ^ b[index_];
  }
  return array;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(message, DST, lengthInBytes, H) {
  abytes2(message);
  abytes2(DST);
  anum(lengthInBytes);
  if (DST.length > 255)
    DST = H(concatBytes3(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lengthInBytes / b_in_bytes);
  if (lengthInBytes > 65_535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes3(DST, index2osp(DST.length, 1));
  const Z_pad = index2osp(0, r_in_bytes);
  const l_index_b_string = index2osp(lengthInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes3(Z_pad, message, l_index_b_string, index2osp(0, 1), DST_prime));
  b[0] = H(concatBytes3(b_0, index2osp(1, 1), DST_prime));
  for (let index_ = 1;index_ <= ell; index_++) {
    const arguments_ = [strxor(b_0, b[index_ - 1]), index2osp(index_ + 1, 1), DST_prime];
    b[index_] = H(concatBytes3(...arguments_));
  }
  const pseudo_random_bytes = concatBytes3(...b);
  return pseudo_random_bytes.slice(0, lengthInBytes);
}
function expand_message_xof(message, DST, lengthInBytes, k, H) {
  abytes2(message);
  abytes2(DST);
  anum(lengthInBytes);
  if (DST.length > 255) {
    const dkLength = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen: dkLength }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lengthInBytes > 65_535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lengthInBytes }).update(message).update(index2osp(lengthInBytes, 2)).update(DST).update(index2osp(DST.length, 1)).digest();
}
function hash_to_field(message, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes2(message);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes2(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const length_in_bytes = count * m * L;
  let prb;
  switch (expand) {
  case "xmd": {
    prb = expand_message_xmd(message, DST, length_in_bytes, hash2);
  
  break;
  }
  case "xof": {
    prb = expand_message_xof(message, DST, length_in_bytes, k, hash2);
  
  break;
  }
  case "_internal_pass": {
    prb = message;
  
  break;
  }
  default: {
    throw new Error('expand must be "xmd" or "xof"');
  }
  }
  const u = new Array(count);
  for (let index_ = 0;index_ < count; index_++) {
    const e = new Array(m);
    for (let index__ = 0;index__ < m; index__++) {
      const elm_offset = L * (index__ + index_ * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[index__] = module_(os2ip(tv), p);
    }
    u[index_] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((index_) => [...index_].reverse());
  return (x, y) => {
    const [xNumber, xDen, yNumber, yDen] = COEFF.map((value) => value.reduce((accumulator, index_) => field.add(field.mul(accumulator, x), index_)));
    if (field.is0(xDen) || field.is0(yDen))
      throw new Error("bad point: ZERO");
    x = field.div(xNumber, xDen);
    y = field.mul(y, field.div(yNumber, yDen));
    return { x, y };
  };
}
function createHasher(Point, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(message, options) {
      const u = hash_to_field(message, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point.fromAffine(mapToCurve(u[0]));
      const u1 = Point.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    encodeToCurve(message, options) {
      const u = hash_to_field(message, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const index_ of scalars)
        if (typeof index_ !== "bigint")
          throw new Error("mapToCurve: expected array of bigints");
      const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}
let os2ip;
const init_hash_to_curve = __esm(() => {
  init_modular();
  init_utilities3();
  os2ip = bytesToNumberBE;
});

// node_modules/@noble/curves/esm/secp256k1.js
const exports_secp256k1 = {};
__export(exports_secp256k1, {
  secp256k1: () => secp256k1,
  schnorr: () => schnorr,
  hashToCurve: () => hashToCurve,
  encodeToCurve: () => encodeToCurve
});
function sqrtModule(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === undefined) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes3(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes3(tagP, ...messages));
}
function schnorrGetExtensionPubKey(priv) {
  const d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  const p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : moduleN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  aInRange("x", x, _1n6, secp256k1P);
  const xx = moduleP(x * x);
  const c = moduleP(xx * x + BigInt(7));
  let y = sqrtModule(c);
  if (y % _2n4 !== _0n6)
    y = moduleP(-y);
  const p = new Point(x, y, _1n6);
  p.assertValidity();
  return p;
}
function challenge(...arguments_) {
  return moduleN(number_(taggedHash("BIP0340/challenge", ...arguments_)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtensionPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtensionPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numberTo32b(d ^ number_(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = moduleN(number_(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtensionPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numberTo32b(moduleN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(number_(pub));
    const r = number_(sig.subarray(0, 32));
    if (!inRange(r, _1n6, secp256k1P))
      return false;
    const s = number_(sig.subarray(32, 64));
    if (!inRange(s, _1n6, secp256k1N))
      return false;
    const e = challenge(numberTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, moduleN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch {
    return false;
  }
}
var secp256k1P, secp256k1N, _1n6, _2n4, divNearest = (a, b) => (a + b / _2n4) / b, Fpk1, secp256k1, _0n6, TAGGED_HASH_PREFIXES, pointToBytes = (point) => point.toRawBytes(true).slice(1), numberTo32b = (n) => numberToBytesBE(n, 32), moduleP = (x) => module_(x, secp256k1P), moduleN = (x) => module_(x, secp256k1N), Point, GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b), number_, schnorr, isoMap, mapSWU, htf, hashToCurve, encodeToCurve;
const init_secp256k1 = __esm(() => {
  init_sha2();
  init_utilities2();
  init__shortw_utilities();
  init_hash_to_curve();
  init_modular();
  init_utilities3();
  init_weierstrass();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  _1n6 = BigInt(1);
  _2n4 = BigInt(2);
  Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtModule });
  secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fpk1,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = module_(k - c1 * a1 - c2 * a2, n);
        let k2 = module_(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256);
  _0n6 = BigInt(0);
  TAGGED_HASH_PREFIXES = {};
  Point = secp256k1.ProjectivePoint;
  number_ = bytesToNumberBE;
  schnorr = /* @__PURE__ */ (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      taggedHash,
      mod: module_
    }
  }))();
  isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((index_) => index_.map(BigInt))))();
  mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fpk1.create(BigInt("-11"))
  }))();
  htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256
  }))();
  hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();
  encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();
});

// node_modules/viem/_esm/errors/node.js
let ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
const init_node = __esm(() => {
  init_formatGwei();
  init_base();
  ExecutionRevertedError = class ExecutionRevertedError extends BaseError2 {
    constructor({ cause, message } = {}) {
      const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
      super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
        cause,
        name: "ExecutionRevertedError"
      });
    }
  };
  Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
  });
  Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
  });
  FeeCapTooHighError = class FeeCapTooHighError extends BaseError2 {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
        cause,
        name: "FeeCapTooHighError"
      });
    }
  };
  Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  });
  FeeCapTooLowError = class FeeCapTooLowError extends BaseError2 {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
        cause,
        name: "FeeCapTooLowError"
      });
    }
  };
  Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  });
  NonceTooHighError = class NonceTooHighError extends BaseError2 {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
    }
  };
  Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
  });
  NonceTooLowError = class NonceTooLowError extends BaseError2 {
    constructor({ cause, nonce } = {}) {
      super([
        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
      ].join(`
`), { cause, name: "NonceTooLowError" });
    }
  };
  Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
  });
  NonceMaxValueError = class NonceMaxValueError extends BaseError2 {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
    }
  };
  Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
  });
  InsufficientFundsError = class InsufficientFundsError extends BaseError2 {
    constructor({ cause } = {}) {
      super([
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
      ].join(`
`), {
        cause,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient."
        ],
        name: "InsufficientFundsError"
      });
    }
  };
  Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds|exceeds transaction sender account balance/
  });
  IntrinsicGasTooHighError = class IntrinsicGasTooHighError extends BaseError2 {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
        cause,
        name: "IntrinsicGasTooHighError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
  });
  IntrinsicGasTooLowError = class IntrinsicGasTooLowError extends BaseError2 {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
        cause,
        name: "IntrinsicGasTooLowError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
  });
  TransactionTypeNotSupportedError = class TransactionTypeNotSupportedError extends BaseError2 {
    constructor({ cause }) {
      super("The transaction type is not supported for this chain.", {
        cause,
        name: "TransactionTypeNotSupportedError"
      });
    }
  };
  Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
  });
  TipAboveFeeCapError = class TipAboveFeeCapError extends BaseError2 {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
      super([
        `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
      ].join(`
`), {
        cause,
        name: "TipAboveFeeCapError"
      });
    }
  };
  Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  });
  UnknownNodeError = class UnknownNodeError extends BaseError2 {
    constructor({ cause }) {
      super(`An error occurred while executing: ${cause?.shortMessage}`, {
        cause,
        name: "UnknownNodeError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/errors/getNodeError.js
function getNodeError(error, arguments_) {
  const message = (error.details || "").toLowerCase();
  const executionRevertedError = error instanceof BaseError2 ? error.walk((e) => e?.code === ExecutionRevertedError.code) : error;
  if (executionRevertedError instanceof BaseError2)
    return new ExecutionRevertedError({
      cause: error,
      message: executionRevertedError.details
    });
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: error,
      message: error.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: error,
      maxFeePerGas: arguments_?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: error,
      maxFeePerGas: arguments_?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: error, nonce: arguments_?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: error, nonce: arguments_?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: error, nonce: arguments_?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: error });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: error, gas: arguments_?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: error, gas: arguments_?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: error });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: error,
      maxFeePerGas: arguments_?.maxFeePerGas,
      maxPriorityFeePerGas: arguments_?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: error
  });
}
const init_getNodeError = __esm(() => {
  init_base();
  init_node();
});

// node_modules/viem/_esm/utils/formatters/extract.js
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key of keys) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}

// node_modules/viem/_esm/utils/formatters/transactionRequest.js
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (request.authorizationList !== undefined)
    rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);
  if (request.accessList !== undefined)
    rpcRequest.accessList = request.accessList;
  if (request.blobVersionedHashes !== undefined)
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (request.blobs !== undefined) {
    rpcRequest.blobs = typeof request.blobs[0] === "string" ? request.blobs : request.blobs.map((x) => bytesToHex(x));
  }
  if (request.data !== undefined)
    rpcRequest.data = request.data;
  if (request.from !== undefined)
    rpcRequest.from = request.from;
  if (request.gas !== undefined)
    rpcRequest.gas = numberToHex(request.gas);
  if (request.gasPrice !== undefined)
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (request.maxFeePerBlobGas !== undefined)
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (request.maxFeePerGas !== undefined)
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (request.maxPriorityFeePerGas !== undefined)
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (request.nonce !== undefined)
    rpcRequest.nonce = numberToHex(request.nonce);
  if (request.to !== undefined)
    rpcRequest.to = request.to;
  if (request.type !== undefined)
    rpcRequest.type = rpcTransactionType[request.type];
  if (request.value !== undefined)
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    r: authorization.r ? numberToHex(BigInt(authorization.r)) : authorization.r,
    s: authorization.s ? numberToHex(BigInt(authorization.s)) : authorization.s,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    ...authorization.yParity === undefined ? {} : { yParity: numberToHex(authorization.yParity) },
    ...authorization.v !== undefined && authorization.yParity === undefined ? { v: numberToHex(authorization.v) } : {}
  }));
}
let rpcTransactionType;
const init_transactionRequest = __esm(() => {
  init_toHex();
  rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2",
    eip4844: "0x3",
    eip7702: "0x4"
  };
});

// node_modules/viem/_esm/utils/stateOverride.js
function serializeStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0)
    return;
  return stateMapping.reduce((accumulator, { slot, value }) => {
    if (slot.length !== 66)
      throw new InvalidBytesLengthError({
        size: slot.length,
        targetSize: 66,
        type: "hex"
      });
    if (value.length !== 66)
      throw new InvalidBytesLengthError({
        size: value.length,
        targetSize: 66,
        type: "hex"
      });
    accumulator[slot] = value;
    return accumulator;
  }, {});
}
function serializeAccountStateOverride(parameters) {
  const { balance, nonce, state, stateDiff, code } = parameters;
  const rpcAccountStateOverride = {};
  if (code !== undefined)
    rpcAccountStateOverride.code = code;
  if (balance !== undefined)
    rpcAccountStateOverride.balance = numberToHex(balance);
  if (nonce !== undefined)
    rpcAccountStateOverride.nonce = numberToHex(nonce);
  if (state !== undefined)
    rpcAccountStateOverride.state = serializeStateMapping(state);
  if (stateDiff !== undefined) {
    if (rpcAccountStateOverride.state)
      throw new StateAssignmentConflictError;
    rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
  if (!parameters)
    return;
  const rpcStateOverride = {};
  for (const { address, ...accountState } of parameters) {
    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address });
    if (rpcStateOverride[address])
      throw new AccountStateConflictError({ address });
    rpcStateOverride[address] = serializeAccountStateOverride(accountState);
  }
  return rpcStateOverride;
}
const init_stateOverride2 = __esm(() => {
  init_address();
  init_data();
  init_stateOverride();
  init_isAddress();
  init_toHex();
});

// node_modules/viem/_esm/constants/number.js
let maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;
const init_number = __esm(() => {
  maxInt8 = 2n ** (8n - 1n) - 1n;
  maxInt16 = 2n ** (16n - 1n) - 1n;
  maxInt24 = 2n ** (24n - 1n) - 1n;
  maxInt32 = 2n ** (32n - 1n) - 1n;
  maxInt40 = 2n ** (40n - 1n) - 1n;
  maxInt48 = 2n ** (48n - 1n) - 1n;
  maxInt56 = 2n ** (56n - 1n) - 1n;
  maxInt64 = 2n ** (64n - 1n) - 1n;
  maxInt72 = 2n ** (72n - 1n) - 1n;
  maxInt80 = 2n ** (80n - 1n) - 1n;
  maxInt88 = 2n ** (88n - 1n) - 1n;
  maxInt96 = 2n ** (96n - 1n) - 1n;
  maxInt104 = 2n ** (104n - 1n) - 1n;
  maxInt112 = 2n ** (112n - 1n) - 1n;
  maxInt120 = 2n ** (120n - 1n) - 1n;
  maxInt128 = 2n ** (128n - 1n) - 1n;
  maxInt136 = 2n ** (136n - 1n) - 1n;
  maxInt144 = 2n ** (144n - 1n) - 1n;
  maxInt152 = 2n ** (152n - 1n) - 1n;
  maxInt160 = 2n ** (160n - 1n) - 1n;
  maxInt168 = 2n ** (168n - 1n) - 1n;
  maxInt176 = 2n ** (176n - 1n) - 1n;
  maxInt184 = 2n ** (184n - 1n) - 1n;
  maxInt192 = 2n ** (192n - 1n) - 1n;
  maxInt200 = 2n ** (200n - 1n) - 1n;
  maxInt208 = 2n ** (208n - 1n) - 1n;
  maxInt216 = 2n ** (216n - 1n) - 1n;
  maxInt224 = 2n ** (224n - 1n) - 1n;
  maxInt232 = 2n ** (232n - 1n) - 1n;
  maxInt240 = 2n ** (240n - 1n) - 1n;
  maxInt248 = 2n ** (248n - 1n) - 1n;
  maxInt256 = 2n ** (256n - 1n) - 1n;
  minInt8 = -(2n ** (8n - 1n));
  minInt16 = -(2n ** (16n - 1n));
  minInt24 = -(2n ** (24n - 1n));
  minInt32 = -(2n ** (32n - 1n));
  minInt40 = -(2n ** (40n - 1n));
  minInt48 = -(2n ** (48n - 1n));
  minInt56 = -(2n ** (56n - 1n));
  minInt64 = -(2n ** (64n - 1n));
  minInt72 = -(2n ** (72n - 1n));
  minInt80 = -(2n ** (80n - 1n));
  minInt88 = -(2n ** (88n - 1n));
  minInt96 = -(2n ** (96n - 1n));
  minInt104 = -(2n ** (104n - 1n));
  minInt112 = -(2n ** (112n - 1n));
  minInt120 = -(2n ** (120n - 1n));
  minInt128 = -(2n ** (128n - 1n));
  minInt136 = -(2n ** (136n - 1n));
  minInt144 = -(2n ** (144n - 1n));
  minInt152 = -(2n ** (152n - 1n));
  minInt160 = -(2n ** (160n - 1n));
  minInt168 = -(2n ** (168n - 1n));
  minInt176 = -(2n ** (176n - 1n));
  minInt184 = -(2n ** (184n - 1n));
  minInt192 = -(2n ** (192n - 1n));
  minInt200 = -(2n ** (200n - 1n));
  minInt208 = -(2n ** (208n - 1n));
  minInt216 = -(2n ** (216n - 1n));
  minInt224 = -(2n ** (224n - 1n));
  minInt232 = -(2n ** (232n - 1n));
  minInt240 = -(2n ** (240n - 1n));
  minInt248 = -(2n ** (248n - 1n));
  minInt256 = -(2n ** (256n - 1n));
  maxUint8 = 2n ** 8n - 1n;
  maxUint16 = 2n ** 16n - 1n;
  maxUint24 = 2n ** 24n - 1n;
  maxUint32 = 2n ** 32n - 1n;
  maxUint40 = 2n ** 40n - 1n;
  maxUint48 = 2n ** 48n - 1n;
  maxUint56 = 2n ** 56n - 1n;
  maxUint64 = 2n ** 64n - 1n;
  maxUint72 = 2n ** 72n - 1n;
  maxUint80 = 2n ** 80n - 1n;
  maxUint88 = 2n ** 88n - 1n;
  maxUint96 = 2n ** 96n - 1n;
  maxUint104 = 2n ** 104n - 1n;
  maxUint112 = 2n ** 112n - 1n;
  maxUint120 = 2n ** 120n - 1n;
  maxUint128 = 2n ** 128n - 1n;
  maxUint136 = 2n ** 136n - 1n;
  maxUint144 = 2n ** 144n - 1n;
  maxUint152 = 2n ** 152n - 1n;
  maxUint160 = 2n ** 160n - 1n;
  maxUint168 = 2n ** 168n - 1n;
  maxUint176 = 2n ** 176n - 1n;
  maxUint184 = 2n ** 184n - 1n;
  maxUint192 = 2n ** 192n - 1n;
  maxUint200 = 2n ** 200n - 1n;
  maxUint208 = 2n ** 208n - 1n;
  maxUint216 = 2n ** 216n - 1n;
  maxUint224 = 2n ** 224n - 1n;
  maxUint232 = 2n ** 232n - 1n;
  maxUint240 = 2n ** 240n - 1n;
  maxUint248 = 2n ** 248n - 1n;
  maxUint256 = 2n ** 256n - 1n;
});

// node_modules/viem/_esm/utils/transaction/assertRequest.js
function assertRequest(arguments_) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = arguments_;
  const account = account_ ? parseAccount(account_) : undefined;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (gasPrice !== undefined && (maxFeePerGas !== undefined || maxPriorityFeePerGas !== undefined))
    throw new FeeConflictError;
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
const init_assertRequest = __esm(() => {
  init_number();
  init_address();
  init_node();
  init_transaction();
  init_isAddress();
});

// node_modules/viem/_esm/utils/address/isAddressEqual.js
function isAddressEqual(a, b) {
  if (!isAddress(a, { strict: false }))
    throw new InvalidAddressError({ address: a });
  if (!isAddress(b, { strict: false }))
    throw new InvalidAddressError({ address: b });
  return a.toLowerCase() === b.toLowerCase();
}
const init_isAddressEqual = __esm(() => {
  init_address();
  init_isAddress();
});

// node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
function decodeFunctionResult(parameters) {
  const { abi, args, functionName, data } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({ abi, args, name: functionName });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath4 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
  const values = decodeAbiParameters(abiItem.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return;
}
var docsPath4 = "/docs/contract/decodeFunctionResult";
const init_decodeFunctionResult = __esm(() => {
  init_abi();
  init_decodeAbiParameters();
  init_getAbiItem();
});

// node_modules/ox/_esm/core/version.js
const version3 = "0.1.1";

// node_modules/ox/_esm/core/internal/errors.js
function getVersion() {
  return version3;
}
const init_errors2 = () => {};

// node_modules/ox/_esm/core/Errors.js
function walk2(error, function_) {
  if (function_?.(error))
    return error;
  if (error && typeof error === "object" && "cause" in error && error.cause)
    return walk2(error.cause, function_);
  return function_ ? null : error;
}
let BaseError3;
const init_Errors = __esm(() => {
  init_errors2();
  BaseError3 = class BaseError3 extends Error {
    constructor(shortMessage, options = {}) {
      const details = (() => {
        if (options.cause instanceof BaseError3) {
          if (options.cause.details)
            return options.cause.details;
          if (options.cause.shortMessage)
            return options.cause.shortMessage;
        }
        if (options.cause?.message)
          return options.cause.message;
        return options.details;
      })();
      const docsPath5 = (() => {
        if (options.cause instanceof BaseError3)
          return options.cause.docsPath || options.docsPath;
        return options.docsPath;
      })();
      const docsBaseUrl = "https://oxlib.sh";
      const docs = `${docsBaseUrl}${docsPath5 ?? ""}`;
      const message = [
        shortMessage || "An error occurred.",
        ...options.metaMessages ? ["", ...options.metaMessages] : [],
        ...details || docsPath5 ? [
          "",
          details ? `Details: ${details}` : undefined,
          docsPath5 ? `See: ${docs}` : undefined
        ] : []
      ].filter((x) => typeof x === "string").join(`
`);
      super(message, options.cause ? { cause: options.cause } : undefined);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseError"
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: `ox@${getVersion()}`
      });
      this.cause = options.cause;
      this.details = details;
      this.docs = docs;
      this.docsPath = docsPath5;
      this.shortMessage = shortMessage;
    }
    walk(function_) {
      return walk2(this, function_);
    }
  };
});

// node_modules/ox/_esm/core/Json.js
function stringify2(value, replacer, space) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof replacer === "function")
      return replacer(key, value2);
    if (typeof value2 === "bigint")
      return value2.toString() + bigIntSuffix;
    return value2;
  }, space);
}
var bigIntSuffix = "#__bigint";

// node_modules/ox/_esm/core/internal/bytes.js
function assertSize2(bytes, size_) {
  if (size2(bytes) > size_)
    throw new SizeOverflowError2({
      givenSize: size2(bytes),
      maxSize: size_
    });
}
function charCodeToBase162(char) {
  if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)
    return char - charCodeMap2.zero;
  if (char >= charCodeMap2.A && char <= charCodeMap2.F)
    return char - (charCodeMap2.A - 10);
  if (char >= charCodeMap2.a && char <= charCodeMap2.f)
    return char - (charCodeMap2.a - 10);
  return;
}
function pad2(bytes, options = {}) {
  const { dir, size: size3 = 32 } = options;
  if (size3 === 0)
    return bytes;
  if (bytes.length > size3)
    throw new SizeExceedsPaddingSizeError2({
      size: bytes.length,
      targetSize: size3,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size3);
  for (let index_ = 0;index_ < size3; index_++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? index_ : size3 - index_ - 1] = bytes[padEnd ? index_ : bytes.length - index_ - 1];
  }
  return paddedBytes;
}
let charCodeMap2;
const init_bytes = __esm(() => {
  init_Bytes();
  charCodeMap2 = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
});

// node_modules/ox/_esm/core/internal/hex.js
function assertSize3(hex, size_) {
  if (size3(hex) > size_)
    throw new SizeOverflowError3({
      givenSize: size3(hex),
      maxSize: size_
    });
}
function assertStartOffset2(value, start) {
  if (typeof start === "number" && start > 0 && start > size3(value) - 1)
    throw new SliceOffsetOutOfBoundsError3({
      offset: start,
      position: "start",
      size: size3(value)
    });
}
function assertEndOffset2(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size3(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError3({
      offset: end,
      position: "end",
      size: size3(value)
    });
  }
}
function pad3(hex_, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size4 * 2)
    throw new SizeExceedsPaddingSizeError3({
      size: Math.ceil(hex.length / 2),
      targetSize: size4,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}
const init_hex = __esm(() => {
  init_Hex();
});

// node_modules/ox/_esm/core/Bytes.js
function from(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex(value);
  return fromArray(value);
}
function fromArray(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromHex(value, options = {}) {
  const { size: size4 } = options;
  let hex = value;
  if (size4) {
    assertSize3(value, size4);
    hex = padRight(value, size4);
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, index_ = 0;index < length; index++) {
    const nibbleLeft = charCodeToBase162(hexString.charCodeAt(index_++));
    const nibbleRight = charCodeToBase162(hexString.charCodeAt(index_++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError3(`Invalid byte sequence ("${hexString[index_ - 2]}${hexString[index_ - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function fromString(value, options = {}) {
  const { size: size4 } = options;
  const bytes = encoder3.encode(value);
  if (typeof size4 === "number") {
    assertSize2(bytes, size4);
    return padRight2(bytes, size4);
  }
  return bytes;
}
function padRight2(value, size4) {
  return pad2(value, { dir: "right", size: size4 });
}
function size2(value) {
  return value.length;
}
let encoder3, SizeOverflowError2, SizeExceedsPaddingSizeError2;
var init_Bytes = __esm(() => {
  init_Errors();
  init_Hex();
  init_bytes();
  init_hex();
  encoder3 = /* @__PURE__ */ new TextEncoder;
  SizeOverflowError2 = class SizeOverflowError2 extends BaseError3 {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bytes.SizeOverflowError"
      });
    }
  };
  SizeExceedsPaddingSizeError2 = class SizeExceedsPaddingSizeError2 extends BaseError3 {
    constructor({ size: size4, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bytes.SizeExceedsPaddingSizeError"
      });
    }
  };
});

// node_modules/ox/_esm/core/Hex.js
function assert(value, options = {}) {
  const { strict = false } = options;
  if (!value)
    throw new InvalidHexTypeError(value);
  if (typeof value !== "string")
    throw new InvalidHexTypeError(value);
  if (strict && !/^0x[\dA-Fa-f]*$/.test(value)) throw new InvalidHexValueError(value);
  if (!value.startsWith("0x"))
    throw new InvalidHexValueError(value);
}
function concat2(...values) {
  return `0x${values.reduce((accumulator, x) => accumulator + x.replace("0x", ""), "")}`;
}
function fromBoolean(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize3(hex, options.size);
    return padLeft(hex, options.size);
  }
  return hex;
}
function fromBytes(value, options = {}) {
  let string = "";
  for (let index_ = 0;index_ < value.length; index_++)
    string += hexes3[value[index_]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize3(hex, options.size);
    return padRight(hex, options.size);
  }
  return hex;
}
function fromNumber(value, options = {}) {
  const { signed, size: size4 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size4) {
    maxValue = signed ? (1n << BigInt(size4) * 8n - 1n) - 1n : 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError2({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size4)
    return padLeft(hex, size4);
  return hex;
}
function fromString2(value, options = {}) {
  return fromBytes(encoder4.encode(value), options);
}
function padLeft(value, size4) {
  return pad3(value, { dir: "left", size: size4 });
}
function padRight(value, size4) {
  return pad3(value, { dir: "right", size: size4 });
}
function slice2(value, start, end, options = {}) {
  const { strict } = options;
  assertStartOffset2(value, start);
  const value_ = `0x${value.replace("0x", "").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
  if (strict)
    assertEndOffset2(value_, start, end);
  return value_;
}
function size3(value) {
  return Math.ceil((value.length - 2) / 2);
}
function validate(value, options = {}) {
  const { strict = false } = options;
  try {
    assert(value, { strict });
    return true;
  } catch {
    return false;
  }
}
let encoder4, hexes3, IntegerOutOfRangeError2, InvalidHexTypeError, InvalidHexValueError, SizeOverflowError3, SliceOffsetOutOfBoundsError3, SizeExceedsPaddingSizeError3;
var init_Hex = __esm(() => {
  init_Errors();
  init_hex();
  encoder4 = /* @__PURE__ */ new TextEncoder;
  hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, index_) => index_.toString(16).padStart(2, "0"));
  IntegerOutOfRangeError2 = class IntegerOutOfRangeError2 extends BaseError3 {
    constructor({ max, min, signed, size: size4, value }) {
      super(`Number \`${value}\` is not in safe${size4 ? ` ${size4 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.IntegerOutOfRangeError"
      });
    }
  };
  InvalidHexTypeError = class InvalidHexTypeError extends BaseError3 {
    constructor(value) {
      super(`Value \`${typeof value === "object" ? stringify2(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
        metaMessages: ['Hex types must be represented as `"0x${string}"`.']
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.InvalidHexTypeError"
      });
    }
  };
  InvalidHexValueError = class InvalidHexValueError extends BaseError3 {
    constructor(value) {
      super(`Value \`${value}\` is an invalid hex value.`, {
        metaMessages: [
          'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.InvalidHexValueError"
      });
    }
  };
  SizeOverflowError3 = class SizeOverflowError3 extends BaseError3 {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.SizeOverflowError"
      });
    }
  };
  SliceOffsetOutOfBoundsError3 = class SliceOffsetOutOfBoundsError3 extends BaseError3 {
    constructor({ offset, position, size: size4 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size4}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.SliceOffsetOutOfBoundsError"
      });
    }
  };
  SizeExceedsPaddingSizeError3 = class SizeExceedsPaddingSizeError3 extends BaseError3 {
    constructor({ size: size4, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.SizeExceedsPaddingSizeError"
      });
    }
  };
});

// node_modules/ox/_esm/core/Withdrawal.js
function toRpc(withdrawal) {
  return {
    address: withdrawal.address,
    amount: fromNumber(withdrawal.amount),
    index: fromNumber(withdrawal.index),
    validatorIndex: fromNumber(withdrawal.validatorIndex)
  };
}
const init_Withdrawal = __esm(() => {
  init_Hex();
});

// node_modules/ox/_esm/core/BlockOverrides.js
function toRpc2(blockOverrides) {
  return {
    ...typeof blockOverrides.baseFeePerGas === "bigint" && {
      baseFeePerGas: fromNumber(blockOverrides.baseFeePerGas)
    },
    ...typeof blockOverrides.blobBaseFee === "bigint" && {
      blobBaseFee: fromNumber(blockOverrides.blobBaseFee)
    },
    ...typeof blockOverrides.feeRecipient === "string" && {
      feeRecipient: blockOverrides.feeRecipient
    },
    ...typeof blockOverrides.gasLimit === "bigint" && {
      gasLimit: fromNumber(blockOverrides.gasLimit)
    },
    ...typeof blockOverrides.number === "bigint" && {
      number: fromNumber(blockOverrides.number)
    },
    ...typeof blockOverrides.prevRandao === "bigint" && {
      prevRandao: fromNumber(blockOverrides.prevRandao)
    },
    ...typeof blockOverrides.time === "bigint" && {
      time: fromNumber(blockOverrides.time)
    },
    ...blockOverrides.withdrawals && {
      withdrawals: blockOverrides.withdrawals.map(toRpc)
    }
  };
}
const init_BlockOverrides = __esm(() => {
  init_Hex();
  init_Withdrawal();
});

// node_modules/viem/_esm/constants/abis.js
let multicall3Abi, batchGatewayAbi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi, erc20Abi;
const init_abis = __esm(() => {
  multicall3Abi = [
    {
      inputs: [
        {
          components: [
            {
              name: "target",
              type: "address"
            },
            {
              name: "allowFailure",
              type: "bool"
            },
            {
              name: "callData",
              type: "bytes"
            }
          ],
          name: "calls",
          type: "tuple[]"
        }
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            {
              name: "success",
              type: "bool"
            },
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "returnData",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ];
  batchGatewayAbi = [
    {
      name: "query",
      type: "function",
      stateMutability: "view",
      inputs: [
        {
          type: "tuple[]",
          name: "queries",
          components: [
            {
              type: "address",
              name: "sender"
            },
            {
              type: "string[]",
              name: "urls"
            },
            {
              type: "bytes",
              name: "data"
            }
          ]
        }
      ],
      outputs: [
        {
          type: "bool[]",
          name: "failures"
        },
        {
          type: "bytes[]",
          name: "responses"
        }
      ]
    },
    {
      name: "HttpError",
      type: "error",
      inputs: [
        {
          type: "uint16",
          name: "status"
        },
        {
          type: "string",
          name: "message"
        }
      ]
    }
  ];
  universalResolverErrors = [
    {
      inputs: [],
      name: "ResolverNotFound",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverWildcardNotSupported",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverNotContract",
      type: "error"
    },
    {
      inputs: [
        {
          name: "returnData",
          type: "bytes"
        }
      ],
      name: "ResolverError",
      type: "error"
    },
    {
      inputs: [
        {
          components: [
            {
              name: "status",
              type: "uint16"
            },
            {
              name: "message",
              type: "string"
            }
          ],
          name: "errors",
          type: "tuple[]"
        }
      ],
      name: "HttpError",
      type: "error"
    }
  ];
  universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    },
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
        { name: "gateways", type: "string[]" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    }
  ];
  universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    },
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [
        { type: "bytes", name: "reverseName" },
        { type: "string[]", name: "gateways" }
      ],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    }
  ];
  textResolverAbi = [
    {
      name: "text",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "key", type: "string" }
      ],
      outputs: [{ name: "", type: "string" }]
    }
  ];
  addressResolverAbi = [
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [{ name: "name", type: "bytes32" }],
      outputs: [{ name: "", type: "address" }]
    },
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "coinType", type: "uint256" }
      ],
      outputs: [{ name: "", type: "bytes" }]
    }
  ];
  universalSignatureValidatorAbi = [
    {
      inputs: [
        {
          name: "_signer",
          type: "address"
        },
        {
          name: "_hash",
          type: "bytes32"
        },
        {
          name: "_signature",
          type: "bytes"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      inputs: [
        {
          name: "_signer",
          type: "address"
        },
        {
          name: "_hash",
          type: "bytes32"
        },
        {
          name: "_signature",
          type: "bytes"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function",
      name: "isValidSig"
    }
  ];
  erc20Abi = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        {
          indexed: true,
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "allowance",
      stateMutability: "view",
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "spender",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "spender",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [
        {
          name: "account",
          type: "address"
        }
      ],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "decimals",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "uint8"
        }
      ]
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    }
  ];
});

// node_modules/viem/_esm/constants/contract.js
const aggregate3Signature = "0x82ad56cb";

// node_modules/viem/_esm/constants/contracts.js
const deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

// node_modules/viem/_esm/errors/chain.js
let ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError;
const init_chain = __esm(() => {
  init_base();
  ChainDoesNotSupportContract = class ChainDoesNotSupportContract extends BaseError2 {
    constructor({ blockNumber, chain, contract }) {
      super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
        metaMessages: [
          "This could be due to any of the following:",
          ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
          ] : [
            `- The chain does not have the contract "${contract.name}" configured.`
          ]
        ],
        name: "ChainDoesNotSupportContract"
      });
    }
  };
  ChainMismatchError = class ChainMismatchError extends BaseError2 {
    constructor({ chain, currentChainId }) {
      super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`, {
        metaMessages: [
          `Current Chain ID:  ${currentChainId}`,
          `Expected Chain ID: ${chain.id}  ${chain.name}`
        ],
        name: "ChainMismatchError"
      });
    }
  };
  ChainNotFoundError = class ChainNotFoundError extends BaseError2 {
    constructor() {
      super([
        "No chain was provided to the request.",
        "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
      ].join(`
`), {
        name: "ChainNotFoundError"
      });
    }
  };
  ClientChainNotConfiguredError = class ClientChainNotConfiguredError extends BaseError2 {
    constructor() {
      super("No chain was provided to the Client.", {
        name: "ClientChainNotConfiguredError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/abi/encodeDeployData.js
function encodeDeployData(parameters) {
  const { abi, args, bytecode } = parameters;
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find((x) => ("type" in x) && x.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath5 });
  if (!("inputs" in description))
    throw new AbiConstructorParametersNotFoundError({ docsPath: docsPath5 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParametersNotFoundError({ docsPath: docsPath5 });
  const data = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data]);
}
var docsPath5 = "/docs/contract/encodeDeployData";
const init_encodeDeployData = __esm(() => {
  init_abi();
  init_encodeAbiParameters();
});

// node_modules/viem/_esm/utils/chain/getChainContractAddress.js
function getChainContractAddress({ blockNumber, chain, contract: name }) {
  const contract = chain?.contracts?.[name];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
const init_getChainContractAddress = __esm(() => {
  init_chain();
});

// node_modules/viem/_esm/utils/errors/getCallError.js
function getCallError(error, { docsPath: docsPath6, ...arguments_ }) {
  const cause = (() => {
    const cause2 = getNodeError(error, arguments_);
    if (cause2 instanceof UnknownNodeError)
      return error;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath6,
    ...arguments_
  });
}
const init_getCallError = __esm(() => {
  init_contract();
  init_node();
  init_getNodeError();
});

// node_modules/viem/_esm/utils/promise/withResolvers.js
function withResolvers() {
  let resolve = () => {
    return;
  };
  let reject = () => {
    return;
  };
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise, resolve, reject };
}

// node_modules/viem/_esm/utils/promise/createBatchScheduler.js
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush();
    const arguments_ = scheduler.map(({ args: arguments2 }) => arguments2);
    if (arguments_.length === 0)
      return;
    fn(arguments_).then((data) => {
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (const [index_, { resolve }] of scheduler.entries()) {
        resolve?.([data[index_], data]);
      }
    }).catch((error) => {
      for (const { reject } of scheduler) {
        reject?.(error);
      }
    });
  };
  const flush = () => schedulerCache.delete(id);
  const getBatchedArguments = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id) || [];
  const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
  return {
    flush,
    async schedule(arguments_) {
      const { promise, resolve, reject } = withResolvers();
      const split2 = shouldSplitBatch?.([...getBatchedArguments(), arguments_]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args: arguments_, resolve, reject });
        return promise;
      }
      setScheduler({ args: arguments_, resolve, reject });
      setTimeout(exec, wait);
      return promise;
    }
  };
}
let schedulerCache;
const init_createBatchScheduler = __esm(() => {
  schedulerCache = /* @__PURE__ */ new Map;
});

// node_modules/viem/_esm/errors/ccip.js
let OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
const init_ccip = __esm(() => {
  init_base();
  OffchainLookupError = class OffchainLookupError extends BaseError2 {
    constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
      super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
        cause,
        metaMessages: [
          ...cause.metaMessages || [],
          cause.metaMessages?.length ? "" : [],
          "Offchain Gateway Call:",
          urls && [
            "  Gateway URL(s):",
            ...urls.map((url) => `    ${getUrl(url)}`)
          ],
          `  Sender: ${sender}`,
          `  Data: ${data}`,
          `  Callback selector: ${callbackSelector}`,
          `  Extra data: ${extraData}`
        ].flat(),
        name: "OffchainLookupError"
      });
    }
  };
  OffchainLookupResponseMalformedError = class OffchainLookupResponseMalformedError extends BaseError2 {
    constructor({ result, url }) {
      super("Offchain gateway response is malformed. Response data must be a hex value.", {
        metaMessages: [
          `Gateway URL: ${getUrl(url)}`,
          `Response: ${stringify(result)}`
        ],
        name: "OffchainLookupResponseMalformedError"
      });
    }
  };
  OffchainLookupSenderMismatchError = class OffchainLookupSenderMismatchError extends BaseError2 {
    constructor({ sender, to }) {
      super("Reverted sender address does not match target contract address (`to`).", {
        metaMessages: [
          `Contract address: ${to}`,
          `OffchainLookup sender address: ${sender}`
        ],
        name: "OffchainLookupSenderMismatchError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/abi/decodeFunctionData.js
function decodeFunctionData(parameters) {
  const { abi, data } = parameters;
  const signature = slice(data, 0, 4);
  const description = abi.find((x) => x.type === "function" && signature === toFunctionSelector(formatAbiItem2(x)));
  if (!description)
    throw new AbiFunctionSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeFunctionData"
    });
  return {
    functionName: description.name,
    args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : undefined
  };
}
const init_decodeFunctionData = __esm(() => {
  init_abi();
  init_slice();
  init_toFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem2();
});

// node_modules/viem/_esm/utils/abi/encodeErrorResult.js
function encodeErrorResult(parameters) {
  const { abi, errorName, args } = parameters;
  let abiItem = abi[0];
  if (errorName) {
    const item = getAbiItem({ abi, args, name: errorName });
    if (!item)
      throw new AbiErrorNotFoundError(errorName, { docsPath: docsPath6 });
    abiItem = item;
  }
  if (abiItem.type !== "error")
    throw new AbiErrorNotFoundError(undefined, { docsPath: docsPath6 });
  const definition = formatAbiItem2(abiItem);
  const signature = toFunctionSelector(definition);
  let data = "0x";
  if (args && args.length > 0) {
    if (!abiItem.inputs)
      throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath6 });
    data = encodeAbiParameters(abiItem.inputs, args);
  }
  return concatHex([signature, data]);
}
var docsPath6 = "/docs/contract/encodeErrorResult";
const init_encodeErrorResult = __esm(() => {
  init_abi();
  init_toFunctionSelector();
  init_encodeAbiParameters();
  init_formatAbiItem2();
  init_getAbiItem();
});

// node_modules/viem/_esm/utils/abi/encodeFunctionResult.js
function encodeFunctionResult(parameters) {
  const { abi, functionName, result } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({ abi, name: functionName });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath7 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath7 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath7 });
  const values = (() => {
    if (abiItem.outputs.length === 0)
      return [];
    if (abiItem.outputs.length === 1)
      return [result];
    if (Array.isArray(result))
      return result;
    throw new InvalidArrayError(result);
  })();
  return encodeAbiParameters(abiItem.outputs, values);
}
var docsPath7 = "/docs/contract/encodeFunctionResult";
const init_encodeFunctionResult = __esm(() => {
  init_abi();
  init_encodeAbiParameters();
  init_getAbiItem();
});

// node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js
async function localBatchGatewayRequest(parameters) {
  const { data, ccipRequest } = parameters;
  const { args: [queries] } = decodeFunctionData({ abi: batchGatewayAbi, data });
  const failures = [];
  const responses = [];
  await Promise.all(queries.map(async (query, index_) => {
    try {
      responses[index_] = await ccipRequest(query);
      failures[index_] = false;
    } catch (error) {
      failures[index_] = true;
      responses[index_] = encodeError(error);
    }
  }));
  return encodeFunctionResult({
    abi: batchGatewayAbi,
    functionName: "query",
    result: [failures, responses]
  });
}
function encodeError(error) {
  if (error.name === "HttpRequestError" && error.status)
    return encodeErrorResult({
      abi: batchGatewayAbi,
      errorName: "HttpError",
      args: [error.status, error.shortMessage]
    });
  return encodeErrorResult({
    abi: [solidityError],
    errorName: "Error",
    args: ["shortMessage" in error ? error.shortMessage : error.message]
  });
}
const localBatchGatewayUrl = "x-batch-gateway:true";
const init_localBatchGatewayRequest = __esm(() => {
  init_abis();
  init_solidity();
  init_decodeFunctionData();
  init_encodeErrorResult();
  init_encodeFunctionResult();
});

// node_modules/viem/_esm/utils/ccip.js
const exports_ccip = {};
__export(exports_ccip, {
  offchainLookupSignature: () => offchainLookupSignature,
  offchainLookupAbiItem: () => offchainLookupAbiItem,
  offchainLookup: () => offchainLookup,
  ccipRequest: () => ccipRequest
});
async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
  const { args } = decodeErrorResult({
    data,
    abi: [offchainLookupAbiItem]
  });
  const [sender, urls, callData, callbackSelector, extraData] = args;
  const { ccipRead } = client;
  const ccipRequest_ = ccipRead && typeof ccipRead?.request === "function" ? ccipRead.request : ccipRequest;
  try {
    if (!isAddressEqual(to, sender))
      throw new OffchainLookupSenderMismatchError({ sender, to });
    const result = urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({
      data: callData,
      ccipRequest: ccipRequest_
    }) : await ccipRequest_({ data: callData, sender, urls });
    const { data: data_ } = await call(client, {
      blockNumber,
      blockTag,
      data: concat([
        callbackSelector,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
      ]),
      to
    });
    return data_;
  } catch (error) {
    throw new OffchainLookupError({
      callbackSelector,
      cause: error,
      data,
      extraData,
      sender,
      urls
    });
  }
}
async function ccipRequest({ data, sender, urls }) {
  let error = new Error("An unknown error occurred.");
  for (const url of urls) {
    const method = url.includes("{data}") ? "GET" : "POST";
    const body = method === "POST" ? { data, sender } : undefined;
    const headers = method === "POST" ? { "Content-Type": "application/json" } : {};
    try {
      const response = await fetch(url.replace("{sender}", sender.toLowerCase()).replace("{data}", data), {
        body: JSON.stringify(body),
        headers,
        method
      });
      let result;
      result = response.headers.get("Content-Type")?.startsWith("application/json") ? (await response.json()).data : (await response.text());
      if (!response.ok) {
        error = new HttpRequestError({
          body,
          details: result?.error ? stringify(result.error) : response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
        continue;
      }
      if (!isHex(result)) {
        error = new OffchainLookupResponseMalformedError({
          result,
          url
        });
        continue;
      }
      return result;
    } catch (error_) {
      error = new HttpRequestError({
        body,
        details: error_.message,
        url
      });
    }
  }
  throw error;
}
var offchainLookupSignature = "0x556f1830", offchainLookupAbiItem;
const init_ccip2 = __esm(() => {
  init_call();
  init_ccip();
  init_request();
  init_decodeErrorResult();
  init_encodeAbiParameters();
  init_isAddressEqual();
  init_localBatchGatewayRequest();
  offchainLookupAbiItem = {
    name: "OffchainLookup",
    type: "error",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "urls",
        type: "string[]"
      },
      {
        name: "callData",
        type: "bytes"
      },
      {
        name: "callbackFunction",
        type: "bytes4"
      },
      {
        name: "extraData",
        type: "bytes"
      }
    ]
  };
});

// node_modules/viem/_esm/actions/public/call.js
async function call(client, arguments_) {
  const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, blobs, blockOverrides, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = arguments_;
  const account = account_ ? parseAccount(account_) : undefined;
  if (code && (factory || factoryData))
    throw new BaseError2("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (code && to)
    throw new BaseError2("Cannot provide both `code` & `to` as parameters.");
  const deploylessCallViaBytecode = code && data_;
  const deploylessCallViaFactory = factory && factoryData && to && data_;
  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
  const data = (() => {
    if (deploylessCallViaBytecode)
      return toDeploylessCallViaBytecodeData({
        code,
        data: data_
      });
    if (deploylessCallViaFactory)
      return toDeploylessCallViaFactoryData({
        data: data_,
        factory,
        factoryData,
        to
      });
    return data_;
  })();
  try {
    assertRequest(arguments_);
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcBlockOverrides = blockOverrides ? toRpc2(blockOverrides) : undefined;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: deploylessCall ? undefined : to,
      value
    });
    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride && !rpcBlockOverrides) {
      try {
        return await scheduleMulticall(client, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (error) {
        if (!(error instanceof ClientChainNotConfiguredError) && !(error instanceof ChainDoesNotSupportContract))
          throw error;
      }
    }
    const parameters = (() => {
      const base = [
        request,
        block
      ];
      if (rpcStateOverride && rpcBlockOverrides)
        return [...base, rpcStateOverride, rpcBlockOverrides];
      if (rpcStateOverride)
        return [...base, rpcStateOverride];
      if (rpcBlockOverrides)
        return [...base, {}, rpcBlockOverrides];
      return base;
    })();
    const response = await client.request({
      method: "eth_call",
      params: parameters
    });
    if (response === "0x")
      return { data: undefined };
    return { data: response };
  } catch (error) {
    const data2 = getRevertErrorData(error);
    const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), exports_ccip));
    if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)
      return { data: await offchainLookup2(client, { data: data2, to }) };
    if (deploylessCall && data2?.slice(0, 10) === "0x101bb98d")
      throw new CounterfactualDeploymentFailedError({ factory });
    throw getCallError(error, {
      ...arguments_,
      account,
      chain: client.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data, to, ...request_ } = request;
  if (!data)
    return false;
  if (data.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).some((x) => x !== undefined))
    return false;
  return true;
}
async function scheduleMulticall(client, arguments_) {
  const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = arguments_;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new ClientChainNotConfiguredError;
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : undefined;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client.uid}.${block}`,
    wait,
    shouldSplitBatch(arguments2) {
      const size4 = arguments2.reduce((size5, { data: data2 }) => size5 + (data2.length - 2), 0);
      return size4 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data2 = await client.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data2 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: undefined };
  return { data: returnData };
}
function toDeploylessCallViaBytecodeData(parameters) {
  const { code, data } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(bytes, bytes)"]),
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [code, data]
  });
}
function toDeploylessCallViaFactoryData(parameters) {
  const { data, factory, factoryData, to } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
    bytecode: deploylessCallViaFactoryBytecode,
    args: [to, data, factory, factoryData]
  });
}
function getRevertErrorData(error_) {
  if (!(error_ instanceof BaseError2))
    return;
  const error = error_.walk();
  return typeof error?.data === "object" ? error.data?.data : error.data;
}
var init_call = __esm(() => {
  init_exports();
  init_BlockOverrides();
  init_abis();
  init_base();
  init_chain();
  init_contract();
  init_decodeFunctionResult();
  init_encodeDeployData();
  init_encodeFunctionData();
  init_getChainContractAddress();
  init_toHex();
  init_getCallError();
  init_transactionRequest();
  init_createBatchScheduler();
  init_stateOverride2();
  init_assertRequest();
});

// src/index.tsx
const import_react57 = __toESM(require_react(), 1);
const import_client = __toESM(require_client(), 1);

// src/App.tsx
const import_react56 = __toESM(require_react(), 1);

// src/components/TokenCards.tsx
const import_react29 = __toESM(require_react(), 1);

// src/components/TokenCard.tsx
const import_react2 = __toESM(require_react(), 1);

// src/utils.ts
const parseEther = (value, decimals = 18) => BigInt(Math.round(value * Number(10n ** BigInt(decimals)) / Number(1n)));
const formatEther = (value, decimals = 18) => {
  const divisor = 10n ** BigInt(decimals);
  const wholePart = value / divisor;
  const fractionalPart = value % divisor;
  return fractionalPart === 0n ? Number(wholePart) : Number(`${wholePart}.${fractionalPart.toString().padStart(decimals, "0").replace(/0+$/, "")}`);
};
const formatNumber = (number_, decimals = 2) => {
  if (number_ >= 1e9)
    return `${(number_ / 1e9).toFixed(decimals)}B`;
  if (number_ >= 1e6)
    return `${(number_ / 1e6).toFixed(decimals)}M`;
  if (number_ >= 1000)
    return `${(number_ / 1000).toFixed(decimals)}K`;
  return number_.toFixed(decimals);
};
const formatTime = (seconds, units = 2) => {
  const days = Math.floor(seconds / 86_400);
  const hours = Math.floor(seconds % 86_400 / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const secs = seconds % 60;
  const parts = [];
  if (days > 0)
    parts.push(`${days} Days`);
  if (hours > 0)
    parts.push(`${hours} Hours`);
  if (minutes > 0)
    parts.push(`${minutes} Minutes`);
  if (secs > 0)
    parts.push(`${secs} Seconds`);
  return parts.slice(0, units).join(", ");
};
const aprToApy = (apr) => (1 + apr / 365) ** 365 - 1;

// src/components/TokenStat.tsx
const import_react = __toESM(require_react(), 1);
const jsx_development_runtime = __toESM(require_jsx_development_runtime(), 1);
const TokenStat = import_react.memo(({ title, detail }) => {
  return /* @__PURE__ */ jsx_development_runtime.jsxDEV("div", {
    className: "bg-gradient-to-r from-green-600/20 to-blue-600/20 rounded-lg py-1 px-2",
    children: [
      /* @__PURE__ */ jsx_development_runtime.jsxDEV("p", {
        className: "text-gray-400 text-xs",
        children: title
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime.jsxDEV("p", {
        className: "font-medium text-xs",
        children: detail
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
TokenStat.displayName = "TokenStat";

// src/components/TokenCard.tsx
const jsx_development_runtime2 = __toESM(require_jsx_development_runtime(), 1);
const TokenCard = import_react2.memo(({ symbol, decimals, description, price, supply, underlying, underlyingSymbol, voteMultiplier, locked, marketRate, color = "green" }) => {
  return /* @__PURE__ */ jsx_development_runtime2.jsxDEV("div", {
    className: "bg-gray-800 p-2 rounded-xl border border-gray-700",
    children: [
      /* @__PURE__ */ jsx_development_runtime2.jsxDEV("div", {
        className: "xl:grid xl:grid-cols-3",
        children: [
          /* @__PURE__ */ jsx_development_runtime2.jsxDEV("div", {
            className: "flex justify-between items-start",
            children: /* @__PURE__ */ jsx_development_runtime2.jsxDEV("div", {
              children: [
                /* @__PURE__ */ jsx_development_runtime2.jsxDEV("div", {
                  className: "flex items-center",
                  children: [
                    /* @__PURE__ */ jsx_development_runtime2.jsxDEV("div", {
                      className: `w-8 h-8 rounded-full bg-${color}-500 flex items-center justify-center mr-2`,
                      children: symbol[0]?.toUpperCase()
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_development_runtime2.jsxDEV("p", {
                      className: "font-bold text-lg",
                      children: [
                        "$",
                        symbol
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                price !== undefined && /* @__PURE__ */ jsx_development_runtime2.jsxDEV("h2", {
                  className: "text-2xl font-bold mt-2",
                  children: [
                    "$",
                    price.toFixed(4)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime2.jsxDEV("div", {
            className: "mt-2 xl:mt-0 grid grid-cols-1 sm:grid-cols-2 col-span-2 gap-2",
            children: [
              /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "Supply",
                detail: `${formatNumber(formatEther(supply, decimals), 3)} ${symbol}`
              }, undefined, false, undefined, this),
              underlying !== undefined && underlying !== supply && /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "TVL",
                detail: `${formatNumber(formatEther(underlying), 2)} ${underlyingSymbol}`
              }, undefined, false, undefined, this),
              underlying !== undefined && underlying !== supply && /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "Mint Rate",
                detail: `${formatNumber(Number(underlying) / Number(supply), 4)} ${underlyingSymbol}`
              }, undefined, false, undefined, this),
              marketRate !== undefined && /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "Market Rate",
                detail: `${formatNumber(Number(marketRate), 3)} ${underlyingSymbol}`
              }, undefined, false, undefined, this),
              locked !== undefined && /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "Locked",
                detail: `${formatNumber(Math.round(formatEther(locked, decimals)))} ${symbol}`
              }, undefined, false, undefined, this),
              locked !== undefined && /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "Lock Rate",
                detail: `${Math.round(1e4 * Number(locked) / Number(supply)) / 100}%`
              }, undefined, false, undefined, this),
              price !== undefined && /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "FDV",
                detail: `$${formatNumber(price * formatEther(supply, decimals))}`
              }, undefined, false, undefined, this),
              voteMultiplier !== undefined && /* @__PURE__ */ jsx_development_runtime2.jsxDEV(TokenStat, {
                title: "Vote Multiplier",
                detail: `${formatNumber(voteMultiplier)}`
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime2.jsxDEV("p", {
        className: "text-gray-400 text-xs mt-2",
        children: description
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
TokenCard.displayName = "TokenCard";

// node_modules/viem/_esm/utils/getAction.js
function getAction(client, actionFunction, name) {
  const action_implicit = client[actionFunction.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (parameters) => actionFunction(client, parameters);
}

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_abi();

// node_modules/viem/_esm/errors/log.js
init_base();

class FilterTypeNotSupportedError extends BaseError2 {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
}

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_toBytes();
init_keccak256();
init_toEventSelector();
init_encodeAbiParameters();
init_formatAbiItem2();
init_getAbiItem();
const docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  const { abi, eventName, args } = parameters;
  let abiItem = abi[0];
  if (eventName) {
    const item = getAbiItem({ abi, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(undefined, { docsPath });
  const definition = formatAbiItem2(abiItem);
  const signature = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((parameter) => ("indexed" in parameter) && parameter.indexed);
    const arguments_ = Array.isArray(args) ? args : (Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : []);
    if (arguments_.length > 0) {
      topics = indexedInputs?.map((parameter, index_) => {
        if (Array.isArray(arguments_[index_]))
          return arguments_[index_].map((_, index__) => encodeArgument({ param: parameter, value: arguments_[index_][index__] }));
        return arguments_[index_] !== undefined && arguments_[index_] !== null ? encodeArgument({ param: parameter, value: arguments_[index_] }) : null;
      }) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArgument({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || /^(.*)\[(\d+)?]$/.test(param.type))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
init_toHex();

// node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : undefined;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    type: "event"
  };
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
init_encodeFunctionData();

// node_modules/viem/_esm/utils/errors/getContractError.js
init_abi();
init_base();
init_contract();
init_request();
init_rpc();
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(error_, { abi, address, args, docsPath: docsPath3, functionName, sender }) {
  const error = error_ instanceof RawContractError ? error_ : (error_ instanceof BaseError2 ? error_.walk((error2) => ("data" in error2)) || error_.walk() : {});
  const { code, data, details, message, shortMessage } = error;
  const cause = (() => {
    if (error_ instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || details || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: error instanceof RpcRequestError ? details : shortMessage ?? message
      });
    }
    return error_;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}

// node_modules/viem/_esm/actions/public/estimateGas.js
init_base();

// node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
init_getAddress();
init_keccak256();
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.slice(4)}`).slice(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/viem/_esm/utils/signature/recoverPublicKey.js
init_size();
init_fromHex();
init_toHex();
async function recoverPublicKey({ hash: hash2, signature }) {
  const hashHex = isHex(hash2) ? hash2 : toHex(hash2);
  const { secp256k1: secp256k12 } = await Promise.resolve().then(() => (init_secp256k1(), exports_secp256k1));
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r, s, v, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    if (size(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.slice(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.slice(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash: hash2, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature }));
}

// node_modules/viem/_esm/utils/authorization/hashAuthorization.js
init_toBytes();
init_toHex();

// node_modules/viem/_esm/utils/encoding/toRlp.js
init_base();
init_cursor2();
init_toBytes();
init_toHex();
function toRlp(bytes, to = "hex") {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === "hex")
    return bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x) => getEncodable(x)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((accumulator, x) => accumulator + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        switch (sizeOfBodyLength) {
        case 1: {
        cursor.pushUint8(bodyLength);
        break;
        }
        case 2: {
        cursor.pushUint16(bodyLength);
        break;
        }
        case 3: {
        cursor.pushUint24(bodyLength);
        break;
        }
        default: { cursor.pushUint32(bodyLength);
        }
        }
      }
      for (const { encode } of list) {
        encode(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        switch (sizeOfBytesLength) {
        case 1: {
        cursor.pushUint8(bytes.length);
        break;
        }
        case 2: {
        cursor.pushUint16(bytes.length);
        break;
        }
        case 3: {
        cursor.pushUint24(bytes.length);
        break;
        }
        default: { cursor.pushUint32(bytes.length);
        }
        }
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError2("Length is too large.");
}

// node_modules/viem/_esm/utils/authorization/hashAuthorization.js
init_keccak256();
function hashAuthorization(parameters) {
  const { chainId, nonce, to } = parameters;
  const address = parameters.contractAddress ?? parameters.address;
  const hash2 = keccak256(concatHex([
    "0x05",
    toRlp([
      chainId ? numberToHex(chainId) : "0x",
      address,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to === "bytes")
    return hexToBytes(hash2);
  return hash2;
}

// node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature } = parameters;
  return recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature ?? authorization
  });
}

// node_modules/viem/_esm/actions/public/estimateGas.js
init_toHex();

// node_modules/viem/_esm/errors/estimateGas.js
init_formatEther();
init_formatGwei();
init_base();
init_transaction();

class EstimateGasExecutionError extends BaseError2 {
  constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArguments = prettyPrint({
      from: account?.address,
      to,
      value: value !== undefined && `${formatEther2(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data,
      gas,
      gasPrice: gasPrice !== undefined && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: maxFeePerGas !== undefined && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: maxPriorityFeePerGas !== undefined && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath3,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArguments
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.cause = cause;
  }
}

// node_modules/viem/_esm/utils/errors/getEstimateGasError.js
init_node();
init_getNodeError();
function getEstimateGasError(error, { docsPath: docsPath3, ...arguments_ }) {
  const cause = (() => {
    const cause2 = getNodeError(error, arguments_);
    if (cause2 instanceof UnknownNodeError)
      return error;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath3,
    ...arguments_
  });
}

// node_modules/viem/_esm/actions/public/estimateGas.js
init_transactionRequest();
init_stateOverride2();
init_assertRequest();
// node_modules/viem/_esm/errors/fee.js
init_formatGwei();
init_base();

class BaseFeeScalarError extends BaseError2 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}

class Eip1559FeesNotSupportedError extends BaseError2 {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}

class MaxFeePerGasTooLowError extends BaseError2 {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
init_fromHex();

// node_modules/viem/_esm/errors/block.js
init_base();

class BlockNotFoundError extends BaseError2 {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
  }
}

// node_modules/viem/_esm/actions/public/getBlock.js
init_toHex();

// node_modules/viem/_esm/utils/formatters/transaction.js
init_fromHex();
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,
    gas: transaction.gas ? BigInt(transaction.gas) : undefined,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : undefined,
    typeHex: transaction.type ? transaction.type : undefined,
    value: transaction.value ? BigInt(transaction.value) : undefined,
    v: transaction.v ? BigInt(transaction.v) : undefined
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
function formatAuthorizationList2(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size > 0 ? BigInt(block.size) : undefined,
    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}

// node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber === undefined ? undefined : numberToHex(blockNumber);
  let block = null;
  block = await (blockHash ? client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true }) : client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) }));
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}

// node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, arguments_) {
  return internal_estimateMaxPriorityFeePerGas(client, arguments_);
}
async function internal_estimateMaxPriorityFeePerGas(client, arguments_) {
  const { block: block_, chain = client.chain, request } = arguments_ || {};
  try {
    const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction(client, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client,
        request
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error;
      return maxPriorityFeePerGas_;
    }
    if (maxPriorityFeePerGas !== undefined)
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, arguments_) {
  return internal_estimateFeesPerGas(client, arguments_);
}
async function internal_estimateFeesPerGas(client, arguments_) {
  const { block: block_, chain = client.chain, request, type = "eip1559" } = arguments_ || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError;
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// node_modules/viem/_esm/actions/public/getTransactionCount.js
init_fromHex();
init_toHex();
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber(count);
}

// node_modules/viem/_esm/utils/blob/blobsToCommitments.js
init_toBytes();
init_toHex();
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x) => bytesToHex(x));
}

// node_modules/viem/_esm/utils/blob/blobsToProofs.js
init_toBytes();
init_toHex();
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (const [index_, blob] of blobs.entries()) {
    const commitment = commitments[index_];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x) => bytesToHex(x));
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
init_toHex();

// node_modules/viem/_esm/utils/hash/sha256.js
init_sha256();
init_toBytes();
init_toHex();
function sha2562(value, to_) {
  const to = to_ || "hex";
  const bytes = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version3 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2562(commitment, "bytes");
  versionedHash.set([version3], 0);
  return to === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version3 } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version3
    }));
  }
  return hashes;
}

// node_modules/viem/_esm/constants/blob.js
const blobsPerTransaction = 6;
const bytesPerFieldElement = 32;
const fieldElementsPerBlob = 4096;
const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - 1 - 1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/viem/_esm/errors/blob.js
init_base();

class BlobSizeTooLargeError extends BaseError2 {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}

class EmptyBlobError extends BaseError2 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}

// node_modules/viem/_esm/utils/blob/toBlobs.js
init_cursor2();
init_size();
init_toBytes();
init_toHex();
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError;
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));
}

// node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let index_ = 0;index_ < blobs.length; index_++)
    sidecars.push({
      blob: blobs[index_],
      commitment: commitments[index_],
      proof: proofs[index_]
    });
  return sidecars;
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_assertRequest();

// node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_transaction();
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (transaction.authorizationList !== undefined)
    return "eip7702";
  if (transaction.blobs !== undefined || transaction.blobVersionedHashes !== undefined || transaction.maxFeePerBlobGas !== undefined || transaction.sidecars !== undefined)
    return "eip4844";
  if (transaction.maxFeePerGas !== undefined || transaction.maxPriorityFeePerGas !== undefined) {
    return "eip1559";
  }
  if (transaction.gasPrice !== undefined) {
    if (transaction.accessList !== undefined)
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/viem/_esm/actions/public/getChainId.js
init_fromHex();
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber(chainIdHex);
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
const eip1559NetworkCache = /* @__PURE__ */ new Map;
async function prepareTransactionRequest(client, arguments_) {
  const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type } = arguments_;
  const account = account_ ? parseAccount(account_) : account_;
  const request = { ...arguments_, ...account ? { from: account?.address } : {} };
  let block;
  async function getBlock2() {
    if (block)
      return block;
    block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain)
      return chain.id;
    if (arguments_.chainId !== undefined)
      return arguments_.chainId;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if (parameters.includes("nonce") && nonce === undefined && account) {
    if (nonceManager) {
      const chainId2 = await getChainId2();
      request.nonce = await nonceManager.consume({
        address: account.address,
        chainId: chainId2,
        client
      });
    } else {
      request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    }
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request.chainId = await getChainId2();
  if ((parameters.includes("fees") || parameters.includes("type")) && type === undefined) {
    try {
      request.type = getTransactionType(request);
    } catch {
      let isEip1559Network = eip1559NetworkCache.get(client.uid);
      if (isEip1559Network === undefined) {
        const block2 = await getBlock2();
        isEip1559Network = typeof block2?.baseFeePerGas === "bigint";
        eip1559NetworkCache.set(client.uid, isEip1559Network);
      }
      request.type = isEip1559Network ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (request.maxFeePerGas === undefined || request.maxPriorityFeePerGas === undefined) {
        const block2 = await getBlock2();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request
        });
        if (arguments_.maxPriorityFeePerGas === undefined && arguments_.maxFeePerGas && arguments_.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (arguments_.maxFeePerGas !== undefined || arguments_.maxPriorityFeePerGas !== undefined)
        throw new Eip1559FeesNotSupportedError;
      if (arguments_.gasPrice === undefined) {
        const block2 = await getBlock2();
        const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
    }
  }
  if (parameters.includes("gas") && gas === undefined)
    request.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : account
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}

// node_modules/viem/_esm/actions/public/getBalance.js
init_toHex();
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : undefined;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, arguments_) {
  const { account: account_ = client.account } = arguments_;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    const estimateGas_rpc = function(parameters) {
      const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [request2, block2 ?? "latest", rpcStateOverride2] : (block2 ? [request2, block2] : [request2])
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {
      ...arguments_,
      parameters: account?.type === "local" ? undefined : ["blobVersionedHashes"]
    });
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError2("`to` is required. Could not infer from `authorizationList`");
        });
      return;
    })();
    assertRequest(arguments_);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
    if (authorizationList) {
      const value2 = await getBalance(client, { address: request.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { address } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: undefined,
            data,
            from: account?.address,
            to: address,
            value: numberToHex(value2)
          },
          rpcStateOverride
        }).catch(() => 100_000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((accumulator, current) => accumulator + current, 0n);
    }
    return estimate;
  } catch (error) {
    throw getEstimateGasError(error, {
      ...arguments_,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi, address, args, functionName, dataSuffix, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : undefined;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
init_getAbiItem();

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
init_abi();
init_isAddressEqual();
init_toBytes();
init_keccak256();
init_toEventSelector();

// node_modules/viem/_esm/utils/abi/decodeEventLog.js
init_abi();
init_size();
init_toEventSelector();
init_cursor();
init_decodeAbiParameters();
init_formatAbiItem2();
const docsPath3 = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature, ...argumentTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath3 });
  const abiItem = (() => {
    if (abi.length === 1)
      return abi[0];
    return abi.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem2(x)));
  })();
  if (!(abiItem && ("name" in abiItem)) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath3 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !(("name" in x) && x.name));
  let arguments_ = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => ("indexed" in x) && x.indexed);
  for (const [index_, parameter] of indexedInputs.entries()) {
    const topic = argumentTopics[index_];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param: parameter
      });
    arguments_[isUnnamed ? index_ : parameter.name || index_] = decodeTopic({ param: parameter, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !(("indexed" in x) && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            arguments_ = [...arguments_, ...decodedData];
          else {
            for (const [index_, nonIndexedInput] of nonIndexedInputs.entries()) {
              arguments_[nonIndexedInput.name] = decodedData[index_];
            }
          }
        }
      } catch (error) {
        if (strict) {
          if (error instanceof AbiDecodingDataSizeTooSmallError || error instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw error;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(arguments_).length > 0 ? arguments_ : undefined
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || /^(.*)\[(\d+)?]$/.test(param.type))
    return value;
  const decodedArgument = decodeAbiParameters([param], value) || [];
  return decodedArgument[0];
}

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs(parameters) {
  const { abi, args, logs, strict = true } = parameters;
  const eventName = (() => {
    if (!parameters.eventName)
      return;
    if (Array.isArray(parameters.eventName))
      return parameters.eventName;
    return [parameters.eventName];
  })();
  return logs.map((log) => {
    try {
      const abiItem = abi.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
      if (!abiItem)
        return null;
      const event = decodeEventLog({
        ...log,
        abi: [abiItem],
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      if (!includesArguments({
        args: event.args,
        inputs: abiItem.inputs,
        matchArgs: args
      }))
        return null;
      return { ...event, ...log };
    } catch (error) {
      let eventName2;
      let isUnnamed;
      if (error instanceof AbiEventSignatureNotFoundError)
        return null;
      if (error instanceof DecodeLogDataMismatch || error instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = error.abiItem.name;
        isUnnamed = error.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function includesArguments(parameters) {
  const { args, inputs, matchArgs } = parameters;
  if (!matchArgs)
    return true;
  if (!args)
    return false;
  function isEqual(input, value, argument) {
    try {
      if (input.type === "address")
        return isAddressEqual(value, argument);
      if (input.type === "string" || input.type === "bytes")
        return keccak256(toBytes(value)) === argument;
      return value === argument;
    } catch {
      return false;
    }
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    return matchArgs.every((value, index) => {
      if (value === null || value === undefined)
        return true;
      const input = inputs[index];
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[index]));
    });
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    return Object.entries(matchArgs).every(([key, value]) => {
      if (value === null || value === undefined)
        return true;
      const input = inputs.find((input2) => input2.name === key);
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[key]));
    });
  return false;
}

// node_modules/viem/_esm/actions/public/getLogs.js
init_toHex();

// node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : undefined);
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: events_ ? undefined : args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  let logs;
  logs = await (blockHash ? client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    }) : client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    }));
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    args,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi, name: eventName }) : undefined;
  const events = event ? undefined : abi.filter((x) => x.type === "event");
  return getAction(client, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}

// node_modules/viem/_esm/actions/public/readContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function readContract(client, parameters) {
  const { abi, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// node_modules/viem/_esm/actions/public/simulateContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function simulateContract(client, parameters) {
  const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi, args, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi.filter((abiItem) => ("name" in abiItem) && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
init_abi();
init_rpc();

// node_modules/viem/_esm/utils/observe.js
const listenersCache = /* @__PURE__ */ new Map;
const cleanupCache = /* @__PURE__ */ new Map;
let callbackCount = 0;
function observe(observerId, callbacks, function_) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((callback) => callback.id !== callbackId));
  };
  const unwatch = () => {
    const listeners2 = getListeners();
    if (!listeners2.some((callback) => callback.id === callbackId))
      return;
    const cleanup2 = cleanupCache.get(observerId);
    if (listeners2.length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...arguments_) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key]?.(...arguments_);
    };
  }
  const cleanup = function_(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// node_modules/viem/_esm/utils/poll.js
function poll(function_, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data;
    if (emitOnBegin)
      data = await function_({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await function_({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}
// node_modules/viem/_esm/utils/promise/withCache.js
const promiseCache = /* @__PURE__ */ new Map;
const responseCache = /* @__PURE__ */ new Map;
function getCache(cacheKey) {
  const buildCache = (cacheKey2, cache) => ({
    clear: () => cache.delete(cacheKey2),
    get: () => cache.get(cacheKey2),
    set: (data) => cache.set(cacheKey2, data)
  });
  const promise = buildCache(cacheKey, promiseCache);
  const response = buildCache(cacheKey, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(function_, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = Date.now() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = function_();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date, data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// node_modules/viem/_esm/actions/public/getBlockNumber.js
const cacheKey = (id) => `blockNumber.${id}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}

// node_modules/viem/_esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter) || !filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (poll_ !== undefined)
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== undefined)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {}
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            logs = previousBlockNumber && previousBlockNumber < blockNumber ? (await getAction(client, getContractEvents, "getContractEvents")({
                abi,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              })) : [];
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (error) {
          if (filter && error instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(error);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: arguments2 } = decodeEventLog({
                  abi,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: arguments2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (error) {
                let eventName2;
                let isUnnamed;
                if (error instanceof DecodeLogDataMismatch || error instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = error.abiItem.name;
                  isUnnamed = error.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (error) {
          onError?.(error);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
// node_modules/viem/_esm/errors/account.js
init_base();

class AccountNotFoundError extends BaseError2 {
  constructor({ docsPath: docsPath8 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: docsPath8,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}

class AccountTypeNotSupportedError extends BaseError2 {
  constructor({ docsPath: docsPath8, metaMessages, type }) {
    super(`Account type "${type}" is not supported.`, {
      docsPath: docsPath8,
      metaMessages,
      name: "AccountTypeNotSupportedError"
    });
  }
}

// node_modules/viem/_esm/actions/wallet/writeContract.js
init_encodeFunctionData();
// node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_base();

// node_modules/viem/_esm/utils/chain/assertCurrentChain.js
init_chain();
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError;
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}

// node_modules/viem/_esm/utils/errors/getTransactionError.js
init_node();
init_transaction();
init_getNodeError();
function getTransactionError(error, { docsPath: docsPath8, ...arguments_ }) {
  const cause = (() => {
    const cause2 = getNodeError(error, arguments_);
    if (cause2 instanceof UnknownNodeError)
      return error;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath8,
    ...arguments_
  });
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_transactionRequest();
init_lru();
init_assertRequest();

// node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
const supportsWalletNamespace = new LruMap(128);
async function sendTransaction(client, parameters) {
  const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type, value, ...rest } = parameters;
  if (account_ === undefined)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = account_ ? parseAccount(account_) : null;
  try {
    assertRequest(parameters);
    const to = await (async () => {
      if (parameters.to)
        return parameters.to;
      if (parameters.to === null)
        return;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError2("`to` is required. Could not infer from `authorizationList`.");
        });
      return;
    })();
    if (account?.type === "json-rpc" || account === null) {
      let chainId;
      if (chain !== null) {
        chainId = await getAction(client, getChainId, "getChainId")({});
        assertCurrentChain({
          currentChainId: chainId,
          chain
        });
      }
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request = format({
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data,
        from: account?.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        type,
        value
      });
      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);
      const method = isWalletNamespaceSupported ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await client.request({
          method,
          params: [request]
        }, { retryCount: 0 });
      } catch (error_) {
        if (isWalletNamespaceSupported === false)
          throw error_;
        const error = error_;
        if (error.name === "InvalidInputRpcError" || error.name === "InvalidParamsRpcError" || error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError") {
          return await client.request({
            method: "wallet_sendTransaction",
            params: [request]
          }, { retryCount: 0 }).then((hash2) => {
            supportsWalletNamespace.set(client.uid, true);
            return hash2;
          }).catch((error_) => {
            const walletNamespaceError = error_;
            if (walletNamespaceError.name === "MethodNotFoundRpcError" || walletNamespaceError.name === "MethodNotSupportedRpcError") {
              supportsWalletNamespace.set(client.uid, false);
              throw error;
            }
            throw walletNamespaceError;
          });
        }
        throw error;
      }
    }
    if (account?.type === "local") {
      const request = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
        account,
        accessList,
        authorizationList,
        blobs,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        type,
        value,
        ...rest,
        to
      });
      const serializer = chain?.serializers?.transaction;
      const serializedTransaction = await account.signTransaction(request, {
        serializer
      });
      return await getAction(client, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    if (account?.type === "smart")
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          "Consider using the `sendUserOperation` Action instead."
        ],
        docsPath: "/docs/actions/bundler/sendUserOperation",
        type: "smart"
      });
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: account?.type
    });
  } catch (error) {
    if (error instanceof AccountTypeNotSupportedError)
      throw error;
    throw getTransactionError(error, {
      ...parameters,
      account,
      chain: parameters.chain || undefined
    });
  }
}

// node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, parameters) {
  const { abi, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
  if (account_ === undefined)
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const account = account_ ? parseAccount(account_) : null;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    return await getAction(client, sendTransaction, "sendTransaction")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      account,
      ...request
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/writeContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/actions/getContract.js
function getContract({ abi, address, client: client_ }) {
  const client = client_;
  const [publicClient, walletClient] = (() => {
    if (!client)
      return [undefined, undefined];
    if ("public" in client && "wallet" in client)
      return [client.public, client.wallet];
    if ("public" in client)
      return [client.public, undefined];
    if ("wallet" in client)
      return [undefined, client.wallet];
    return [client, client];
  })();
  const hasPublicClient = publicClient !== undefined && publicClient !== null;
  const hasWalletClient = walletClient !== undefined && walletClient !== null;
  const contract = {};
  let hasReadFunction = false;
  let hasWriteFunction = false;
  let hasEvent = false;
  for (const item of abi) {
    if (item.type === "function")
      if (item.stateMutability === "view" || item.stateMutability === "pure")
        hasReadFunction = true;
      else
        hasWriteFunction = true;
    else if (item.type === "event")
      hasEvent = true;
    if (hasReadFunction && hasWriteFunction && hasEvent)
      break;
  }
  if (hasPublicClient) {
    if (hasReadFunction)
      contract.read = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(publicClient, readContract, "readContract")({
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasWriteFunction)
      contract.simulate = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(publicClient, simulateContract, "simulateContract")({
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasEvent) {
      contract.createEventFilter = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract.getEvents = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, getContractEvents, "getContractEvents")({
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract.watchEvent = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, watchContractEvent, "watchContractEvent")({
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
    }
  }
  if (hasWalletClient && hasWriteFunction) contract.write = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(walletClient, writeContract, "writeContract")({
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
  if ((hasPublicClient || hasWalletClient) && hasWriteFunction) contract.estimateGas = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            const client2 = publicClient ?? walletClient;
            return getAction(client2, estimateContractGas, "estimateContractGas")({
              abi,
              address,
              functionName,
              args,
              ...options,
              account: options.account ?? walletClient.account
            });
          };
        }
      });
  contract.address = address;
  contract.abi = abi;
  return contract;
}
function getFunctionParameters(values) {
  const hasArguments = values.length && Array.isArray(values[0]);
  const arguments_ = hasArguments ? values[0] : [];
  const options = (hasArguments ? values[1] : values[0]) ?? {};
  return { args: arguments_, options };
}
function getEventParameters(values, abiEvent) {
  let hasArguments = false;
  if (Array.isArray(values[0]))
    hasArguments = true;
  else if (values.length === 1) {
    hasArguments = abiEvent.inputs.some((x) => x.indexed);
  } else if (values.length === 2) {
    hasArguments = true;
  }
  const arguments_ = hasArguments ? values[0] : undefined;
  const options = (hasArguments ? values[1] : values[0]) ?? {};
  return { args: arguments_, options };
}
// node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js
init_base();
// node_modules/viem/_esm/actions/wallet/getCallsStatus.js
init_slice();
init_fromHex();

// node_modules/viem/_esm/utils/formatters/transactionReceipt.js
init_fromHex();
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
// node_modules/viem/_esm/actions/wallet/sendCalls.js
init_base();
init_rpc();
init_encodeFunctionData();
init_fromHex();
init_toHex();
const fallbackMagicIdentifier = "0x5792579257925792579257925792579257925792579257925792579257925792";
const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
  size: 32
});
async function sendCalls(client, parameters) {
  const { account: account_ = client.account, capabilities, chain = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id, version: version4 = "2.0.0" } = parameters;
  if (account_ === undefined)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendCalls"
    });
  const account = account_ ? parseAccount(account_) : null;
  const calls = parameters.calls.map((call_) => {
    const call2 = call_;
    const data = call2.abi ? encodeFunctionData({
      abi: call2.abi,
      functionName: call2.functionName,
      args: call2.args
    }) : call2.data;
    return {
      data,
      to: call2.to,
      value: call2.value ? numberToHex(call2.value) : undefined
    };
  });
  try {
    const response = await client.request({
      method: "wallet_sendCalls",
      params: [
        {
          atomicRequired: forceAtomic,
          calls,
          capabilities,
          chainId: numberToHex(chain.id),
          from: account?.address,
          id,
          version: version4
        }
      ]
    }, { retryCount: 0 });
    if (typeof response === "string")
      return { id: response };
    return response;
  } catch (error_) {
    const error = error_;
    if (experimental_fallback && (error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError" || error.details.toLowerCase().includes("does not exist / is not available") || error.details.toLowerCase().includes("missing or invalid. request()") || error.details.toLowerCase().includes("did not match any variant of untagged enum"))) {
      if (capabilities) {
        const hasNonOptionalCapability = Object.values(capabilities).some((capability) => !capability.optional);
        if (hasNonOptionalCapability) {
          const message = "non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";
          throw new UnsupportedNonOptionalCapabilityError(new BaseError2(message, {
            details: message
          }));
        }
      }
      if (forceAtomic && calls.length > 1) {
        const message = "`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";
        throw new AtomicityNotSupportedError(new BaseError2(message, {
          details: message
        }));
      }
      const promises = [];
      for (const call2 of calls) {
        const promise = sendTransaction(client, {
          account,
          chain,
          data: call2.data,
          to: call2.to,
          value: call2.value ? hexToBigInt(call2.value) : undefined
        });
        promises.push(promise);
        if (experimental_fallbackDelay > 0)
          await new Promise((resolve) => setTimeout(resolve, experimental_fallbackDelay));
      }
      const results = await Promise.allSettled(promises);
      if (results.every((r) => r.status === "rejected"))
        throw results[0].reason;
      const hashes = results.map((result) => {
        if (result.status === "fulfilled")
          return result.value;
        return fallbackTransactionErrorMagicIdentifier;
      });
      return {
        id: concat([
          ...hashes,
          numberToHex(chain.id, { size: 32 }),
          fallbackMagicIdentifier
        ])
      };
    }
    throw getTransactionError(error_, {
      ...parameters,
      account,
      chain: parameters.chain
    });
  }
}

// node_modules/viem/_esm/actions/wallet/getCallsStatus.js
async function getCallsStatus(client, parameters) {
  async function getStatus(id) {
    const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2));
    if (isTransactions) {
      const chainId2 = trim(sliceHex(id, -64, -32));
      const hashes = sliceHex(id, 0, -64).slice(2).match(/.{1,64}/g);
      const receipts2 = await Promise.all(hashes.map((hash2) => fallbackTransactionErrorMagicIdentifier.slice(2) === hash2 ? undefined : client.request({
        method: "eth_getTransactionReceipt",
        params: [`0x${hash2}`]
      }, { dedupe: true })));
      const status2 = (() => {
        if (receipts2.includes(null))
          return 100;
        if (receipts2.every((r) => r?.status === "0x1"))
          return 200;
        if (receipts2.every((r) => r?.status === "0x0"))
          return 500;
        return 600;
      })();
      return {
        atomic: false,
        chainId: hexToNumber(chainId2),
        receipts: receipts2.filter(Boolean),
        status: status2,
        version: "2.0.0"
      };
    }
    return client.request({
      method: "wallet_getCallsStatus",
      params: [id]
    });
  }
  const { atomic = false, chainId, receipts, version: version4 = "2.0.0", ...response } = await getStatus(parameters.id);
  const [status, statusCode] = (() => {
    const statusCode2 = response.status;
    if (statusCode2 >= 100 && statusCode2 < 200)
      return ["pending", statusCode2];
    if (statusCode2 >= 200 && statusCode2 < 300)
      return ["success", statusCode2];
    if (statusCode2 >= 300 && statusCode2 < 700)
      return ["failure", statusCode2];
    if (statusCode2 === "CONFIRMED")
      return ["success", 200];
    if (statusCode2 === "PENDING")
      return ["pending", 100];
    return [undefined, statusCode2];
  })();
  return {
    ...response,
    atomic,
    chainId: chainId ? hexToNumber(chainId) : undefined,
    receipts: receipts?.map((receipt) => ({
      ...receipt,
      blockNumber: hexToBigInt(receipt.blockNumber),
      gasUsed: hexToBigInt(receipt.gasUsed),
      status: receiptStatuses[receipt.status]
    })) ?? [],
    statusCode,
    status,
    version: version4
  };
}

// node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js
async function waitForCallsStatus(client, parameters) {
  const { id, pollingInterval = client.pollingInterval, status = ({ statusCode }) => statusCode >= 200, timeout = 60_000 } = parameters;
  const observerId = stringify(["waitForCallsStatus", client.uid, id]);
  const { promise, resolve, reject } = withResolvers();
  let timer;
  const unobserve = observe(observerId, { resolve, reject }, (emit) => {
    const unpoll = poll(async () => {
      const done = (function_) => {
        clearTimeout(timer);
        unpoll();
        function_();
        unobserve();
      };
      try {
        const result = await getCallsStatus(client, { id });
        if (!status(result))
          return;
        done(() => emit.resolve(result));
      } catch (error) {
        done(() => emit.reject(error));
      }
    }, {
      interval: pollingInterval,
      emitOnBegin: true
    });
    return unpoll;
  });
  timer = timeout ? setTimeout(() => {
    unobserve();
    clearTimeout(timer);
    reject(new WaitForCallsStatusTimeoutError({ id }));
  }, timeout) : undefined;
  return await promise;
}

class WaitForCallsStatusTimeoutError extends BaseError2 {
  constructor({ id }) {
    super(`Timed out while waiting for call bundle with id "${id}" to be confirmed.`, { name: "WaitForCallsStatusTimeoutError" });
  }
}
// node_modules/viem/_esm/utils/uid.js
const size4 = 256;
let index = size4;
let buffer;
function uid(length = 11) {
  if (!buffer || index + length > size4 * 2) {
    buffer = "";
    index = 0;
    for (let index_ = 0;index_ < size4; index_++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).slice(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4000, ccipRead, key = "base", name = "Base Client", pollingInterval = 4000, type = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : undefined;
  const { config, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config, ...value };
  const client = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid()
  };
  function extend(base) {
    return (extendFunction) => {
      const extended = extendFunction(base);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}

// node_modules/viem/_esm/utils/buildRequest.js
init_base();
init_request();
init_rpc();
init_toHex();

// node_modules/viem/_esm/utils/promise/withDedupe.js
init_lru();
const promiseCache2 = /* @__PURE__ */ new LruMap(8192);
function withDedupe(function_, { enabled = true, id }) {
  if (!enabled || !id)
    return function_();
  if (promiseCache2.get(id))
    return promiseCache2.get(id);
  const promise = function_().finally(() => promiseCache2.delete(id));
  promiseCache2.set(id, promise);
  return promise;
}

// node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(function_, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await function_();
        resolve(data);
      } catch (error) {
        if (count < retryCount && await shouldRetry({ count, error: error }))
          return retry({ error: error });
        reject(error);
      }
    };
    attemptRetry();
  });
}

// node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
  return async (arguments_, overrideOptions = {}) => {
    const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const { method } = arguments_;
    if (methods?.exclude?.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    if (methods?.include && !methods.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    const requestId = dedupe ? stringToHex(`${uid2}.${stringify(arguments_)}`) : undefined;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(arguments_);
      } catch (error) {
        const error_ = error;
        switch (error_.code) {
          case ParseRpcError.code: {
            throw new ParseRpcError(error_);
          }
          case InvalidRequestRpcError.code: {
            throw new InvalidRequestRpcError(error_);
          }
          case MethodNotFoundRpcError.code: {
            throw new MethodNotFoundRpcError(error_, { method: arguments_.method });
          }
          case InvalidParametersRpcError.code: {
            throw new InvalidParametersRpcError(error_);
          }
          case InternalRpcError.code: {
            throw new InternalRpcError(error_);
          }
          case InvalidInputRpcError.code: {
            throw new InvalidInputRpcError(error_);
          }
          case ResourceNotFoundRpcError.code: {
            throw new ResourceNotFoundRpcError(error_);
          }
          case ResourceUnavailableRpcError.code: {
            throw new ResourceUnavailableRpcError(error_);
          }
          case TransactionRejectedRpcError.code: {
            throw new TransactionRejectedRpcError(error_);
          }
          case MethodNotSupportedRpcError.code: {
            throw new MethodNotSupportedRpcError(error_, {
              method: arguments_.method
            });
          }
          case LimitExceededRpcError.code: {
            throw new LimitExceededRpcError(error_);
          }
          case JsonRpcVersionUnsupportedError.code: {
            throw new JsonRpcVersionUnsupportedError(error_);
          }
          case UserRejectedRequestError.code: {
            throw new UserRejectedRequestError(error_);
          }
          case UnauthorizedProviderError.code: {
            throw new UnauthorizedProviderError(error_);
          }
          case UnsupportedProviderMethodError.code: {
            throw new UnsupportedProviderMethodError(error_);
          }
          case ProviderDisconnectedError.code: {
            throw new ProviderDisconnectedError(error_);
          }
          case ChainDisconnectedError.code: {
            throw new ChainDisconnectedError(error_);
          }
          case SwitchChainError.code: {
            throw new SwitchChainError(error_);
          }
          case UnsupportedNonOptionalCapabilityError.code: {
            throw new UnsupportedNonOptionalCapabilityError(error_);
          }
          case UnsupportedChainIdError.code: {
            throw new UnsupportedChainIdError(error_);
          }
          case DuplicateIdError.code: {
            throw new DuplicateIdError(error_);
          }
          case UnknownBundleIdError.code: {
            throw new UnknownBundleIdError(error_);
          }
          case BundleTooLargeError.code: {
            throw new BundleTooLargeError(error_);
          }
          case AtomicReadyWalletRejectedUpgradeError.code: {
            throw new AtomicReadyWalletRejectedUpgradeError(error_);
          }
          case AtomicityNotSupportedError.code: {
            throw new AtomicityNotSupportedError(error_);
          }
          case 5000: {
            throw new UserRejectedRequestError(error_);
          }
          default: {
            if (error instanceof BaseError2)
              throw error;
            throw new UnknownRpcError(error_);
          }
        }
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return Number.parseInt(retryAfter) * 1000;
        }
        return Math.trunc(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}

// node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  const uid2 = uid();
  return {
    config: {
      key,
      methods,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type
    },
    request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid2 }),
    value
  };
}

// node_modules/viem/_esm/clients/transports/custom.js
function custom(provider, config = {}) {
  const { key = "custom", methods, name = "Custom Provider", retryDelay } = config;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key,
    methods,
    name,
    request: provider.request.bind(provider),
    retryCount: config.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
// node_modules/viem/_esm/clients/transports/http.js
init_request();

// node_modules/viem/_esm/errors/transport.js
init_base();

class UrlRequiredError extends BaseError2 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}

// node_modules/viem/_esm/clients/transports/http.js
init_createBatchScheduler();

// node_modules/viem/_esm/utils/rpc/http.js
init_request();

// node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(function_, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController;
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await function_({ signal: controller?.signal || null }));
      } catch (error) {
        if (error?.name === "AbortError")
          reject(errorInstance);
        reject(error);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
// node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();

// node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
  return {
    async request(parameters) {
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = parameters;
      const fetchOptions = {
        ...options.fetchOptions,
        ...parameters.fetchOptions
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init);
          const arguments_ = await onRequest?.(request, init) ?? { ...init, url };
          const response2 = await fetch(arguments_.url ?? url, arguments_);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          try {
            data = JSON.parse(data || "{}");
          } catch (error) {
            if (response.ok)
              throw error;
            data = { error: data };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (error) {
        if (error instanceof HttpRequestError)
          throw error;
        if (error instanceof TimeoutError)
          throw error;
        throw new HttpRequestError({
          body,
          cause: error,
          url
        });
      }
    }
  };
}

// node_modules/viem/_esm/clients/transports/http.js
function http(url, config = {}) {
  const { batch, fetchOptions, key = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1000, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError;
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      methods,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a, b) => a.id - b.id
        });
        const function_ = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await function_(body);
        if (raw)
          return { error, result };
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
// node_modules/viem/_esm/actions/ens/getEnsAddress.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_toHex();

// node_modules/viem/_esm/utils/ens/errors.js
init_solidity();
init_base();
init_contract();
function isNullUniversalResolverError(error, callType) {
  if (!(error instanceof BaseError2))
    return false;
  const cause = error.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.data?.errorName === "ResolverNotContract")
    return true;
  if (cause.data?.errorName === "ResolverError")
    return true;
  if (cause.data?.errorName === "HttpError")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}

// node_modules/viem/_esm/actions/ens/getEnsAddress.js
init_localBatchGatewayRequest();

// node_modules/viem/_esm/utils/ens/namehash.js
init_toBytes();
init_toHex();
init_keccak256();

// node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}

// node_modules/viem/_esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let index_ = labels.length - 1;index_ >= 0; index_ -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[index_]);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(labels[index_]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// node_modules/viem/_esm/utils/ens/packetToBytes.js
init_toBytes();

// node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}

// node_modules/viem/_esm/utils/ens/labelhash.js
init_toBytes();
init_toHex();
init_keccak256();
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}

// node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replaceAll(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (const element of list) {
    let encoded = stringToBytes(element);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(element)));
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes.byteLength !== offset + 1)
    return bytes.slice(0, offset + 1);
  return bytes;
}

// node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, parameters) {
  const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;
  const { chain } = client;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain?.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    return null;
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType == undefined ? { args: [namehash(name)] } : { args: [namehash(name), BigInt(coinType)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        functionData,
        gatewayUrls ?? [localBatchGatewayUrl]
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType == undefined ? undefined : [namehash(name), BigInt(coinType)],
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (error) {
    if (strict)
      throw error;
    if (isNullUniversalResolverError(error, "resolve"))
      return null;
    throw error;
  }
}

// node_modules/viem/_esm/errors/ens.js
init_base();

class EnsAvatarInvalidMetadataError extends BaseError2 {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}

class EnsAvatarInvalidNftUriError extends BaseError2 {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}

class EnsAvatarUriResolutionError extends BaseError2 {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}

class EnsAvatarUnsupportedNamespaceError extends BaseError2 {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}

// node_modules/viem/_esm/utils/ens/avatar/utils.js
const networkRegex = /(?<protocol>https?:\/\/[^/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w.\-]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[2-7A-Za-z]{58,}|B[2-7A-Z]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[\dA-F]{50,})(\/(?<target>[\w.\-]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([+/A-Za-z\-]*);base64,([^"].*)/;
const dataURIRegex = /^data:([+/A-Za-z\-]*)?(;[\dA-Za-z].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && error.response !== undefined) {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image;
      img.addEventListener('load', () => {
        resolve(true);
      });
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replaceAll(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replaceAll('_', "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}

// node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// node_modules/viem/_esm/actions/ens/getEnsText.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_toHex();
init_localBatchGatewayRequest();
async function getEnsText(client, parameters) {
  const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters;
  const { chain } = client;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain?.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    return null;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        }),
        gatewayUrls ?? [localBatchGatewayUrl]
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (error) {
    if (strict)
      throw error;
    if (isNullUniversalResolverError(error, "resolve"))
      return null;
    throw error;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
  const record = await getAction(client, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client, {
      record,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsName.js
init_abis();
init_getChainContractAddress();
init_toHex();
async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().slice(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name;
  } catch (error) {
    if (strict)
      throw error;
    if (isNullUniversalResolverError(error, "reverse"))
      return null;
    throw error;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsResolver.js
init_getChainContractAddress();
init_toHex();
async function getEnsResolver(client, parameters) {
  const { blockNumber, blockTag, name } = parameters;
  const { chain } = client;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain?.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(", ")}) for chain "${chain.name}" (id: ${chain.id}).`);
  const [resolverAddress] = await getAction(client, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// node_modules/viem/_esm/clients/decorators/public.js
init_call();

// node_modules/viem/_esm/actions/public/createAccessList.js
init_toHex();
init_getCallError();
init_transactionRequest();
init_assertRequest();
async function createAccessList(client, arguments_) {
  const { account: account_ = client.account, blockNumber, blockTag = "latest", blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = arguments_;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    assertRequest(arguments_);
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      to,
      value
    });
    const response = await client.request({
      method: "eth_createAccessList",
      params: [request, block]
    });
    return {
      accessList: response.accessList,
      gasUsed: BigInt(response.gasUsed)
    };
  } catch (error) {
    throw getCallError(error, {
      ...arguments_,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id, request: getRequest(id), type: "block" };
}

// node_modules/viem/_esm/actions/public/createEventFilter.js
init_toHex();
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : undefined);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length > 0 ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : undefined,
    fromBlock,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    toBlock,
    type: "event"
  };
}

// node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id, request: getRequest(id), type: "transaction" };
}

// node_modules/viem/_esm/actions/public/getBlobBaseFee.js
async function getBlobBaseFee(client) {
  const baseFee = await client.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}

// node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
init_fromHex();
init_toHex();
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber === undefined ? undefined : numberToHex(blockNumber);
  let count;
  count = await (blockHash ? client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    }, { dedupe: true }) : client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) }));
  return hexToNumber(count);
}

// node_modules/viem/_esm/actions/public/getCode.js
init_toHex();
async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber === undefined ? undefined : numberToHex(blockNumber);
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  }, { dedupe: Boolean(blockNumberHex) });
  if (hex === "0x")
    return;
  return hex;
}

// node_modules/viem/_esm/errors/eip712.js
init_base();

class Eip712DomainNotFoundError extends BaseError2 {
  constructor({ address }) {
    super(`No EIP-712 domain found on contract "${address}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${address}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
}

// node_modules/viem/_esm/actions/public/getEip712Domain.js
async function getEip712Domain(client, parameters) {
  const { address, factory, factoryData } = parameters;
  try {
    const [fields, name, version4, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, "readContract")({
      abi,
      address,
      functionName: "eip712Domain",
      factory,
      factoryData
    });
    return {
      domain: {
        name,
        version: version4,
        chainId: Number(chainId),
        verifyingContract,
        salt
      },
      extensions,
      fields
    };
  } catch (error_) {
    const error = error_;
    if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") {
      throw new Eip712DomainNotFoundError({ address });
    }
    throw error;
  }
}
var abi = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/viem/_esm/actions/public/getFeeHistory.js
init_toHex();

// node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map(BigInt),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map(BigInt))
  };
}

// node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : undefined;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  }, { dedupe: Boolean(blockNumberHex) });
  return formatFeeHistory(feeHistory);
}

// node_modules/viem/_esm/actions/public/getFilterLogs.js
async function getFilterLogs(_client, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/getProof.js
init_toHex();

// node_modules/viem/_esm/utils/chain/defineChain.js
function defineChain(chain) {
  return {
    formatters: undefined,
    fees: undefined,
    serializers: undefined,
    ...chain
  };
}

// node_modules/viem/_esm/utils/typedData.js
init_abi();
init_address();

// node_modules/viem/_esm/errors/typedData.js
init_base();

class InvalidDomainError extends BaseError2 {
  constructor({ domain }) {
    super(`Invalid domain "${stringify(domain)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}

class InvalidPrimaryTypeError extends BaseError2 {
  constructor({ primaryType, types }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}

class InvalidStructTypeError extends BaseError2 {
  constructor({ type }) {
    super(`Struct type "${type}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}

// node_modules/viem/_esm/utils/typedData.js
init_isAddress();
init_size();
init_toHex();
init_regex2();

// node_modules/viem/_esm/utils/signature/hashTypedData.js
init_encodeAbiParameters();
init_toHex();
init_keccak256();
function hashTypedData(parameters) {
  const { domain = {}, message, primaryType } = parameters;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  return keccak256(concat(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct({ data, primaryType, types }) {
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
  const encodedHashType = toHex(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...[...unsortedDeps].sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = new Set) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types[primaryType] === undefined) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
}
function encodeField({ types, name, type, value }) {
  if (types[type] !== undefined) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type }, value];
}

// node_modules/viem/_esm/utils/typedData.js
function serializeTypedData(parameters) {
  const { domain: domain_, message: message_, primaryType, types } = parameters;
  const normalizeData = (struct, data_) => {
    const data = { ...data_ };
    for (const parameter of struct) {
      const { name, type } = parameter;
      if (type === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain = (() => {
    if (!types.EIP712Domain)
      return {};
    if (!domain_)
      return {};
    return normalizeData(types.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return;
    return normalizeData(types[primaryType], message_);
  })();
  return stringify({ domain, message, primaryType, types });
}
function validateTypedData(parameters) {
  const { domain, message, primaryType, types } = parameters;
  const validateData = (struct, data) => {
    for (const parameter of struct) {
      const { name, type } = parameter;
      const value = data[name];
      const integerMatch = type.match(integerRegex2);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base, size_] = integerMatch;
        numberToHex(value, {
          signed: base === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex2);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct2 = types[type];
      if (struct2) {
        validateReference(type);
        validateData(struct2, value);
      }
    }
  };
  if (types.EIP712Domain && domain) {
    if (typeof domain !== "object")
      throw new InvalidDomainError({ domain });
    validateData(types.EIP712Domain, domain);
  }
  if (primaryType !== "EIP712Domain") {
    if (types[primaryType])
      validateData(types[primaryType], message);
    else
      throw new InvalidPrimaryTypeError({ primaryType, types });
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    (typeof domain?.chainId === "number" || typeof domain?.chainId === "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function validateReference(type) {
  if (type === "address" || type === "bool" || type === "string" || type.startsWith("bytes") || type.startsWith("uint") || type.startsWith("int"))
    throw new InvalidStructTypeError({ type });
}

// node_modules/viem/_esm/utils/index.js
init_encodeFunctionData();
init_fromHex();

// node_modules/viem/_esm/utils/signature/hashMessage.js
init_keccak256();

// node_modules/viem/_esm/constants/strings.js
const presignMessagePrefix = `\u0019Ethereum Signed Message:
`;

// node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
init_size();
init_toHex();
function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === "string")
      return stringToHex(message_);
    if (typeof message_.raw === "string")
      return message_.raw;
    return bytesToHex(message_.raw);
  })();
  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
  return concat([prefix, message]);
}

// node_modules/viem/_esm/utils/signature/hashMessage.js
function hashMessage(message, to_) {
  return keccak256(toPrefixedMessage(message), to_);
}

// node_modules/viem/_esm/constants/bytes.js
const erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";

// node_modules/viem/_esm/utils/signature/isErc6492Signature.js
init_slice();
function isErc6492Signature(signature) {
  return sliceHex(signature, -32) === erc6492MagicBytes;
}

// node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
init_encodeAbiParameters();
init_toBytes();
function serializeErc6492Signature(parameters) {
  const { address, data, signature, to = "hex" } = parameters;
  const signature_ = concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
    erc6492MagicBytes
  ]);
  if (to === "hex")
    return signature_;
  return hexToBytes(signature_);
}

// node_modules/viem/_esm/utils/formatters/proof.js
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : undefined,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : undefined
  };
}

// node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber === undefined ? undefined : numberToHex(blockNumber);
  const proof = await client.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}

// node_modules/viem/_esm/actions/public/getStorageAt.js
init_toHex();
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber === undefined ? undefined : numberToHex(blockNumber);
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// node_modules/viem/_esm/actions/public/getTransaction.js
init_transaction();
init_toHex();
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber === undefined ? undefined : numberToHex(blockNumber);
  let transaction = null;
  if (hash2) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    }, { dedupe: true });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    }, { dedupe: true });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}

// node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getAction(client, getBlockNumber, "getBlockNumber")({}),
    hash2 ? getAction(client, getTransaction, "getTransaction")({ hash: hash2 }) : undefined
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// node_modules/viem/_esm/actions/public/getTransactionReceipt.js
init_transaction();
async function getTransactionReceipt(client, { hash: hash2 }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  }, { dedupe: true });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}

// node_modules/viem/_esm/actions/public/multicall.js
init_abis();
init_abi();
init_base();
init_contract();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
async function multicall(client, parameters) {
  const { account, allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (const { abi: abi2, address, args, functionName } of contracts) {
    try {
      const callData = encodeFunctionData({ abi: abi2, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (error_) {
      const error = getContractError(error_, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName,
        sender: account
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
    abi: multicall3Abi,
    account,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results = [];
  for (const [index_, result] of aggregate3Results.entries()) {
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let index__ = 0;index__ < chunkedCalls[index_].length; index__++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: undefined
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (const [index__, { returnData, success }] of aggregate3Result.entries()) {
      const { callData } = chunkedCalls[index_][index__];
      const { abi: abi2, address, functionName, args } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError;
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi2,
          args,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (error_) {
        const error = getContractError(error_, {
          abi: abi2,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: undefined, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError2("multicall results mismatch");
  return results;
}

// node_modules/viem/_esm/actions/public/simulateBlocks.js
init_BlockOverrides();
init_abi();
init_contract();
init_node();
init_decodeFunctionResult();
init_encodeFunctionData();
init_toHex();
init_getNodeError();
init_transactionRequest();
init_stateOverride2();
init_assertRequest();
async function simulateBlocks(client, parameters) {
  const { blockNumber, blockTag = "latest", blocks, returnFullTransactions, traceTransfers, validation } = parameters;
  try {
    const blockStateCalls = [];
    for (const block2 of blocks) {
      const blockOverrides = block2.blockOverrides ? toRpc2(block2.blockOverrides) : undefined;
      const calls = block2.calls.map((call_) => {
        const call2 = call_;
        const account = call2.account ? parseAccount(call2.account) : undefined;
        const request = {
          ...call2,
          data: call2.abi ? encodeFunctionData(call2) : call2.data,
          from: call2.from ?? account?.address
        };
        assertRequest(request);
        return formatTransactionRequest(request);
      });
      const stateOverrides = block2.stateOverrides ? serializeStateOverride(block2.stateOverrides) : undefined;
      blockStateCalls.push({
        blockOverrides,
        calls,
        stateOverrides
      });
    }
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const result = await client.request({
      method: "eth_simulateV1",
      params: [
        { blockStateCalls, returnFullTransactions, traceTransfers, validation },
        block
      ]
    });
    return result.map((block2, index_) => ({
      ...formatBlock(block2),
      calls: block2.calls.map((call2, index__) => {
        const { abi: abi2, args, functionName, to } = blocks[index_].calls[index__];
        const data = call2.error?.data ?? call2.returnData;
        const gasUsed = BigInt(call2.gasUsed);
        const logs = call2.logs?.map((log) => formatLog(log));
        const status = call2.status === "0x1" ? "success" : "failure";
        const result2 = abi2 && status === "success" && data !== "0x" ? decodeFunctionResult({
          abi: abi2,
          data,
          functionName
        }) : null;
        const error = (() => {
          if (status === "success")
            return;
          let error2;
          if (call2.error?.data === "0x")
            error2 = new AbiDecodingZeroDataError;
          else if (call2.error)
            error2 = new RawContractError(call2.error);
          if (!error2)
            return;
          return getContractError(error2, {
            abi: abi2 ?? [],
            address: to,
            args,
            functionName: functionName ?? "<unknown>"
          });
        })();
        return {
          data,
          gasUsed,
          logs,
          status,
          ...status === "success" ? {
            result: result2
          } : {
            error
          }
        };
      })
    }));
  } catch (error_) {
    const cause = error_;
    const error = getNodeError(cause, {});
    if (error instanceof UnknownNodeError)
      throw cause;
    throw error;
  }
}

// node_modules/ox/_esm/core/AbiItem.js
init_exports();
init_Errors();

// node_modules/ox/_esm/core/Hash.js
init_sha3();
init_Bytes();
init_Hex();
function keccak2562(value, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes(bytes);
}

// node_modules/ox/_esm/core/AbiItem.js
init_Hex();

// node_modules/ox/_esm/core/Address.js
init_Bytes();

// node_modules/ox/_esm/core/internal/lru.js
class LruMap2 extends Map {
  constructor(size5) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.maxSize = size5;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== undefined) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
}

// node_modules/ox/_esm/core/Caches.js
const caches = {
  checksum: /* @__PURE__ */ new LruMap2(8192)
};
const checksum = caches.checksum;

// node_modules/ox/_esm/core/Address.js
init_Errors();
const addressRegex2 = /^0x[\dA-Fa-f]{40}$/;
function assert2(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex2.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert2(address, { strict: false });
  const hexAddress = address.slice(2).toLowerCase();
  const hash2 = keccak2562(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let index_ = 0;index_ < 40; index_ += 2) {
    if (hash2[index_ >> 1] >> 4 >= 8 && characters[index_]) {
      characters[index_] = characters[index_].toUpperCase();
    }
    if ((hash2[index_ >> 1] & 15) >= 8 && characters[index_ + 1]) {
      characters[index_ + 1] = characters[index_ + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
function validate2(address, options = {}) {
  const { strict = true } = options ?? {};
  try {
    assert2(address, { strict });
    return true;
  } catch {
    return false;
  }
}

class InvalidAddressError2 extends BaseError3 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
}

class InvalidInputError extends BaseError3 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
}

class InvalidChecksumError extends BaseError3 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
}

// node_modules/ox/_esm/core/internal/abiItem.js
init_Errors();
function normalizeSignature2(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let index_ = 0;index_ < signature.length; index_++) {
    const char = signature[index_];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", "error", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[index_ - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError3("Unable to normalize signature.");
  return result;
}
function isArgumentOfType2(argument, abiParameter) {
  const argumentType = typeof argument;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address": {
      return validate2(argument, { strict: false });
    }
    case "bool": {
      return argumentType === "boolean";
    }
    case "function": {
      return argumentType === "string";
    }
    case "string": {
      return argumentType === "string";
    }
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgumentOfType2(Object.values(argument)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argumentType === "number" || argumentType === "bigint";
      if (/^bytes([1-9]|1\d|2\d|3[0-2])?$/.test(abiParameterType))
        return argumentType === "string" || argument instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[\d*])+$/.test(abiParameterType)) {
        return Array.isArray(argument) && argument.every((x) => isArgumentOfType2(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[\d*])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes2(sourceParameters, targetParameters, arguments_) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes2(sourceParameter.components, targetParameter.components, arguments_[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return validate2(arguments_[parameterIndex], {
          strict: false
        });
      if (types.includes("address") && types.includes("bytes"))
        return validate2(arguments_[parameterIndex], {
          strict: false
        });
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}

// node_modules/ox/_esm/core/AbiItem.js
function from2(abiItem, options = {}) {
  const { prepare = true } = options;
  const item = (() => {
    if (Array.isArray(abiItem))
      return parseAbiItem(abiItem);
    if (typeof abiItem === "string")
      return parseAbiItem(abiItem);
    return abiItem;
  })();
  return {
    ...item,
    ...prepare ? { hash: getSignatureHash(item) } : {}
  };
}
function fromAbi(abi2, name, options) {
  const { args: arguments_ = [], prepare = true } = options ?? {};
  const isSelector = validate(name, { strict: false });
  const abiItems = abi2.filter((abiItem2) => {
    if (isSelector) {
      if (abiItem2.type === "function" || abiItem2.type === "error")
        return getSelector(abiItem2) === slice2(name, 0, 4);
      if (abiItem2.type === "event")
        return getSignatureHash(abiItem2) === name;
      return false;
    }
    return "name" in abiItem2 && abiItem2.name === name;
  });
  if (abiItems.length === 0)
    throw new NotFoundError({ name });
  if (abiItems.length === 1)
    return {
      ...abiItems[0],
      ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}
    };
  let matchedAbiItem;
  for (const abiItem2 of abiItems) {
    if (!("inputs" in abiItem2))
      continue;
    if (!arguments_ || arguments_.length === 0) {
      if (!abiItem2.inputs || abiItem2.inputs.length === 0)
        return {
          ...abiItem2,
          ...prepare ? { hash: getSignatureHash(abiItem2) } : {}
        };
      continue;
    }
    if (!abiItem2.inputs)
      continue;
    if (abiItem2.inputs.length === 0)
      continue;
    if (abiItem2.inputs.length !== arguments_.length)
      continue;
    const matched = arguments_.every((argument, index2) => {
      const abiParameter = "inputs" in abiItem2 && abiItem2.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgumentOfType2(argument, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes2(abiItem2.inputs, matchedAbiItem.inputs, arguments_);
        if (ambiguousTypes)
          throw new AmbiguityError({
            abiItem: abiItem2,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem2;
    }
  }
  const abiItem = (() => {
    if (matchedAbiItem)
      return matchedAbiItem;
    const [abiItem2, ...overloads] = abiItems;
    return { ...abiItem2, overloads };
  })();
  if (!abiItem)
    throw new NotFoundError({ name });
  return {
    ...abiItem,
    ...prepare ? { hash: getSignatureHash(abiItem) } : {}
  };
}
function getSelector(abiItem) {
  return slice2(getSignatureHash(abiItem), 0, 4);
}
function getSignature(abiItem) {
  const signature = (() => {
    if (typeof abiItem === "string")
      return abiItem;
    return formatAbiItem(abiItem);
  })();
  return normalizeSignature2(signature);
}
function getSignatureHash(abiItem) {
  if (typeof abiItem !== "string" && "hash" in abiItem && abiItem.hash)
    return abiItem.hash;
  return keccak2562(fromString2(getSignature(abiItem)));
}

class AmbiguityError extends BaseError3 {
  constructor(x, y) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        `\`${x.type}\` in \`${normalizeSignature2(formatAbiItem(x.abiItem))}\`, and`,
        `\`${y.type}\` in \`${normalizeSignature2(formatAbiItem(y.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.AmbiguityError"
    });
  }
}

class NotFoundError extends BaseError3 {
  constructor({ name, data, type = "item" }) {
    const selector = (() => {
      if (name)
        return ` with name "${name}"`;
      if (data)
        return ` with data "${data}"`;
      return "";
    })();
    super(`ABI ${type}${selector} not found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.NotFoundError"
    });
  }
}

// node_modules/ox/_esm/core/AbiParameters.js
init_Errors();
init_Hex();

// node_modules/ox/_esm/core/Solidity.js
const arrayRegex = /^(.*)\[(\d*)]$/;
const bytesRegex3 = /^bytes([1-9]|1\d|2\d|3[0-2])?$/;
const integerRegex3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const maxInt82 = 2n ** (8n - 1n) - 1n;
const maxInt162 = 2n ** (16n - 1n) - 1n;
const maxInt242 = 2n ** (24n - 1n) - 1n;
const maxInt322 = 2n ** (32n - 1n) - 1n;
const maxInt402 = 2n ** (40n - 1n) - 1n;
const maxInt482 = 2n ** (48n - 1n) - 1n;
const maxInt562 = 2n ** (56n - 1n) - 1n;
const maxInt642 = 2n ** (64n - 1n) - 1n;
const maxInt722 = 2n ** (72n - 1n) - 1n;
const maxInt802 = 2n ** (80n - 1n) - 1n;
const maxInt882 = 2n ** (88n - 1n) - 1n;
const maxInt962 = 2n ** (96n - 1n) - 1n;
const maxInt1042 = 2n ** (104n - 1n) - 1n;
const maxInt1122 = 2n ** (112n - 1n) - 1n;
const maxInt1202 = 2n ** (120n - 1n) - 1n;
const maxInt1282 = 2n ** (128n - 1n) - 1n;
const maxInt1362 = 2n ** (136n - 1n) - 1n;
const maxInt1442 = 2n ** (144n - 1n) - 1n;
const maxInt1522 = 2n ** (152n - 1n) - 1n;
const maxInt1602 = 2n ** (160n - 1n) - 1n;
const maxInt1682 = 2n ** (168n - 1n) - 1n;
const maxInt1762 = 2n ** (176n - 1n) - 1n;
const maxInt1842 = 2n ** (184n - 1n) - 1n;
const maxInt1922 = 2n ** (192n - 1n) - 1n;
const maxInt2002 = 2n ** (200n - 1n) - 1n;
const maxInt2082 = 2n ** (208n - 1n) - 1n;
const maxInt2162 = 2n ** (216n - 1n) - 1n;
const maxInt2242 = 2n ** (224n - 1n) - 1n;
const maxInt2322 = 2n ** (232n - 1n) - 1n;
const maxInt2402 = 2n ** (240n - 1n) - 1n;
const maxInt2482 = 2n ** (248n - 1n) - 1n;
const maxInt2562 = 2n ** (256n - 1n) - 1n;
const minInt82 = -(2n ** (8n - 1n));
const minInt162 = -(2n ** (16n - 1n));
const minInt242 = -(2n ** (24n - 1n));
const minInt322 = -(2n ** (32n - 1n));
const minInt402 = -(2n ** (40n - 1n));
const minInt482 = -(2n ** (48n - 1n));
const minInt562 = -(2n ** (56n - 1n));
const minInt642 = -(2n ** (64n - 1n));
const minInt722 = -(2n ** (72n - 1n));
const minInt802 = -(2n ** (80n - 1n));
const minInt882 = -(2n ** (88n - 1n));
const minInt962 = -(2n ** (96n - 1n));
const minInt1042 = -(2n ** (104n - 1n));
const minInt1122 = -(2n ** (112n - 1n));
const minInt1202 = -(2n ** (120n - 1n));
const minInt1282 = -(2n ** (128n - 1n));
const minInt1362 = -(2n ** (136n - 1n));
const minInt1442 = -(2n ** (144n - 1n));
const minInt1522 = -(2n ** (152n - 1n));
const minInt1602 = -(2n ** (160n - 1n));
const minInt1682 = -(2n ** (168n - 1n));
const minInt1762 = -(2n ** (176n - 1n));
const minInt1842 = -(2n ** (184n - 1n));
const minInt1922 = -(2n ** (192n - 1n));
const minInt2002 = -(2n ** (200n - 1n));
const minInt2082 = -(2n ** (208n - 1n));
const minInt2162 = -(2n ** (216n - 1n));
const minInt2242 = -(2n ** (224n - 1n));
const minInt2322 = -(2n ** (232n - 1n));
const minInt2402 = -(2n ** (240n - 1n));
const minInt2482 = -(2n ** (248n - 1n));
const minInt2562 = -(2n ** (256n - 1n));
const maxUint82 = 2n ** 8n - 1n;
const maxUint162 = 2n ** 16n - 1n;
const maxUint242 = 2n ** 24n - 1n;
const maxUint322 = 2n ** 32n - 1n;
const maxUint402 = 2n ** 40n - 1n;
const maxUint482 = 2n ** 48n - 1n;
const maxUint562 = 2n ** 56n - 1n;
const maxUint642 = 2n ** 64n - 1n;
const maxUint722 = 2n ** 72n - 1n;
const maxUint802 = 2n ** 80n - 1n;
const maxUint882 = 2n ** 88n - 1n;
const maxUint962 = 2n ** 96n - 1n;
const maxUint1042 = 2n ** 104n - 1n;
const maxUint1122 = 2n ** 112n - 1n;
const maxUint1202 = 2n ** 120n - 1n;
const maxUint1282 = 2n ** 128n - 1n;
const maxUint1362 = 2n ** 136n - 1n;
const maxUint1442 = 2n ** 144n - 1n;
const maxUint1522 = 2n ** 152n - 1n;
const maxUint1602 = 2n ** 160n - 1n;
const maxUint1682 = 2n ** 168n - 1n;
const maxUint1762 = 2n ** 176n - 1n;
const maxUint1842 = 2n ** 184n - 1n;
const maxUint1922 = 2n ** 192n - 1n;
const maxUint2002 = 2n ** 200n - 1n;
const maxUint2082 = 2n ** 208n - 1n;
const maxUint2162 = 2n ** 216n - 1n;
const maxUint2242 = 2n ** 224n - 1n;
const maxUint2322 = 2n ** 232n - 1n;
const maxUint2402 = 2n ** 240n - 1n;
const maxUint2482 = 2n ** 248n - 1n;
const maxUint2562 = 2n ** 256n - 1n;

// node_modules/ox/_esm/core/internal/abiParameters.js
init_Errors();
init_Hex();
function prepareParameters({ checksumAddress: checksumAddress2, parameters, values }) {
  const preparedParameters = [];
  for (const [index_, parameter] of parameters.entries()) {
    preparedParameters.push(prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: parameter,
      value: values[index_]
    }));
  }
  return preparedParameters;
}
function prepareParameter({ checksumAddress: checksumAddress2 = false, parameter: parameter_, value }) {
  const parameter = parameter_;
  const arrayComponents = getArrayComponents2(parameter.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray2(value, {
      checksumAddress: checksumAddress2,
      length,
      parameter: {
        ...parameter,
        type
      }
    });
  }
  if (parameter.type === "tuple") {
    return encodeTuple2(value, {
      checksumAddress: checksumAddress2,
      parameter
    });
  }
  if (parameter.type === "address") {
    return encodeAddress2(value, {
      checksum: checksumAddress2
    });
  }
  if (parameter.type === "bool") {
    return encodeBoolean(value);
  }
  if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
    const signed = parameter.type.startsWith("int");
    const [, , size5 = "256"] = integerRegex3.exec(parameter.type) ?? [];
    return encodeNumber2(value, {
      signed,
      size: Number(size5)
    });
  }
  if (parameter.type.startsWith("bytes")) {
    return encodeBytes2(value, { type: parameter.type });
  }
  if (parameter.type === "string") {
    return encodeString2(value);
  }
  throw new InvalidTypeError(parameter.type);
}
function encode(preparedParameters) {
  let staticSize = 0;
  for (const { dynamic, encoded } of preparedParameters) {
    staticSize += dynamic ? 32 : size3(encoded);
  }
  const staticParameters = [];
  const dynamicParameters = [];
  let dynamicSize = 0;
  for (const { dynamic, encoded } of preparedParameters) {
    if (dynamic) {
      staticParameters.push(fromNumber(staticSize + dynamicSize, { size: 32 }));
      dynamicParameters.push(encoded);
      dynamicSize += size3(encoded);
    } else {
      staticParameters.push(encoded);
    }
  }
  return concat2(...staticParameters, ...dynamicParameters);
}
function encodeAddress2(value, options) {
  const { checksum: checksum3 = false } = options;
  assert2(value, { strict: checksum3 });
  return {
    dynamic: false,
    encoded: padLeft(value.toLowerCase())
  };
}
function encodeArray2(value, options) {
  const { checksumAddress: checksumAddress2, length, parameter } = options;
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError2(value);
  if (!dynamic && value.length !== length)
    throw new ArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${parameter.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParameters = [];
  for (const element of value) {
    const preparedParameter = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter,
      value: element
    });
    if (preparedParameter.dynamic)
      dynamicChild = true;
    preparedParameters.push(preparedParameter);
  }
  if (dynamic || dynamicChild) {
    const data = encode(preparedParameters);
    if (dynamic) {
      const length2 = fromNumber(preparedParameters.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParameters.length > 0 ? concat2(length2, data) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat2(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function encodeBytes2(value, { type }) {
  const [, parametersize] = type.split("bytes");
  const bytesSize = size3(value);
  if (!parametersize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
    return {
      dynamic: true,
      encoded: concat2(padLeft(fromNumber(bytesSize, { size: 32 })), value_)
    };
  }
  if (bytesSize !== Number.parseInt(parametersize))
    throw new BytesSizeMismatchError2({
      expectedSize: Number.parseInt(parametersize),
      value
    });
  return { dynamic: false, encoded: padRight(value) };
}
function encodeBoolean(value) {
  if (typeof value !== "boolean")
    throw new BaseError3(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padLeft(fromBoolean(value)) };
}
function encodeNumber2(value, { signed, size: size5 }) {
  if (typeof size5 === "number") {
    const max = 2n ** (BigInt(size5) - (signed ? 1n : 0n)) - 1n;
    const min = signed ? -max - 1n : 0n;
    if (value > max || value < min)
      throw new IntegerOutOfRangeError2({
        max: max.toString(),
        min: min.toString(),
        signed,
        size: size5 / 8,
        value: value.toString()
      });
  }
  return {
    dynamic: false,
    encoded: fromNumber(value, {
      size: 32,
      signed
    })
  };
}
function encodeString2(value) {
  const hexValue = fromString2(value);
  const partsLength = Math.ceil(size3(hexValue) / 32);
  const parts = [];
  for (let index_ = 0;index_ < partsLength; index_++) {
    parts.push(padRight(slice2(hexValue, index_ * 32, (index_ + 1) * 32)));
  }
  return {
    dynamic: true,
    encoded: concat2(padRight(fromNumber(size3(hexValue), { size: 32 })), ...parts)
  };
}
function encodeTuple2(value, options) {
  const { checksumAddress: checksumAddress2, parameter } = options;
  let dynamic = false;
  const preparedParameters = [];
  for (let index_ = 0;index_ < parameter.components.length; index_++) {
    const parameter_ = parameter.components[index_];
    const index2 = Array.isArray(value) ? index_ : parameter_.name;
    const preparedParameter = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: parameter_,
      value: value[index2]
    });
    preparedParameters.push(preparedParameter);
    if (preparedParameter.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encode(preparedParameters) : concat2(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function getArrayComponents2(type) {
  const matches = type.match(/^(.*)\[(\d+)?]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}

// node_modules/ox/_esm/core/AbiParameters.js
function encode2(parameters, values, options) {
  const { checksumAddress: checksumAddress2 = false } = options ?? {};
  if (parameters.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: parameters.length,
      givenLength: values.length
    });
  const preparedParameters = prepareParameters({
    checksumAddress: checksumAddress2,
    parameters,
    values
  });
  const data = encode(preparedParameters);
  if (data.length === 0)
    return "0x";
  return data;
}
function encodePacked(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (const [index_, type] of types.entries()) {
    const value = values[index_];
    data.push(encodePacked.encode(type, value));
  }
  return concat2(...data);
}
(function(encodePacked2) {
  function encode3(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert2(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString2(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex3);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size5 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size5,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex3);
    if (bytesMatch) {
      const [_type, size5] = bytesMatch;
      if (Number.parseInt(size5) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size5),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (const element of value) {
        data.push(encode3(childType, element, true));
      }
      if (data.length === 0)
        return "0x";
      return concat2(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked2.encode = encode3;
})(encodePacked || (encodePacked = {}));
class ArrayLengthMismatchError extends BaseError3 {
  constructor({ expectedLength, givenLength, type }) {
    super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
}

class BytesSizeMismatchError2 extends BaseError3 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
}

class LengthMismatchError extends BaseError3 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join(`
`));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
}

class InvalidArrayError2 extends BaseError3 {
  constructor(value) {
    super(`Value \`${value}\` is not a valid array.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidArrayError"
    });
  }
}

class InvalidTypeError extends BaseError3 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
}

// node_modules/ox/_esm/core/AbiConstructor.js
init_Hex();
function encode3(abiConstructor, options) {
  const { bytecode, args } = options;
  return concat2(bytecode, abiConstructor.inputs?.length && args?.length ? encode2(abiConstructor.inputs, args) : "0x");
}
function from3(abiConstructor) {
  return from2(abiConstructor);
}

// node_modules/ox/_esm/core/AbiFunction.js
init_Hex();
function encodeData2(abiFunction, ...arguments_) {
  const { overloads } = abiFunction;
  const item = overloads ? fromAbi2([abiFunction, ...overloads], abiFunction.name, {
    args: arguments_[0]
  }) : abiFunction;
  const selector = getSelector2(item);
  const data = arguments_.length > 0 ? encode2(item.inputs, arguments_[0]) : undefined;
  return data ? concat2(selector, data) : selector;
}
function from4(abiFunction, options = {}) {
  return from2(abiFunction, options);
}
function fromAbi2(abi2, name, options) {
  const item = fromAbi(abi2, name, options);
  if (item.type !== "function")
    throw new NotFoundError({ name, type: "function" });
  return item;
}
function getSelector2(abiItem) {
  return getSelector(abiItem);
}
// node_modules/viem/_esm/constants/address.js
const ethAddress = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
const zeroAddress = "0x0000000000000000000000000000000000000000";

// node_modules/viem/_esm/actions/public/simulateCalls.js
init_base();
init_encodeFunctionData();
const getBalanceCode = "0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";
async function simulateCalls(client, parameters) {
  const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation } = parameters;
  const account = parameters.account ? parseAccount(parameters.account) : undefined;
  if (traceAssetChanges && !account)
    throw new BaseError2("`account` is required when `traceAssetChanges` is true");
  const getBalanceData = account ? encode3(from3("constructor(bytes, bytes)"), {
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [
      getBalanceCode,
      encodeData2(from4("function getBalance(address)"), [account.address])
    ]
  }) : undefined;
  const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async (call2) => {
    if (!call2.data && !call2.abi)
      return;
    const { accessList } = await createAccessList(client, {
      account: account.address,
      ...call2,
      data: call2.abi ? encodeFunctionData(call2) : call2.data
    });
    return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);
  })).then((x) => x.flat().filter(Boolean)) : [];
  const resultsStateOverrides = stateOverrides?.map((override) => {
    if (override.address === account?.address)
      return {
        ...override,
        nonce: 0
      };
    return override;
  });
  const blocks = await simulateBlocks(client, {
    blockNumber,
    blockTag,
    blocks: [
      ...traceAssetChanges ? [
        {
          calls: [{ data: getBalanceData }],
          stateOverrides
        },
        {
          calls: assetAddresses.map((address, index_) => ({
            abi: [
              from4("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [account.address],
            to: address,
            from: zeroAddress,
            nonce: index_
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        }
      ] : [],
      {
        calls: [...calls, {}].map((call2, index2) => ({
          ...call2,
          from: account?.address,
          nonce: index2
        })),
        stateOverrides: resultsStateOverrides
      },
      ...traceAssetChanges ? [
        {
          calls: [{ data: getBalanceData }]
        },
        {
          calls: assetAddresses.map((address, index_) => ({
            abi: [
              from4("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [account.address],
            to: address,
            from: zeroAddress,
            nonce: index_
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        {
          calls: assetAddresses.map((address, index_) => ({
            to: address,
            abi: [
              from4("function decimals() returns (uint256)")
            ],
            functionName: "decimals",
            from: zeroAddress,
            nonce: index_
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        {
          calls: assetAddresses.map((address, index_) => ({
            to: address,
            abi: [
              from4("function tokenURI(uint256) returns (string)")
            ],
            functionName: "tokenURI",
            args: [0n],
            from: zeroAddress,
            nonce: index_
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        {
          calls: assetAddresses.map((address, index_) => ({
            to: address,
            abi: [from4("function symbol() returns (string)")],
            functionName: "symbol",
            from: zeroAddress,
            nonce: index_
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        }
      ] : []
    ],
    traceTransfers,
    validation
  });
  const block_results = traceAssetChanges ? blocks[2] : blocks[0];
  const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];
  const { calls: block_calls, ...block } = block_results;
  const results = block_calls.slice(0, -1) ?? [];
  const ethPre = block_ethPre?.calls ?? [];
  const assetsPre = block_assetsPre?.calls ?? [];
  const balancesPre = [...ethPre, ...assetsPre].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
  const ethPost = block_ethPost?.calls ?? [];
  const assetsPost = block_assetsPost?.calls ?? [];
  const balancesPost = [...ethPost, ...assetsPost].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
  const decimals = (block_decimals?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
  const symbols = (block_symbols?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
  const tokenURI = (block_tokenURI?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
  const changes = [];
  for (const [index_, balancePost] of balancesPost.entries()) {
    const balancePre = balancesPre[index_];
    if (typeof balancePost !== "bigint")
      continue;
    if (typeof balancePre !== "bigint")
      continue;
    const decimals_ = decimals[index_ - 1];
    const symbol_ = symbols[index_ - 1];
    const tokenURI_ = tokenURI[index_ - 1];
    const token = (() => {
      if (index_ === 0)
        return {
          address: ethAddress,
          decimals: 18,
          symbol: "ETH"
        };
      return {
        address: assetAddresses[index_ - 1],
        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,
        symbol: symbol_ ?? undefined
      };
    })();
    if (changes.some((change) => change.token.address === token.address))
      continue;
    changes.push({
      token,
      value: {
        pre: balancePre,
        post: balancePost,
        diff: balancePost - balancePre
      }
    });
  }
  return {
    assetChanges: changes,
    block,
    results
  };
}

// node_modules/viem/_esm/actions/public/verifyHash.js
init_abis();
init_contract();
init_encodeDeployData();
init_getAddress();
init_isAddressEqual();
init_toHex();

// node_modules/viem/_esm/utils/signature/serializeSignature.js
init_secp256k1();
init_fromHex();
init_toBytes();
function serializeSignature({ r, s, to = "hex", v, yParity }) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n))
      return v % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
  if (to === "hex")
    return signature;
  return hexToBytes(signature);
}

// node_modules/viem/_esm/actions/public/verifyHash.js
init_call();
async function verifyHash(client, parameters) {
  const { address, factory, factoryData, hash: hash2, signature, universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address, ...rest } = parameters;
  const signatureHex = (() => {
    if (isHex(signature))
      return signature;
    if (typeof signature === "object" && "r" in signature && "s" in signature)
      return serializeSignature(signature);
    return bytesToHex(signature);
  })();
  const wrappedSignature = await (async () => {
    if (!factory && !factoryData)
      return signatureHex;
    if (isErc6492Signature(signatureHex))
      return signatureHex;
    return serializeErc6492Signature({
      address: factory,
      data: factoryData,
      signature: signatureHex
    });
  })();
  try {
    const arguments_ = universalSignatureVerifierAddress ? {
      to: universalSignatureVerifierAddress,
      data: encodeFunctionData({
        abi: universalSignatureValidatorAbi,
        functionName: "isValidSig",
        args: [address, hash2, wrappedSignature]
      }),
      ...rest
    } : {
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash2, wrappedSignature],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...rest
    };
    const { data } = await getAction(client, call, "call")(arguments_);
    return hexToBool(data ?? "0x0");
  } catch (error) {
    try {
      const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash: hash2, signature }));
      if (verified)
        return true;
    } catch {}
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}

// node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {
  const hash2 = hashMessage(message);
  return verifyHash(client, {
    address,
    factory,
    factoryData,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData(client, parameters) {
  const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
  const hash2 = hashTypedData({ message, primaryType, types, domain });
  return verifyHash(client, {
    address,
    factory,
    factoryData,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
init_transaction();
// node_modules/viem/_esm/actions/public/watchBlockNumber.js
init_fromHex();
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (poll_ !== undefined)
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  let previousBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (previousBlockNumber) {
          if (blockNumber === previousBlockNumber)
            return;
          if (blockNumber - previousBlockNumber > 1 && emitMissed) {
            for (let index_ = previousBlockNumber + 1n;index_ < blockNumber; index_++) {
              emit.onBlockNumber(index_, previousBlockNumber);
              previousBlockNumber = index_;
            }
          }
        }
        if (!previousBlockNumber || blockNumber > previousBlockNumber) {
          emit.onBlockNumber(blockNumber, previousBlockNumber);
          previousBlockNumber = blockNumber;
        }
      } catch (error) {
        emit.onError?.(error);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              if (!active)
                return;
              const blockNumber = hexToBigInt(data.result?.number);
              emit.onBlockNumber(blockNumber, previousBlockNumber);
              previousBlockNumber = blockNumber;
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (error) {
          onError?.(error);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, {
  confirmations = 1,
  hash: hash2,
  onReplaced,
  pollingInterval = client.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count }) => Math.trunc(1 << count) * 200,
  timeout = 180_000
}) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash2]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  const { promise, resolve, reject } = withResolvers();
  const timer = timeout ? setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout) : undefined;
  const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
    const _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
      emitMissed: true,
      emitOnBegin: true,
      poll: true,
      pollingInterval,
      async onBlockNumber(blockNumber_) {
        const done = (function_) => {
          clearTimeout(timer);
          _unwatch();
          function_();
          _unobserve();
        };
        let blockNumber = blockNumber_;
        if (retrying)
          return;
        try {
          if (receipt) {
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
            return;
          }
          if (!transaction) {
            retrying = true;
            await withRetry(async () => {
              transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash2 });
              if (transaction.blockNumber)
                blockNumber = transaction.blockNumber;
            }, {
              delay: retryDelay,
              retryCount
            });
            retrying = false;
          }
          receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
            return;
          done(() => emit.resolve(receipt));
        } catch (error) {
          if (error instanceof TransactionNotFoundError || error instanceof TransactionReceiptNotFoundError) {
            if (!transaction) {
              retrying = false;
              return;
            }
            try {
              replacedTransaction = transaction;
              retrying = true;
              const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                blockNumber,
                includeTransactions: true
              }), {
                delay: retryDelay,
                retryCount,
                shouldRetry: ({ error }) => error instanceof BlockNotFoundError
              });
              retrying = false;
              const replacementTransaction = block.transactions.find(({ from: from5, nonce }) => from5 === replacedTransaction.from && nonce === replacedTransaction.nonce);
              if (!replacementTransaction)
                return;
              receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                hash: replacementTransaction.hash
              });
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              let reason = "replaced";
              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {
                reason = "repriced";
              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                reason = "cancelled";
              }
              done(() => {
                emit.onReplaced?.({
                  reason,
                  replacedTransaction,
                  transaction: replacementTransaction,
                  transactionReceipt: receipt
                });
                emit.resolve(receipt);
              });
            } catch (error_) {
              done(() => emit.reject(error_));
            }
          } else {
            done(() => emit.reject(error));
          }
        }
      }
    });
  });
  return promise;
}
// node_modules/viem/_esm/actions/public/watchBlocks.js
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (poll_ !== undefined)
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const includeTransactions = includeTransactions_ ?? false;
  let previousBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      try {
        const block = await getAction(client, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number !== null && previousBlock?.number != undefined) {
          if (block.number === previousBlock.number)
            return;
          if (block.number - previousBlock.number > 1 && emitMissed) {
            for (let index_ = previousBlock?.number + 1n;index_ < block.number; index_++) {
              const block2 = await getAction(client, getBlock, "getBlock")({
                blockNumber: index_,
                includeTransactions
              });
              emit.onBlock(block2, previousBlock);
              previousBlock = block2;
            }
          }
        }
        if (previousBlock?.number == undefined || blockTag === "pending" && block?.number == undefined || block.number !== null && block.number > previousBlock.number) {
          emit.onBlock(block, previousBlock);
          previousBlock = block;
        }
      } catch (error) {
        emit.onError?.(error);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let emitFetched = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        if (emitOnBegin) {
          getAction(client, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          }).then((block) => {
            if (!active)
              return;
            if (!emitFetched)
              return;
            onBlock(block);
            emitFetched = false;
          });
        }
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["newHeads"],
          async onData(data) {
            if (!active)
              return;
            const block = await getAction(client, getBlock, "getBlock")({
              blockNumber: data.blockNumber,
              includeTransactions
            }).catch(() => {});
            if (!active)
              return;
            onBlock(block, previousBlock);
            emitFetched = false;
            previousBlock = block;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (error) {
        onError?.(error);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// node_modules/viem/_esm/actions/public/watchEvent.js
init_abi();
init_rpc();
function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = (() => {
    if (poll_ !== undefined)
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== undefined)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events,
              strict,
              fromBlock
            });
          } catch {}
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            logs = previousBlockNumber && previousBlockNumber !== blockNumber ? (await getAction(client, getLogs, "getLogs")({
                address,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              })) : [];
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (error) {
          if (filter && error instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(error);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const events_ = events ?? (event ? [event] : undefined);
        let topics = [];
        if (events_) {
          const encoded = events_.flatMap((event2) => encodeEventTopics({
            abi: [event2],
            eventName: event2.name,
            args
          }));
          topics = [encoded];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: arguments2 } = decodeEventLog({
                abi: events_ ?? [],
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, { args: arguments2, eventName });
              onLogs([formatted]);
            } catch (error) {
              let eventName;
              let isUnnamed;
              if (error instanceof DecodeLogDataMismatch || error instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = error.abiItem.name;
                isUnnamed = error.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (error) {
        onError?.(error);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
// node_modules/viem/_esm/actions/public/watchPendingTransactions.js
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = poll_ === undefined ? client.transport.type !== "webSocket" : poll_;
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter;
      const unwatch = poll(async () => {
        try {
          if (!filter) {
            try {
              filter = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (error) {
              unwatch();
              throw error;
            }
          }
          const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit.onTransactions([hash2]);
        } catch (error) {
          emit.onError?.(error);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (error) {
        onError?.(error);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
function parseSiweMessage(message) {
  const { scheme, statement, ...prefix } = message.match(prefixRegex)?.groups ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = message.match(suffixRegex)?.groups ?? {};
  const resources = message.split("Resources:")[1]?.split(`
- `).slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
var prefixRegex = /^(?:(?<scheme>[A-Za-z][\d+-.A-Za-z]*):\/\/)?(?<domain>[\d+-.A-Za-z]*(?::\d{1,5})?) wants you to sign in with your Ethereum account:\n(?<address>0x[\dA-Fa-f]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /URI: (?<uri>.+)\nVersion: (?<version>.+)\nChain ID: (?<chainId>\d+)\nNonce: (?<nonce>[\dA-Za-z]+)\nIs{2}ued At: (?<issuedAt>.+)(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

// node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
init_isAddress();
init_isAddressEqual();
function validateSiweMessage(parameters) {
  const { address, domain, message, nonce, scheme, time = new Date } = parameters;
  if (domain && message.domain !== domain)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time >= message.expirationTime)
    return false;
  if (message.notBefore && time < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (!isAddress(message.address, { strict: false }))
      return false;
    if (address && !isAddressEqual(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}

// node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
async function verifySiweMessage(client, parameters) {
  const { address, domain, message, nonce, scheme, signature, time = new Date, ...callRequest } = parameters;
  const parsed = parseSiweMessage(message);
  if (!parsed.address)
    return false;
  const isValid = validateSiweMessage({
    address,
    domain,
    message: parsed,
    nonce,
    scheme,
    time
  });
  if (!isValid)
    return false;
  const hash2 = hashMessage(message);
  return verifyHash(client, {
    address: parsed.address,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (arguments_) => call(client, arguments_),
    createAccessList: (arguments_) => createAccessList(client, arguments_),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (arguments_) => createContractEventFilter(client, arguments_),
    createEventFilter: (arguments_) => createEventFilter(client, arguments_),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (arguments_) => estimateContractGas(client, arguments_),
    estimateGas: (arguments_) => estimateGas(client, arguments_),
    getBalance: (arguments_) => getBalance(client, arguments_),
    getBlobBaseFee: () => getBlobBaseFee(client),
    getBlock: (arguments_) => getBlock(client, arguments_),
    getBlockNumber: (arguments_) => getBlockNumber(client, arguments_),
    getBlockTransactionCount: (arguments_) => getBlockTransactionCount(client, arguments_),
    getBytecode: (arguments_) => getCode(client, arguments_),
    getChainId: () => getChainId(client),
    getCode: (arguments_) => getCode(client, arguments_),
    getContractEvents: (arguments_) => getContractEvents(client, arguments_),
    getEip712Domain: (arguments_) => getEip712Domain(client, arguments_),
    getEnsAddress: (arguments_) => getEnsAddress(client, arguments_),
    getEnsAvatar: (arguments_) => getEnsAvatar(client, arguments_),
    getEnsName: (arguments_) => getEnsName(client, arguments_),
    getEnsResolver: (arguments_) => getEnsResolver(client, arguments_),
    getEnsText: (arguments_) => getEnsText(client, arguments_),
    getFeeHistory: (arguments_) => getFeeHistory(client, arguments_),
    estimateFeesPerGas: (arguments_) => estimateFeesPerGas(client, arguments_),
    getFilterChanges: (arguments_) => getFilterChanges(client, arguments_),
    getFilterLogs: (arguments_) => getFilterLogs(client, arguments_),
    getGasPrice: () => getGasPrice(client),
    getLogs: (arguments_) => getLogs(client, arguments_),
    getProof: (arguments_) => getProof(client, arguments_),
    estimateMaxPriorityFeePerGas: (arguments_) => estimateMaxPriorityFeePerGas(client, arguments_),
    getStorageAt: (arguments_) => getStorageAt(client, arguments_),
    getTransaction: (arguments_) => getTransaction(client, arguments_),
    getTransactionConfirmations: (arguments_) => getTransactionConfirmations(client, arguments_),
    getTransactionCount: (arguments_) => getTransactionCount(client, arguments_),
    getTransactionReceipt: (arguments_) => getTransactionReceipt(client, arguments_),
    multicall: (arguments_) => multicall(client, arguments_),
    prepareTransactionRequest: (arguments_) => prepareTransactionRequest(client, arguments_),
    readContract: (arguments_) => readContract(client, arguments_),
    sendRawTransaction: (arguments_) => sendRawTransaction(client, arguments_),
    simulate: (arguments_) => simulateBlocks(client, arguments_),
    simulateBlocks: (arguments_) => simulateBlocks(client, arguments_),
    simulateCalls: (arguments_) => simulateCalls(client, arguments_),
    simulateContract: (arguments_) => simulateContract(client, arguments_),
    verifyMessage: (arguments_) => verifyMessage(client, arguments_),
    verifySiweMessage: (arguments_) => verifySiweMessage(client, arguments_),
    verifyTypedData: (arguments_) => verifyTypedData(client, arguments_),
    uninstallFilter: (arguments_) => uninstallFilter(client, arguments_),
    waitForTransactionReceipt: (arguments_) => waitForTransactionReceipt(client, arguments_),
    watchBlocks: (arguments_) => watchBlocks(client, arguments_),
    watchBlockNumber: (arguments_) => watchBlockNumber(client, arguments_),
    watchContractEvent: (arguments_) => watchContractEvent(client, arguments_),
    watchEvent: (arguments_) => watchEvent(client, arguments_),
    watchPendingTransactions: (arguments_) => watchPendingTransactions(client, arguments_)
  };
}

// node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}
// node_modules/viem/_esm/actions/wallet/addChain.js
init_toHex();
async function addChain(client, { chain }) {
  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
  await client.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id),
        chainName: name,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : undefined
      }
    ]
  }, { dedupe: true, retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/deployContract.js
init_encodeDeployData();
function deployContract(walletClient, parameters) {
  const { abi: abi2, args, bytecode, ...request } = parameters;
  const calldata = encodeDeployData({ abi: abi2, args, bytecode });
  return sendTransaction(walletClient, {
    ...request,
    ...request.authorizationList ? { to: null } : {},
    data: calldata
  });
}

// node_modules/viem/_esm/actions/wallet/getAddresses.js
init_getAddress();
async function getAddresses(client) {
  if (client.account?.type === "local")
    return [client.account.address];
  const addresses = await client.request({ method: "eth_accounts" }, { dedupe: true });
  return addresses.map((address) => checksumAddress(address));
}

// node_modules/viem/_esm/actions/wallet/getCapabilities.js
init_toHex();
async function getCapabilities(client, parameters = {}) {
  const { account = client.account, chainId } = parameters;
  const account_ = account ? parseAccount(account) : undefined;
  const parameters_ = chainId ? [account_?.address, [numberToHex(chainId)]] : [account_?.address];
  const capabilities_raw = await client.request({
    method: "wallet_getCapabilities",
    params: parameters_
  });
  const capabilities = {};
  for (const [chainId2, capabilities_] of Object.entries(capabilities_raw)) {
    capabilities[Number(chainId2)] = {};
    for (let [key, value] of Object.entries(capabilities_)) {
      if (key === "addSubAccount")
        key = "unstable_addSubAccount";
      capabilities[Number(chainId2)][key] = value;
    }
  }
  return typeof chainId === "number" ? capabilities[chainId] : capabilities;
}

// node_modules/viem/_esm/actions/wallet/getPermissions.js
async function getPermissions(client) {
  const permissions = await client.request({ method: "wallet_getPermissions" }, { dedupe: true });
  return permissions;
}
// node_modules/viem/_esm/actions/wallet/prepareAuthorization.js
init_isAddressEqual();
async function prepareAuthorization(client, parameters) {
  const { account: account_ = client.account, chainId, nonce } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/eip7702/prepareAuthorization"
    });
  const account = parseAccount(account_);
  const executor = (() => {
    if (!parameters.executor)
      return;
    if (parameters.executor === "self")
      return parameters.executor;
    return parseAccount(parameters.executor);
  })();
  const authorization = {
    address: parameters.contractAddress ?? parameters.address,
    chainId,
    nonce
  };
  if (authorization.chainId === undefined)
    authorization.chainId = client.chain?.id ?? await getAction(client, getChainId, "getChainId")({});
  if (authorization.nonce === undefined) {
    authorization.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
      address: account.address,
      blockTag: "pending"
    });
    if (executor === "self" || executor?.address && isAddressEqual(executor.address, account.address))
      authorization.nonce += 1;
  }
  return authorization;
}

// node_modules/viem/_esm/actions/wallet/requestAddresses.js
init_getAddress();
async function requestAddresses(client) {
  const addresses = await client.request({ method: "eth_requestAccounts" }, { dedupe: true, retryCount: 0 });
  return addresses.map((address) => getAddress(address));
}

// node_modules/viem/_esm/actions/wallet/requestPermissions.js
async function requestPermissions(client, permissions) {
  return client.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/showCallsStatus.js
async function showCallsStatus(client, parameters) {
  const { id } = parameters;
  await client.request({
    method: "wallet_showCallsStatus",
    params: [id]
  });
  return;
}
// node_modules/viem/_esm/actions/wallet/signAuthorization.js
async function signAuthorization(client, parameters) {
  const { account: account_ = client.account } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/eip7702/signAuthorization"
    });
  const account = parseAccount(account_);
  if (!account.signAuthorization)
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/eip7702/signAuthorization",
      metaMessages: [
        "The `signAuthorization` Action does not support JSON-RPC Accounts."
      ],
      type: account.type
    });
  const authorization = await prepareAuthorization(client, parameters);
  return account.signAuthorization(authorization);
}
// node_modules/viem/_esm/actions/wallet/signMessage.js
init_toHex();
async function signMessage(client, { account: account_ = client.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  if (account.signMessage)
    return account.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex(message.raw);
    return message.raw;
  })();
  return client.request({
    method: "personal_sign",
    params: [message_, account.address]
  }, { retryCount: 0 });
}
// node_modules/viem/_esm/actions/wallet/signTransaction.js
init_toHex();
init_transactionRequest();
init_assertRequest();
async function signTransaction(client, parameters) {
  const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account = parseAccount(account_);
  assertRequest({
    account,
    ...parameters
  });
  const chainId = await getAction(client, getChainId, "getChainId")({});
  if (chain !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain
    });
  const formatters = chain?.formatters || client.chain?.formatters;
  const format = formatters?.transactionRequest?.format || formatTransactionRequest;
  if (account.signTransaction)
    return account.signTransaction({
      ...transaction,
      chainId
    }, { serializer: client.chain?.serializers?.transaction });
  return await client.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format(transaction),
        chainId: numberToHex(chainId),
        from: account.address
      }
    ]
  }, { retryCount: 0 });
}
// node_modules/viem/_esm/actions/wallet/signTypedData.js
async function signTypedData(client, parameters) {
  const { account: account_ = client.account, domain, message, primaryType } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account = parseAccount(account_);
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({ domain, message, primaryType, types });
  if (account.signTypedData)
    return account.signTypedData({ domain, message, primaryType, types });
  const typedData = serializeTypedData({ domain, message, primaryType, types });
  return client.request({
    method: "eth_signTypedData_v4",
    params: [account.address, typedData]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/switchChain.js
init_toHex();
async function switchChain(client, { id }) {
  await client.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id)
      }
    ]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/watchAsset.js
async function watchAsset(client, parameters) {
  const added = await client.request({
    method: "wallet_watchAsset",
    params: parameters
  }, { retryCount: 0 });
  return added;
}

// node_modules/viem/_esm/clients/decorators/wallet.js
function walletActions(client) {
  return {
    addChain: (arguments_) => addChain(client, arguments_),
    deployContract: (arguments_) => deployContract(client, arguments_),
    getAddresses: () => getAddresses(client),
    getCallsStatus: (arguments_) => getCallsStatus(client, arguments_),
    getCapabilities: (arguments_) => getCapabilities(client, arguments_),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    prepareAuthorization: (arguments_) => prepareAuthorization(client, arguments_),
    prepareTransactionRequest: (arguments_) => prepareTransactionRequest(client, arguments_),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (arguments_) => requestPermissions(client, arguments_),
    sendCalls: (arguments_) => sendCalls(client, arguments_),
    sendRawTransaction: (arguments_) => sendRawTransaction(client, arguments_),
    sendTransaction: (arguments_) => sendTransaction(client, arguments_),
    showCallsStatus: (arguments_) => showCallsStatus(client, arguments_),
    signAuthorization: (arguments_) => signAuthorization(client, arguments_),
    signMessage: (arguments_) => signMessage(client, arguments_),
    signTransaction: (arguments_) => signTransaction(client, arguments_),
    signTypedData: (arguments_) => signTypedData(client, arguments_),
    switchChain: (arguments_) => switchChain(client, arguments_),
    waitForCallsStatus: (arguments_) => waitForCallsStatus(client, arguments_),
    watchAsset: (arguments_) => watchAsset(client, arguments_),
    writeContract: (arguments_) => writeContract(client, arguments_)
  };
}

// node_modules/viem/_esm/clients/createWalletClient.js
function createWalletClient(parameters) {
  const { key = "wallet", name = "Wallet Client", transport } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    transport,
    type: "walletClient"
  });
  return client.extend(walletActions);
}
// node_modules/viem/_esm/index.js
init_abis();
init_decodeFunctionData();

// node_modules/viem/_esm/chains/definitions/arbitrum.js
const arbitrum = /* @__PURE__ */ defineChain({
  id: 42_161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7_654_707
    }
  }
});
// node_modules/viem/_esm/chains/definitions/bsc.js
const bsc = /* @__PURE__ */ defineChain({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15_921_452
    }
  }
});
// node_modules/viem/_esm/chains/definitions/mainnet.js
const mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19_258_213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14_353_601
    }
  }
});
// src/config/ABIs/RMGP.ts
const rMGP = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_mgpToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_ymgpToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_masterMagpie",
        type: "address"
      },
      {
        internalType: "address",
        name: "_vlMGP",
        type: "address"
      },
      {
        internalType: "address",
        name: "_weth",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "CannotUnlockZero",
    type: "error"
  },
  {
    inputs: [],
    name: "ContractPaused",
    type: "error"
  },
  {
    inputs: [],
    name: "ECDSAInvalidSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "ECDSAInvalidSignatureLength",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "ECDSAInvalidSignatureS",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    inputs: [],
    name: "InsufficientBalance",
    type: "error"
  },
  {
    inputs: [],
    name: "NoLockedTokens",
    type: "error"
  },
  {
    inputs: [],
    name: "NoSlotsToUnlock",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [],
    name: "SwapRouterNotSet",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferFailed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      }
    ],
    name: "ZeroAddress",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "mgpAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "rmgpAmount",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "mgpAmount",
        type: "uint256"
      }
    ],
    name: "RewardsClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "rmgpAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "mgpAmount",
        type: "uint256"
      }
    ],
    name: "UnlockStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "slot",
        type: "uint256"
      }
    ],
    name: "Unlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [],
    name: "MASTER_MAGPIE",
    outputs: [
      {
        internalType: "contract IMasterMagpie",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MGP_TOKEN",
    outputs: [
      {
        internalType: "contract ERC20",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VL_MGP",
    outputs: [
      {
        internalType: "contract IVL_MGP",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "WETH",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "addRewardsToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "claim",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "mgpAmount",
        type: "uint256"
      }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getUserPendingWithdraws",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getUserWithdrawable",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "isValidSignature",
    outputs: [
      {
        internalType: "bytes4",
        name: "magicValue",
        type: "bytes4"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "pendingWithdraws",
    outputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "mgpAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "removeRewardsToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "rescueTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "rewardTokens",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "address",
        name: "swapRouter",
        type: "address"
      },
      {
        internalType: "bool",
        name: "camelot",
        type: "bool"
      }
    ],
    name: "setSwapRouter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "setYMGP",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "rmgpAmount",
        type: "uint256"
      }
    ],
    name: "startUnlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "swapRouters",
    outputs: [
      {
        internalType: "address",
        name: "router",
        type: "address"
      },
      {
        internalType: "bool",
        name: "camelot",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unsubmittedWithdraws",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "ymgpToken",
    outputs: [
      {
        internalType: "contract IYMGP",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/config/ABIs/YMGP.ts
const yMGP = [{ inputs: [{ internalType: "address", name: "_rmgpToken", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { inputs: [], name: "CannotLockZero", type: "error" }, { inputs: [], name: "CannotUnlockZero", type: "error" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "allowance", type: "uint256" }, { internalType: "uint256", name: "needed", type: "uint256" }], name: "ERC20InsufficientAllowance", type: "error" }, { inputs: [{ internalType: "address", name: "sender", type: "address" }, { internalType: "uint256", name: "balance", type: "uint256" }, { internalType: "uint256", name: "needed", type: "uint256" }], name: "ERC20InsufficientBalance", type: "error" }, { inputs: [{ internalType: "address", name: "approver", type: "address" }], name: "ERC20InvalidApprover", type: "error" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }], name: "ERC20InvalidReceiver", type: "error" }, { inputs: [{ internalType: "address", name: "sender", type: "address" }], name: "ERC20InvalidSender", type: "error" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }], name: "ERC20InvalidSpender", type: "error" }, { inputs: [], name: "InsufficientBalance", type: "error" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "OwnableInvalidOwner", type: "error" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "OwnableUnauthorizedAccount", type: "error" }, { inputs: [], name: "TransferFailed", type: "error" }, { inputs: [{ internalType: "string", name: "name", type: "string" }], name: "ZeroAddress", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Deposited", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Locked", type: "event" }, { anonymous: false, inputs: [], name: "NoYieldToClaim", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "YieldClaimed", type: "event" }, { inputs: [], name: "RMGP_TOKEN", outputs: [{ internalType: "contract ERC20", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "claim", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "deposit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "lock", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "lockedBalances", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "token", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "rescueTokens", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalLocked", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "unclaimedUserYield", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "unlock", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "userClaimedYield", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];

// src/config/ABIs/VMGP.ts
const vMGP = [{ inputs: [{ internalType: "address", name: "_ymgpToken", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "allowance", type: "uint256" }, { internalType: "uint256", name: "needed", type: "uint256" }], name: "ERC20InsufficientAllowance", type: "error" }, { inputs: [{ internalType: "address", name: "sender", type: "address" }, { internalType: "uint256", name: "balance", type: "uint256" }, { internalType: "uint256", name: "needed", type: "uint256" }], name: "ERC20InsufficientBalance", type: "error" }, { inputs: [{ internalType: "address", name: "approver", type: "address" }], name: "ERC20InvalidApprover", type: "error" }, { inputs: [{ internalType: "address", name: "receiver", type: "address" }], name: "ERC20InvalidReceiver", type: "error" }, { inputs: [{ internalType: "address", name: "sender", type: "address" }], name: "ERC20InvalidSender", type: "error" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }], name: "ERC20InvalidSpender", type: "error" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "OwnableInvalidOwner", type: "error" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "OwnableUnauthorizedAccount", type: "error" }, { inputs: [], name: "TransferFailed", type: "error" }, { inputs: [{ internalType: "string", name: "name", type: "string" }], name: "ZeroAddress", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Deposited", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "deposit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "token", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "rescueTokens", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_ymgpToken", type: "address" }], name: "setYMGP", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "ymgpToken", outputs: [{ internalType: "contract ERC20", name: "", type: "address" }], stateMutability: "view", type: "function" }];

// src/config/ABIs/CMGP.ts
const cMGP = [{ name: "Transfer", inputs: [{ name: "sender", type: "address", indexed: true }, { name: "receiver", type: "address", indexed: true }, { name: "value", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "Approval", inputs: [{ name: "owner", type: "address", indexed: true }, { name: "spender", type: "address", indexed: true }, { name: "value", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "TokenExchange", inputs: [{ name: "buyer", type: "address", indexed: true }, { name: "sold_id", type: "uint256", indexed: false }, { name: "tokens_sold", type: "uint256", indexed: false }, { name: "bought_id", type: "uint256", indexed: false }, { name: "tokens_bought", type: "uint256", indexed: false }, { name: "fee", type: "uint256", indexed: false }, { name: "packed_price_scale", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "AddLiquidity", inputs: [{ name: "provider", type: "address", indexed: true }, { name: "token_amounts", type: "uint256[3]", indexed: false }, { name: "fee", type: "uint256", indexed: false }, { name: "token_supply", type: "uint256", indexed: false }, { name: "packed_price_scale", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "RemoveLiquidity", inputs: [{ name: "provider", type: "address", indexed: true }, { name: "token_amounts", type: "uint256[3]", indexed: false }, { name: "token_supply", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "RemoveLiquidityOne", inputs: [{ name: "provider", type: "address", indexed: true }, { name: "token_amount", type: "uint256", indexed: false }, { name: "coin_index", type: "uint256", indexed: false }, { name: "coin_amount", type: "uint256", indexed: false }, { name: "approx_fee", type: "uint256", indexed: false }, { name: "packed_price_scale", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "NewParameters", inputs: [{ name: "mid_fee", type: "uint256", indexed: false }, { name: "out_fee", type: "uint256", indexed: false }, { name: "fee_gamma", type: "uint256", indexed: false }, { name: "allowed_extra_profit", type: "uint256", indexed: false }, { name: "adjustment_step", type: "uint256", indexed: false }, { name: "ma_time", type: "uint256", indexed: false }, { name: "xcp_ma_time", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "RampAgamma", inputs: [{ name: "initial_A", type: "uint256", indexed: false }, { name: "future_A", type: "uint256", indexed: false }, { name: "initial_gamma", type: "uint256", indexed: false }, { name: "future_gamma", type: "uint256", indexed: false }, { name: "initial_time", type: "uint256", indexed: false }, { name: "future_time", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "StopRampA", inputs: [{ name: "current_A", type: "uint256", indexed: false }, { name: "current_gamma", type: "uint256", indexed: false }, { name: "time", type: "uint256", indexed: false }], anonymous: false, type: "event" }, { name: "ClaimAdminFee", inputs: [{ name: "admin", type: "address", indexed: true }, { name: "tokens", type: "uint256[3]", indexed: false }], anonymous: false, type: "event" }, { stateMutability: "nonpayable", type: "constructor", inputs: [{ name: "_name", type: "string" }, { name: "_symbol", type: "string" }, { name: "_coins", type: "address[3]" }, { name: "_math", type: "address" }, { name: "_weth", type: "address" }, { name: "_salt", type: "bytes32" }, { name: "__packed_precisions", type: "uint256" }, { name: "packed_A_gamma", type: "uint256" }, { name: "packed_fee_params", type: "uint256" }, { name: "packed_rebalancing_params", type: "uint256" }, { name: "packed_prices", type: "uint256" }], outputs: [] }, { stateMutability: "nonpayable", type: "function", name: "exchange", inputs: [{ name: "i", type: "uint256" }, { name: "j", type: "uint256" }, { name: "dx", type: "uint256" }, { name: "min_dy", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "exchange", inputs: [{ name: "i", type: "uint256" }, { name: "j", type: "uint256" }, { name: "dx", type: "uint256" }, { name: "min_dy", type: "uint256" }, { name: "receiver", type: "address" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "exchange_received", inputs: [{ name: "i", type: "uint256" }, { name: "j", type: "uint256" }, { name: "dx", type: "uint256" }, { name: "min_dy", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "exchange_received", inputs: [{ name: "i", type: "uint256" }, { name: "j", type: "uint256" }, { name: "dx", type: "uint256" }, { name: "min_dy", type: "uint256" }, { name: "receiver", type: "address" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "add_liquidity", inputs: [{ name: "amounts", type: "uint256[3]" }, { name: "min_mint_amount", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "add_liquidity", inputs: [{ name: "amounts", type: "uint256[3]" }, { name: "min_mint_amount", type: "uint256" }, { name: "receiver", type: "address" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "remove_liquidity", inputs: [{ name: "_amount", type: "uint256" }, { name: "min_amounts", type: "uint256[3]" }], outputs: [{ name: "", type: "uint256[3]" }] }, { stateMutability: "nonpayable", type: "function", name: "remove_liquidity", inputs: [{ name: "_amount", type: "uint256" }, { name: "min_amounts", type: "uint256[3]" }, { name: "receiver", type: "address" }], outputs: [{ name: "", type: "uint256[3]" }] }, { stateMutability: "nonpayable", type: "function", name: "remove_liquidity_one_coin", inputs: [{ name: "token_amount", type: "uint256" }, { name: "i", type: "uint256" }, { name: "min_amount", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "remove_liquidity_one_coin", inputs: [{ name: "token_amount", type: "uint256" }, { name: "i", type: "uint256" }, { name: "min_amount", type: "uint256" }, { name: "receiver", type: "address" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "nonpayable", type: "function", name: "transferFrom", inputs: [{ name: "_from", type: "address" }, { name: "_to", type: "address" }, { name: "_value", type: "uint256" }], outputs: [{ name: "", type: "bool" }] }, { stateMutability: "nonpayable", type: "function", name: "transfer", inputs: [{ name: "_to", type: "address" }, { name: "_value", type: "uint256" }], outputs: [{ name: "", type: "bool" }] }, { stateMutability: "nonpayable", type: "function", name: "approve", inputs: [{ name: "_spender", type: "address" }, { name: "_value", type: "uint256" }], outputs: [{ name: "", type: "bool" }] }, { stateMutability: "nonpayable", type: "function", name: "permit", inputs: [{ name: "_owner", type: "address" }, { name: "_spender", type: "address" }, { name: "_value", type: "uint256" }, { name: "_deadline", type: "uint256" }, { name: "_v", type: "uint8" }, { name: "_r", type: "bytes32" }, { name: "_s", type: "bytes32" }], outputs: [{ name: "", type: "bool" }] }, { stateMutability: "view", type: "function", name: "fee_receiver", inputs: [], outputs: [{ name: "", type: "address" }] }, { stateMutability: "view", type: "function", name: "admin", inputs: [], outputs: [{ name: "", type: "address" }] }, { stateMutability: "view", type: "function", name: "calc_token_amount", inputs: [{ name: "amounts", type: "uint256[3]" }, { name: "deposit", type: "bool" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "get_dy", inputs: [{ name: "i", type: "uint256" }, { name: "j", type: "uint256" }, { name: "dx", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "get_dx", inputs: [{ name: "i", type: "uint256" }, { name: "j", type: "uint256" }, { name: "dy", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "lp_price", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "get_virtual_price", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "price_oracle", inputs: [{ name: "k", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "xcp_oracle", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "last_prices", inputs: [{ name: "k", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "price_scale", inputs: [{ name: "k", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "fee", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "calc_withdraw_one_coin", inputs: [{ name: "token_amount", type: "uint256" }, { name: "i", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "calc_token_fee", inputs: [{ name: "amounts", type: "uint256[3]" }, { name: "xp", type: "uint256[3]" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "A", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "gamma", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "mid_fee", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "out_fee", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "fee_gamma", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "allowed_extra_profit", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "adjustment_step", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "ma_time", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "precisions", inputs: [], outputs: [{ name: "", type: "uint256[3]" }] }, { stateMutability: "view", type: "function", name: "fee_calc", inputs: [{ name: "xp", type: "uint256[3]" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "DOMAIN_SEPARATOR", inputs: [], outputs: [{ name: "", type: "bytes32" }] }, { stateMutability: "nonpayable", type: "function", name: "ramp_A_gamma", inputs: [{ name: "future_A", type: "uint256" }, { name: "future_gamma", type: "uint256" }, { name: "future_time", type: "uint256" }], outputs: [] }, { stateMutability: "nonpayable", type: "function", name: "stop_ramp_A_gamma", inputs: [], outputs: [] }, { stateMutability: "nonpayable", type: "function", name: "apply_new_parameters", inputs: [{ name: "_new_mid_fee", type: "uint256" }, { name: "_new_out_fee", type: "uint256" }, { name: "_new_fee_gamma", type: "uint256" }, { name: "_new_allowed_extra_profit", type: "uint256" }, { name: "_new_adjustment_step", type: "uint256" }, { name: "_new_ma_time", type: "uint256" }, { name: "_new_xcp_ma_time", type: "uint256" }], outputs: [] }, { stateMutability: "view", type: "function", name: "MATH", inputs: [], outputs: [{ name: "", type: "address" }] }, { stateMutability: "view", type: "function", name: "coins", inputs: [{ name: "arg0", type: "uint256" }], outputs: [{ name: "", type: "address" }] }, { stateMutability: "view", type: "function", name: "factory", inputs: [], outputs: [{ name: "", type: "address" }] }, { stateMutability: "view", type: "function", name: "last_timestamp", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "last_xcp", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "xcp_ma_time", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "initial_A_gamma", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "initial_A_gamma_time", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "future_A_gamma", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "future_A_gamma_time", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "balances", inputs: [{ name: "arg0", type: "uint256" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "D", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "xcp_profit", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "xcp_profit_a", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "virtual_price", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "packed_rebalancing_params", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "packed_fee_params", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "ADMIN_FEE", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "name", inputs: [], outputs: [{ name: "", type: "string" }] }, { stateMutability: "view", type: "function", name: "symbol", inputs: [], outputs: [{ name: "", type: "string" }] }, { stateMutability: "view", type: "function", name: "decimals", inputs: [], outputs: [{ name: "", type: "uint8" }] }, { stateMutability: "view", type: "function", name: "version", inputs: [], outputs: [{ name: "", type: "string" }] }, { stateMutability: "view", type: "function", name: "balanceOf", inputs: [{ name: "arg0", type: "address" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "allowance", inputs: [{ name: "arg0", type: "address" }, { name: "arg1", type: "address" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "totalSupply", inputs: [], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "nonces", inputs: [{ name: "arg0", type: "address" }], outputs: [{ name: "", type: "uint256" }] }, { stateMutability: "view", type: "function", name: "salt", inputs: [], outputs: [{ name: "", type: "bytes32" }] }];

// src/config/ABIs/VLMGP.ts
const VLMGP = [{ inputs: [], name: "AllUnlockSlotOccupied", type: "error" }, { inputs: [], name: "AlreadyMigrated", type: "error" }, { inputs: [], name: "BeyondUnlockLength", type: "error" }, { inputs: [], name: "BeyondUnlockSlotLimit", type: "error" }, { inputs: [], name: "BurnEventManagerNotSet", type: "error" }, { inputs: [], name: "BurnEvnentManagerPaused", type: "error" }, { inputs: [], name: "InvalidAddress", type: "error" }, { inputs: [], name: "InvalidCoolDownPeriod", type: "error" }, { inputs: [], name: "IsZeroAddress", type: "error" }, { inputs: [], name: "MaxSlotCantLowered", type: "error" }, { inputs: [], name: "MaxSlotShouldNotZero", type: "error" }, { inputs: [], name: "NotEnoughLockedMPG", type: "error" }, { inputs: [], name: "NotInCoolDown", type: "error" }, { inputs: [], name: "PenaltyToNotSet", type: "error" }, { inputs: [], name: "StillInCoolDown", type: "error" }, { inputs: [], name: "TransferNotWhiteListed", type: "error" }, { inputs: [], name: "UnlockSlotOccupied", type: "error" }, { inputs: [], name: "UnlockedAlready", type: "error" }, { inputs: [], name: "coolDownInSecCanCauseOverflow", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "_coolDownSecs", type: "uint256" }], name: "CoolDownInSecsUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: false, internalType: "uint256", name: "slotIdx", type: "uint256" }, { indexed: false, internalType: "uint256", name: "mgpamount", type: "uint256" }, { indexed: false, internalType: "uint256", name: "penaltyAmount", type: "uint256" }], name: "ForceUnLock", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint8", name: "version", type: "uint8" }], name: "Initialized", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "_maxSlot", type: "uint256" }], name: "MaxSlotUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: true, internalType: "uint256", name: "timestamp", type: "uint256" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "NewLock", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_oldMaster", type: "address" }, { indexed: false, internalType: "address", name: "_newMaster", type: "address" }], name: "NewMasterChiefUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "penaltyDestination", type: "address" }], name: "PenaltyDestinationUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "penaltyDestination", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "PenaltySentTo", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: false, internalType: "uint256", name: "slotIdx", type: "uint256" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "ReLock", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: true, internalType: "uint256", name: "timestamp", type: "uint256" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Unlock", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_user", type: "address" }, { indexed: true, internalType: "uint256", name: "_timestamp", type: "uint256" }, { indexed: false, internalType: "uint256", name: "_amount", type: "uint256" }], name: "UnlockStarts", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: true, internalType: "uint256", name: "timestamp", type: "uint256" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }, { indexed: false, internalType: "uint256", name: "_eventId", type: "uint256" }], name: "VlMgpBurn", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_for", type: "address" }, { indexed: false, internalType: "bool", name: "_status", type: "bool" }], name: "WhitelistSet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "burnEventManager", type: "address" }], name: "burnEventManagerSet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "referralStorage", type: "address" }], name: "referralStorageSet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "wombatBribeManager", type: "address" }], name: "wombatBribeManagerSet", type: "event" }, { inputs: [], name: "DENOMINATOR", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "MGP", outputs: [{ internalType: "contract IERC20", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_masterMagpie", type: "address" }, { internalType: "uint256", name: "_maxSlots", type: "uint256" }, { internalType: "address", name: "_mgp", type: "address" }, { internalType: "uint256", name: "_coolDownInSecs", type: "uint256" }], name: "__vlMGP_init_", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "burnEventManager", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_vlmgpAmountToBurn", type: "uint256" }, { internalType: "uint256", name: "_vlmgpBurnEventId", type: "uint256" }], name: "burnVlmgp", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_slotIndex", type: "uint256" }], name: "cancelUnlock", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "coolDownInSecs", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "subtractedValue", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_slotIndex", type: "uint256" }], name: "expectedPenaltyAmount", outputs: [{ internalType: "uint256", name: "penaltyAmount", type: "uint256" }, { internalType: "uint256", name: "amontToUser", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_slotIndex", type: "uint256" }], name: "forceUnLock", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "getFullyUnlock", outputs: [{ internalType: "uint256", name: "unlockedAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "getNextAvailableUnlockSlot", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "getRewardablePercentWAD", outputs: [{ internalType: "uint256", name: "percent", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "getUserAmountInCoolDown", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }, { internalType: "uint256", name: "n", type: "uint256" }], name: "getUserNthUnlockSlot", outputs: [{ internalType: "uint256", name: "startTime", type: "uint256" }, { internalType: "uint256", name: "endTime", type: "uint256" }, { internalType: "uint256", name: "amountInCoolDown", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "getUserTotalLocked", outputs: [{ internalType: "uint256", name: "_lockAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "getUserUnlockSlotLength", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_user", type: "address" }], name: "getUserUnlockingSchedule", outputs: [{ components: [{ internalType: "uint256", name: "startTime", type: "uint256" }, { internalType: "uint256", name: "endTime", type: "uint256" }, { internalType: "uint256", name: "amountInCoolDown", type: "uint256" }], internalType: "struct ILocker.UserUnlocking[]", name: "slots", type: "tuple[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "addedValue", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }], name: "lock", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "address", name: "_for", type: "address" }], name: "lockFor", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "masterMagpie", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "maxSlot", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "penaltyDestination", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "referralStorage", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_coolDownSecs", type: "uint256" }], name: "setCoolDownInSecs", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_masterMagpie", type: "address" }], name: "setMasterChief", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_maxSlots", type: "uint256" }], name: "setMaxSlots", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_burnEventMAnager", type: "address" }], name: "setMgpBurnEventManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_penaltyDestination", type: "address" }], name: "setPenaltyDestination", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_referralStorage", type: "address" }], name: "setReferralStorage", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_for", type: "address" }, { internalType: "bool", name: "_status", type: "bool" }], name: "setWhitelistForTransfer", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_bribeManager", type: "address" }], name: "setWombatBribeManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amountToCoolDown", type: "uint256" }], name: "startUnlock", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalAmountInCoolDown", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalLocked", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalPenalty", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "transferPenalty", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "transferWhitelist", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_slotIndex", type: "uint256" }], name: "unlock", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "unpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }], name: "userUnlockings", outputs: [{ internalType: "uint256", name: "startTime", type: "uint256" }, { internalType: "uint256", name: "endTime", type: "uint256" }, { internalType: "uint256", name: "amountInCoolDown", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "wombatBribeManager", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }];

// src/config/ABIs/MASTERMGP.ts
const MASTERMGP = [{ inputs: [], name: "IndexOutOfBound", type: "error" }, { inputs: [], name: "InvalidStakingToken", type: "error" }, { inputs: [], name: "LengthMismatch", type: "error" }, { inputs: [], name: "MGPsetAlready", type: "error" }, { inputs: [], name: "MustBeContract", type: "error" }, { inputs: [], name: "MustBeContractOrZero", type: "error" }, { inputs: [], name: "MustNotBeZero", type: "error" }, { inputs: [], name: "OnlyActivePool", type: "error" }, { inputs: [], name: "OnlyCompounder", type: "error" }, { inputs: [], name: "OnlyLocker", type: "error" }, { inputs: [], name: "OnlyPoolHelper", type: "error" }, { inputs: [], name: "OnlyPoolManager", type: "error" }, { inputs: [], name: "OnlyWhiteListedAllocUpdator", type: "error" }, { inputs: [], name: "PoolExsisted", type: "error" }, { inputs: [], name: "UnlockAmountExceedsLocked", type: "error" }, { inputs: [], name: "WithdrawAmountExceedsStaked", type: "error" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_oldARBRewarder", type: "address" }, { indexed: false, internalType: "address", name: "_newARBRewarder", type: "address" }], name: "ARBRewarderSet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "rewarder", type: "address" }], name: "ARBRewarderSetAsQueuer", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "_allocPoint", type: "uint256" }, { indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: true, internalType: "contract IBaseRewardPool", name: "_rewarder", type: "address" }], name: "Add", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_newCompounder", type: "address" }, { indexed: false, internalType: "address", name: "_oldCompounder", type: "address" }], name: "CompounderUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_user", type: "address" }, { indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "uint256", name: "_amount", type: "uint256" }], name: "Deposit", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_user", type: "address" }, { indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "uint256", name: "_amount", type: "uint256" }], name: "DepositNotAvailable", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_user", type: "address" }, { indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "uint256", name: "_amount", type: "uint256" }], name: "EmergencyWithdraw", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_account", type: "address" }, { indexed: true, internalType: "address", name: "_receiver", type: "address" }, { indexed: false, internalType: "uint256", name: "_amount", type: "uint256" }, { indexed: false, internalType: "bool", name: "isLock", type: "bool" }], name: "HarvestMGP", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint8", name: "version", type: "uint8" }], name: "Initialized", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "address[]", name: "_legacyRewarder", type: "address[]" }], name: "LegacyRewardersSet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "bool", name: "_isRewardMGP", type: "bool" }], name: "LockFreePoolUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_mgp", type: "address" }], name: "MGPSet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_mWomSV", type: "address" }, { indexed: false, internalType: "address", name: "_oldMWomSV", type: "address" }], name: "MWomSVpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_account", type: "address" }, { indexed: false, internalType: "bool", name: "_status", type: "bool" }], name: "PoolManagerStatus", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "uint256", name: "_allocPoint", type: "uint256" }, { indexed: true, internalType: "contract IBaseRewardPool", name: "_rewarder", type: "address" }], name: "Set", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_user", type: "address" }, { indexed: false, internalType: "uint256", name: "_oldMgpPerSec", type: "uint256" }, { indexed: false, internalType: "uint256", name: "_newMgpPerSec", type: "uint256" }], name: "UpdateEmissionRate", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "uint256", name: "_lastRewardTimestamp", type: "uint256" }, { indexed: false, internalType: "uint256", name: "_lpSupply", type: "uint256" }, { indexed: false, internalType: "uint256", name: "_accMGPPerShare", type: "uint256" }], name: "UpdatePool", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "uint256", name: "_oldAllocPoint", type: "uint256" }, { indexed: false, internalType: "uint256", name: "_newAllocPoint", type: "uint256" }], name: "UpdatePoolAlloc", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "_newVlmgp", type: "address" }, { indexed: false, internalType: "address", name: "_oldVlmgp", type: "address" }], name: "VLMGPUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_user", type: "address" }, { indexed: true, internalType: "address", name: "_stakingToken", type: "address" }, { indexed: false, internalType: "uint256", name: "_amount", type: "uint256" }], name: "Withdraw", type: "event" }, { inputs: [], name: "ARBRewarder", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "AllocationManagers", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "MPGRewardPool", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "PoolManagers", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_mgp", type: "address" }, { internalType: "uint256", name: "_mgpPerSec", type: "uint256" }, { internalType: "uint256", name: "_startTimestamp", type: "uint256" }], name: "__MasterMagpie_init", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_allocPoint", type: "uint256" }, { internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "address", name: "_rewarder", type: "address" }, { internalType: "address", name: "_helper", type: "address" }, { internalType: "bool", name: "_helperNeedsHarvest", type: "bool" }], name: "add", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newAllocationManager", type: "address" }], name: "addWhitelistedAllocManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "address", name: "_user", type: "address" }], name: "allPendingLegacyTokens", outputs: [{ internalType: "address[][]", name: "bonusTokenAddresses", type: "address[][]" }, { internalType: "string[][]", name: "bonusTokenSymbols", type: "string[][]" }, { internalType: "uint256[][]", name: "pendingBonusRewards", type: "uint256[][]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "address", name: "_user", type: "address" }], name: "allPendingTokens", outputs: [{ internalType: "uint256", name: "pendingMGP", type: "uint256" }, { internalType: "address[]", name: "bonusTokenAddresses", type: "address[]" }, { internalType: "string[]", name: "bonusTokenSymbols", type: "string[]" }, { internalType: "uint256[]", name: "pendingBonusRewards", type: "uint256[]" }], stateMutability: "view", type: "function" }, { inputs: [], name: "compounder", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "address", name: "mainRewardToken", type: "address" }], name: "createRewarder", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "deposit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "address", name: "_for", type: "address" }], name: "depositFor", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "address", name: "_for", type: "address" }], name: "depositMWomSVFor", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "address", name: "_for", type: "address" }], name: "depositVlMGPFor", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }], name: "getPoolInfo", outputs: [{ internalType: "uint256", name: "emission", type: "uint256" }, { internalType: "uint256", name: "allocpoint", type: "uint256" }, { internalType: "uint256", name: "sizeOfPool", type: "uint256" }, { internalType: "uint256", name: "totalPoint", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "stakingToken", type: "address" }], name: "getRewarder", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "legacyRewarder_deprecated", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }], name: "legacyRewarders", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "mWomSV", outputs: [{ internalType: "contract ILocker", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "massUpdatePools", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "mgp", outputs: [{ internalType: "contract MGP", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "mgpPerSec", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address[]", name: "_stakingTokens", type: "address[]" }], name: "multiclaim", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "_stakingTokens", type: "address[]" }, { internalType: "address[][]", name: "_rewardTokens", type: "address[][]" }, { internalType: "address", name: "_account", type: "address" }], name: "multiclaimFor", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "_stakingTokens", type: "address[]" }, { internalType: "address[][]", name: "_rewardTokens", type: "address[][]" }, { internalType: "address", name: "_account", type: "address" }], name: "multiclaimOnBehalf", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "_stakingTokens", type: "address[]" }, { internalType: "address[][]", name: "_rewardTokens", type: "address[][]" }], name: "multiclaimSpec", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "address", name: "_user", type: "address" }, { internalType: "address", name: "_rewardToken", type: "address" }], name: "pendingTokens", outputs: [{ internalType: "uint256", name: "pendingMGP", type: "uint256" }, { internalType: "address", name: "bonusTokenAddress", type: "address" }, { internalType: "string", name: "bonusTokenSymbol", type: "string" }, { internalType: "uint256", name: "pendingBonusToken", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "poolLength", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "referral", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "registeredToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "index", type: "uint256" }], name: "removeWhitelistedAllocManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }], name: "rewarderBonusTokenInfo", outputs: [{ internalType: "address[]", name: "bonusTokenAddresses", type: "address[]" }, { internalType: "string[]", name: "bonusTokenSymbols", type: "string[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "uint256", name: "_allocPoint", type: "uint256" }, { internalType: "address", name: "_helper", type: "address" }, { internalType: "address", name: "_rewarder", type: "address" }, { internalType: "bool", name: "_helperNeedsHarvest", type: "bool" }], name: "set", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_ARBRewarder", type: "address" }], name: "setARBRewarder", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "_pools", type: "address[]" }], name: "setARBRewarderAsQueuer", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_compounder", type: "address" }], name: "setCompounder", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "_stakingTokens", type: "address[]" }, { internalType: "address[][]", name: "_legacyRewarder", type: "address[][]" }], name: "setLegacyRewarder", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "bool", name: "_isLockFree", type: "bool" }], name: "setMGPRewardPools", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_mWomSV", type: "address" }], name: "setMWomSV", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_account", type: "address" }, { internalType: "bool", name: "_allowedManager", type: "bool" }], name: "setPoolManagerStatus", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_referral", type: "address" }], name: "setReferral", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_vlmgp", type: "address" }], name: "setVlmgp", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "address", name: "_user", type: "address" }], name: "stakingInfo", outputs: [{ internalType: "uint256", name: "stakedAmount", type: "uint256" }, { internalType: "uint256", name: "availableAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "startTimestamp", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "tokenToPoolInfo", outputs: [{ internalType: "address", name: "stakingToken", type: "address" }, { internalType: "uint256", name: "allocPoint", type: "uint256" }, { internalType: "uint256", name: "lastRewardTimestamp", type: "uint256" }, { internalType: "uint256", name: "accMGPPerShare", type: "uint256" }, { internalType: "address", name: "rewarder", type: "address" }, { internalType: "address", name: "helper", type: "address" }, { internalType: "bool", name: "helperNeedsHarvest", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalAllocPoint", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }], name: "unClaimedMgp", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "unpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_mgpPerSec", type: "uint256" }], name: "updateEmissionRate", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }], name: "updatePool", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "_stakingTokens", type: "address[]" }, { internalType: "uint256[]", name: "_allocPoints", type: "uint256[]" }], name: "updatePoolsAlloc", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_rewarder", type: "address" }, { internalType: "address", name: "_manager", type: "address" }, { internalType: "bool", name: "_allowed", type: "bool" }], name: "updateRewarderManager", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "vlmgp", outputs: [{ internalType: "contract ILocker", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "withdraw", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_stakingToken", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "address", name: "_for", type: "address" }], name: "withdrawFor", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "address", name: "_for", type: "address" }], name: "withdrawMWomSVFor", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "address", name: "_for", type: "address" }], name: "withdrawVlMGPFor", outputs: [], stateMutability: "nonpayable", type: "function" }];

// src/config/ABIs/VLREWARDER.ts
const VLREWARDER = [{ inputs: [{ internalType: "address", name: "_logic", type: "address" }, { internalType: "address", name: "admin_", type: "address" }, { internalType: "bytes", name: "_data", type: "bytes" }], stateMutability: "payable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "previousAdmin", type: "address" }, { indexed: false, internalType: "address", name: "newAdmin", type: "address" }], name: "AdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "beacon", type: "address" }], name: "BeaconUpgraded", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "implementation", type: "address" }], name: "Upgraded", type: "event" }, { stateMutability: "payable", type: "fallback" }, { inputs: [], name: "admin", outputs: [{ internalType: "address", name: "admin_", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newAdmin", type: "address" }], name: "changeAdmin", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "implementation", outputs: [{ internalType: "address", name: "implementation_", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newImplementation", type: "address" }], name: "upgradeTo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newImplementation", type: "address" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "upgradeToAndCall", outputs: [], stateMutability: "payable", type: "function" }, { stateMutability: "payable", type: "receive" }];

// src/config/ABIs/ODOSRouter.ts
const ODOSRouter = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "sender", type: "address" }, { indexed: false, internalType: "uint256", name: "inputAmount", type: "uint256" }, { indexed: false, internalType: "address", name: "inputToken", type: "address" }, { indexed: false, internalType: "uint256", name: "amountOut", type: "uint256" }, { indexed: false, internalType: "address", name: "outputToken", type: "address" }, { indexed: false, internalType: "int256", name: "slippage", type: "int256" }, { indexed: false, internalType: "uint32", name: "referralCode", type: "uint32" }], name: "Swap", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "sender", type: "address" }, { indexed: false, internalType: "uint256[]", name: "amountsIn", type: "uint256[]" }, { indexed: false, internalType: "address[]", name: "tokensIn", type: "address[]" }, { indexed: false, internalType: "uint256[]", name: "amountsOut", type: "uint256[]" }, { indexed: false, internalType: "address[]", name: "tokensOut", type: "address[]" }, { indexed: false, internalType: "uint32", name: "referralCode", type: "uint32" }], name: "SwapMulti", type: "event" }, { inputs: [], name: "FEE_DENOM", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "REFERRAL_WITH_FEE_THRESHOLD", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "addressList", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint32", name: "", type: "uint32" }], name: "referralLookup", outputs: [{ internalType: "uint64", name: "referralFee", type: "uint64" }, { internalType: "address", name: "beneficiary", type: "address" }, { internalType: "bool", name: "registered", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint32", name: "_referralCode", type: "uint32" }, { internalType: "uint64", name: "_referralFee", type: "uint64" }, { internalType: "address", name: "_beneficiary", type: "address" }], name: "registerReferralCode", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_swapMultiFee", type: "uint256" }], name: "setSwapMultiFee", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "inputToken", type: "address" }, { internalType: "uint256", name: "inputAmount", type: "uint256" }, { internalType: "address", name: "inputReceiver", type: "address" }, { internalType: "address", name: "outputToken", type: "address" }, { internalType: "uint256", name: "outputQuote", type: "uint256" }, { internalType: "uint256", name: "outputMin", type: "uint256" }, { internalType: "address", name: "outputReceiver", type: "address" }], internalType: "struct OdosRouterV2.swapTokenInfo", name: "tokenInfo", type: "tuple" }, { internalType: "bytes", name: "pathDefinition", type: "bytes" }, { internalType: "address", name: "executor", type: "address" }, { internalType: "uint32", name: "referralCode", type: "uint32" }], name: "swap", outputs: [{ internalType: "uint256", name: "amountOut", type: "uint256" }], stateMutability: "payable", type: "function" }, { inputs: [], name: "swapCompact", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "payable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "tokenAddress", type: "address" }, { internalType: "uint256", name: "amountIn", type: "uint256" }, { internalType: "address", name: "receiver", type: "address" }], internalType: "struct OdosRouterV2.inputTokenInfo[]", name: "inputs", type: "tuple[]" }, { components: [{ internalType: "address", name: "tokenAddress", type: "address" }, { internalType: "uint256", name: "relativeValue", type: "uint256" }, { internalType: "address", name: "receiver", type: "address" }], internalType: "struct OdosRouterV2.outputTokenInfo[]", name: "outputs", type: "tuple[]" }, { internalType: "uint256", name: "valueOutMin", type: "uint256" }, { internalType: "bytes", name: "pathDefinition", type: "bytes" }, { internalType: "address", name: "executor", type: "address" }, { internalType: "uint32", name: "referralCode", type: "uint32" }], name: "swapMulti", outputs: [{ internalType: "uint256[]", name: "amountsOut", type: "uint256[]" }], stateMutability: "payable", type: "function" }, { inputs: [], name: "swapMultiCompact", outputs: [{ internalType: "uint256[]", name: "amountsOut", type: "uint256[]" }], stateMutability: "payable", type: "function" }, { inputs: [], name: "swapMultiFee", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "contractAddress", type: "address" }, { internalType: "uint256", name: "nonce", type: "uint256" }, { internalType: "uint256", name: "deadline", type: "uint256" }, { internalType: "bytes", name: "signature", type: "bytes" }], internalType: "struct OdosRouterV2.permit2Info", name: "permit2", type: "tuple" }, { components: [{ internalType: "address", name: "tokenAddress", type: "address" }, { internalType: "uint256", name: "amountIn", type: "uint256" }, { internalType: "address", name: "receiver", type: "address" }], internalType: "struct OdosRouterV2.inputTokenInfo[]", name: "inputs", type: "tuple[]" }, { components: [{ internalType: "address", name: "tokenAddress", type: "address" }, { internalType: "uint256", name: "relativeValue", type: "uint256" }, { internalType: "address", name: "receiver", type: "address" }], internalType: "struct OdosRouterV2.outputTokenInfo[]", name: "outputs", type: "tuple[]" }, { internalType: "uint256", name: "valueOutMin", type: "uint256" }, { internalType: "bytes", name: "pathDefinition", type: "bytes" }, { internalType: "address", name: "executor", type: "address" }, { internalType: "uint32", name: "referralCode", type: "uint32" }], name: "swapMultiPermit2", outputs: [{ internalType: "uint256[]", name: "amountsOut", type: "uint256[]" }], stateMutability: "payable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "contractAddress", type: "address" }, { internalType: "uint256", name: "nonce", type: "uint256" }, { internalType: "uint256", name: "deadline", type: "uint256" }, { internalType: "bytes", name: "signature", type: "bytes" }], internalType: "struct OdosRouterV2.permit2Info", name: "permit2", type: "tuple" }, { components: [{ internalType: "address", name: "inputToken", type: "address" }, { internalType: "uint256", name: "inputAmount", type: "uint256" }, { internalType: "address", name: "inputReceiver", type: "address" }, { internalType: "address", name: "outputToken", type: "address" }, { internalType: "uint256", name: "outputQuote", type: "uint256" }, { internalType: "uint256", name: "outputMin", type: "uint256" }, { internalType: "address", name: "outputReceiver", type: "address" }], internalType: "struct OdosRouterV2.swapTokenInfo", name: "tokenInfo", type: "tuple" }, { internalType: "bytes", name: "pathDefinition", type: "bytes" }, { internalType: "address", name: "executor", type: "address" }, { internalType: "uint32", name: "referralCode", type: "uint32" }], name: "swapPermit2", outputs: [{ internalType: "uint256", name: "amountOut", type: "uint256" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "tokenAddress", type: "address" }, { internalType: "uint256", name: "amountIn", type: "uint256" }, { internalType: "address", name: "receiver", type: "address" }], internalType: "struct OdosRouterV2.inputTokenInfo[]", name: "inputs", type: "tuple[]" }, { components: [{ internalType: "address", name: "tokenAddress", type: "address" }, { internalType: "uint256", name: "relativeValue", type: "uint256" }, { internalType: "address", name: "receiver", type: "address" }], internalType: "struct OdosRouterV2.outputTokenInfo[]", name: "outputs", type: "tuple[]" }, { internalType: "uint256", name: "valueOutMin", type: "uint256" }, { internalType: "bytes", name: "pathDefinition", type: "bytes" }, { internalType: "address", name: "executor", type: "address" }], name: "swapRouterFunds", outputs: [{ internalType: "uint256[]", name: "amountsOut", type: "uint256[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "tokens", type: "address[]" }, { internalType: "uint256[]", name: "amounts", type: "uint256[]" }, { internalType: "address", name: "dest", type: "address" }], name: "transferRouterFunds", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address[]", name: "addresses", type: "address[]" }], name: "writeAddressList", outputs: [], stateMutability: "nonpayable", type: "function" }, { stateMutability: "payable", type: "receive" }];

// src/config/ABIs/WETH.ts
const WETH = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }, { indexed: false, internalType: "bytes", name: "data", type: "bytes" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [], name: "DOMAIN_SEPARATOR", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "bridgeBurn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "bridgeMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "subtractedValue", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "deposit", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "depositTo", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "addedValue", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "uint8", name: "_decimals", type: "uint8" }, { internalType: "address", name: "_l2Gateway", type: "address" }, { internalType: "address", name: "_l1Address", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "l1Address", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "l2Gateway", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "nonces", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "deadline", type: "uint256" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "permit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "recipient", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_value", type: "uint256" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "transferAndCall", outputs: [{ internalType: "bool", name: "success", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "sender", type: "address" }, { internalType: "address", name: "recipient", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "withdraw", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "withdrawTo", outputs: [], stateMutability: "nonpayable", type: "function" }, { stateMutability: "payable", type: "receive" }];

// src/config/ABIs/abis.ts
const ABIs = {
  MGP: erc20Abi,
  rMGP,
  yMGP,
  vMGP,
  VLMGP,
  MASTERMGP,
  VLREWARDER,
  cMGP,
  CKP: erc20Abi,
  PNP: erc20Abi,
  EGP: erc20Abi,
  LTP: erc20Abi,
  WETH,
  WBNB: erc20Abi,
  ODOSRouter
};

// src/config/contracts.ts
const decimals = { MGP: 18, rMGP: 18, yMGP: 18, cMGP: 18, CKP: 18, PNP: 18, EGP: 18, LTP: 18, WETH: 18, ETH: 18 };
const calls = [];
const onRPCRequest = async (request) => {
  const body = await new Response(request.body).json();
  for (const call2 of body) {
    if (call2.method === "eth_call") {
      const key = `${call2.params[0].to}_${call2.params[0].data}`;
      if (calls.includes(key)) {
        for (const chain of Object.values(contracts)) {
          for (const contractName of Object.keys(chain)) {
            const contract = chain[contractName];
            if (contract.address === call2.params[0].to) {
              const decodedData = decodeFunctionData({ abi: contract.abi, data: call2.params[0].data });
              console.log("Duplicate RPC Call", `${contractName}.${decodedData.functionName}(${decodedData.args === undefined ? "" : decodedData.args.join(", ")})`);
            }
          }
        }
      } else
        calls.push(key);
    }
  }
};
const publicClients = {
  1: createPublicClient({ chain: mainnet, transport: http("https://eth.drpc.org", { retryDelay: 250, batch: { wait: 1000, batchSize: 3 }, onFetchRequest: onRPCRequest }) }),
  56: createPublicClient({ chain: bsc, transport: http("https://bsc-dataseed1.binance.org", { retryDelay: 250, batch: true, onFetchRequest: onRPCRequest }) }),
  42_161: createPublicClient({ chain: arbitrum, transport: http("https://arb1.arbitrum.io/rpc", { retryDelay: 1000, batch: { wait: 150 }, onFetchRequest: onRPCRequest }) })
};
const coins = {
  MGP: { symbol: "MGP", color: "bg-blue-400", bgColor: "bg-blue-600" },
  rMGP: { symbol: "RMGP", color: "bg-green-400", bgColor: "bg-green-600" },
  yMGP: { symbol: "YMGP", color: "bg-green-400", bgColor: "bg-green-600" },
  cMGP: { symbol: "CMGP", color: "bg-indigo-400", bgColor: "bg-indigo-600" },
  CKP: { symbol: "CKP", color: "bg-pink-400", bgColor: "bg-pink-600" },
  PNP: { symbol: "PNP", color: "bg-orange-400", bgColor: "bg-orange-600" },
  EGP: { symbol: "EGP", color: "bg-red-400", bgColor: "bg-red-600" },
  LTP: { symbol: "LTP", color: "bg-teal-400", bgColor: "bg-teal-600" },
  WETH: { symbol: "ETH", color: "bg-gray-400", bgColor: "bg-gray-600" }
};
const bscContracts = {
  MGP: getContract({ address: "0xD06716E1Ff2E492Cc5034c2E81805562dd3b45fa", abi: erc20Abi, client: publicClients[56] }),
  rMGP: getContract({ address: "0x0277517658a1dd3899bf926fCf6A633e549eB769", abi: ABIs.rMGP, client: publicClients[56] }),
  yMGP: getContract({ address: "0xc7Fd6A7D4CDd26fD34948cA0fC2b07DdC84fe0Bb", abi: ABIs.yMGP, client: publicClients[56] }),
  vMGP: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.vMGP, client: publicClients[56] }),
  cMGP: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.cMGP, client: publicClients[56] }),
  VLMGP: getContract({ address: "0x9B69b06272980FA6BAd9D88680a71e3c3BeB32c6", abi: ABIs.VLMGP, client: publicClients[56] }),
  MASTERMGP: getContract({ address: "0xa3B615667CBd33cfc69843Bf11Fbb2A1D926BD46", abi: ABIs.MASTERMGP, client: publicClients[56] }),
  VLREWARDER: getContract({ address: "0x9D29c8d733a3b6E0713D677F106E8F38c5649eF9", abi: ABIs.VLREWARDER, client: publicClients[56] }),
  WETH: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.WETH, client: publicClients[56] }),
  WBNB: getContract({ address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", abi: ABIs.WBNB, client: publicClients[56] }),
  PNP: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.PNP, client: publicClients[56] }),
  CKP: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.CKP, client: publicClients[56] }),
  EGP: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.EGP, client: publicClients[56] }),
  LTP: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.LTP, client: publicClients[56] }),
  ODOSRouter: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.ODOSRouter, client: publicClients[56] })
};
const arbContracts = {
  MGP: getContract({ address: "0xa61F74247455A40b01b0559ff6274441FAfa22A3", abi: erc20Abi, client: publicClients[42_161] }),
  rMGP: getContract({ address: "0x3788c8791d826254bAbd49b602C93008468D5695", abi: ABIs.rMGP, client: publicClients[42_161] }),
  yMGP: getContract({ address: "0x3975Eca44C64dCBE35d3aA227F05a97A811b30B9", abi: ABIs.yMGP, client: publicClients[42_161] }),
  vMGP: getContract({ address: "0x0000000000000000000000000000000000000000", abi: ABIs.vMGP, client: publicClients[42_161] }),
  cMGP: getContract({ address: "0xD1465c3489Aa7Eac0e7f9907F93a684840a2F934", abi: ABIs.cMGP, client: publicClients[42_161] }),
  VLMGP: getContract({ address: "0x536599497Ce6a35FC65C7503232Fec71A84786b9", abi: ABIs.VLMGP, client: publicClients[42_161] }),
  MASTERMGP: getContract({ address: "0x664cc2BcAe1E057EB1Ec379598c5B743Ad9Db6e7", abi: ABIs.MASTERMGP, client: publicClients[42_161] }),
  VLREWARDER: getContract({ address: "0xAE7FDA9d3d6dceda5824c03A75948AaB4c933c45", abi: ABIs.VLREWARDER, client: publicClients[42_161] }),
  WETH: getContract({ address: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", abi: ABIs.WETH, client: publicClients[42_161] }),
  WBNB: getContract({ address: "0x20865e63B111B2649ef829EC220536c82C58ad7B", abi: ABIs.WBNB, client: publicClients[42_161] }),
  PNP: getContract({ address: "0x2Ac2B254Bc18cD4999f64773a966E4f4869c34Ee", abi: ABIs.PNP, client: publicClients[42_161] }),
  CKP: getContract({ address: "0x346Af1954e3d6be46B96dA713a1f7fD2d1928F1d", abi: ABIs.CKP, client: publicClients[42_161] }),
  EGP: getContract({ address: "0x7E7a7C916c19a45769f6BDAF91087f93c6C12F78", abi: ABIs.EGP, client: publicClients[42_161] }),
  LTP: getContract({ address: "0xa73959804651eEd0D4bd04293A675cB832c20454", abi: ABIs.LTP, client: publicClients[42_161] }),
  ODOSRouter: getContract({ address: "0xa669e7A0d4b3e4Fa48af2dE86BD4CD7126Be4e13", abi: ABIs.ODOSRouter, client: publicClients[42_161] })
};
var contracts = {
  56: bscContracts,
  42_161: arbContracts
};

// src/contexts/GlobalContext.tsx
const import_react28 = __toESM(require_react(), 1);

// src/hooks/useWallet.ts
const import_react4 = __toESM(require_react(), 1);

// src/hooks/useUpdateable.ts
const import_react3 = __toESM(require_react(), 1);

// node_modules/superjson/dist/double-indexed-kv.js
class DoubleIndexedKV {
  constructor() {
    this.keyToValue = new Map;
    this.valueToKey = new Map;
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
}

// node_modules/superjson/dist/registry.js
class Registry {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV;
  }
  register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }
    this.kv.set(identifier, value);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
}

// node_modules/superjson/dist/class-registry.js
class ClassRegistry extends Registry {
  constructor() {
    super((c) => c.name);
    this.classToAllowedProps = new Map;
  }
  register(value, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value, options.allowProps);
      }
      super.register(value, options.identifier);
    } else {
      super.register(value, options);
    }
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
}

// node_modules/superjson/dist/util.js
function valuesOfObject(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  const values = [];
  for (const key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  const values = valuesOfObject(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  const valuesNotNever = values;
  for (const value of valuesNotNever) {
    if (predicate(value)) {
      return value;
    }
  }
  return;
}
function forEach(record, run) {
  for (const [key, value] of Object.entries(record)) run(value, key);
}
function includes(array, value) {
  return array.includes(value);
}
function findArray(record, predicate) {
  for (const value of record) {
    if (predicate(value)) {
      return value;
    }
  }
  return;
}

// node_modules/superjson/dist/custom-transformer-registry.js
class CustomTransformerRegistry {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v));
  }
  findByName(name) {
    return this.transfomers[name];
  }
}

// node_modules/superjson/dist/is.js
const getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
const isUndefined = (payload) => payload === undefined;
const isNull = (payload) => payload === null;
const isPlainObject = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
const isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;
const isArray = (payload) => Array.isArray(payload);
const isString = (payload) => typeof payload === "string";
const isNumber = (payload) => typeof payload === "number" && !isNaN(payload);
const isBoolean = (payload) => typeof payload === "boolean";
const isRegExp = (payload) => payload instanceof RegExp;
const isMap = (payload) => payload instanceof Map;
const isSet = (payload) => payload instanceof Set;
const isSymbol = (payload) => getType(payload) === "Symbol";
const isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
const isError = (payload) => payload instanceof Error;
const isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
const isPrimitive = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
const isBigint = (payload) => typeof payload === "bigint";
const isInfinite = (payload) => payload === Infinity || payload === -Infinity;
const isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
const isURL = (payload) => payload instanceof URL;

// node_modules/superjson/dist/pathstringifier.js
const escapeKey = (key) => key.replaceAll('.', String.raw`\.`);
const stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
const parsePath = (string) => {
  const result = [];
  let segment = "";
  for (let index_ = 0;index_ < string.length; index_++) {
    const char = string.charAt(index_);
    const isEscapedDot = char === "\\" && string.charAt(index_ + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      index_++;
      continue;
    }
    const isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  result.push(lastSegment);
  return result;
};

// node_modules/superjson/dist/transformer.js
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
const simpleRules = [
  simpleTransformation(isUndefined, "undefined", () => null, () => {
    return;
  }),
  simpleTransformation(isBigint, "bigint", (v) => v.toString(), (v) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", (v) => v.toISOString(), (v) => new Date(v)),
  simpleTransformation(isError, "Error", (v, superJson) => {
    const baseError = {
      name: v.name,
      message: v.message
    };
    for (const property of superJson.allowedErrorProps) {
      baseError[property] = v[property];
    }
    return baseError;
  }, (v, superJson) => {
    const e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    for (const property of superJson.allowedErrorProps) {
      e[property] = v[property];
    }
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", (v) => "" + v, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(isSet, "set", (v) => [...v.values()], (v) => new Set(v)),
  simpleTransformation(isMap, "map", (v) => [...v.entries()], (v) => new Map(v)),
  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), "number", (v) => {
    if (isNaNValue(v)) {
      return "NaN";
    }
    return v > 0 ? "Infinity" : "-Infinity";
  }, Number),
  simpleTransformation((v) => v === 0 && 1 / v === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v) => v.toString(), (v) => new URL(v))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
const symbolRule = compositeTransformation((s, superJson) => {
  if (isSymbol(s)) {
    const isRegistered = Boolean(superJson.symbolRegistry.getIdentifier(s));
    return isRegistered;
  }
  return false;
}, (s, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s);
  return ["symbol", identifier];
}, (v) => v.description, (_, a, superJson) => {
  const value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
const constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((object, ctor) => {
  object[ctor.name] = ctor;
  return object;
}, {});
const typedArrayRule = compositeTransformation(isTypedArray, (v) => ["typed-array", v.constructor.name], (v) => [...v], (v, a) => {
  const ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass?.constructor) {
    const isRegistered = Boolean(superJson.classRegistry.getIdentifier(potentialClass.constructor));
    return isRegistered;
  }
  return false;
}
const classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProperties = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProperties) {
    return { ...clazz };
  }
  const result = {};
  for (const property of allowedProperties) {
    result[property] = clazz[property];
  }
  return result;
}, (v, a, superJson) => {
  const clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
const customRule = compositeTransformation((value, superJson) => {
  return Boolean(superJson.customTransformerRegistry.findApplicable(value));
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, (v, a, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
const compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
const transformValue = (value, superJson) => {
  const applicableCompositeRule = findArray(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  const applicableSimpleRule = findArray(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return;
};
const simpleRulesByAnnotation = {};
for (const rule of simpleRules) {
  simpleRulesByAnnotation[rule.annotation] = rule;
}
const untransformValue = (json, type, superJson) => {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol": {
        return symbolRule.untransform(json, type, superJson);
      }
      case "class": {
        return classRule.untransform(json, type, superJson);
      }
      case "custom": {
        return customRule.untransform(json, type, superJson);
      }
      case "typed-array": {
        return typedArrayRule.untransform(json, type, superJson);
      }
      default: {
        throw new Error("Unknown transformation: " + type);
      }
    }
  } else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};

// node_modules/superjson/dist/accessDeep.js
const getNthKey = (value, n) => {
  if (n > value.size)
    throw new Error("index out of bounds");
  const keys = value.keys();
  while (n > 0) {
    keys.next();
    n--;
  }
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
const getDeep = (object, path) => {
  validatePath(path);
  for (let index_ = 0;index_ < path.length; index_++) {
    const key = path[index_];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      const row = +key;
      const type = +path[++index_] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key": {
          object = keyOfRow;
          break;
        }
        case "value": {
          object = object.get(keyOfRow);
          break;
        }
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
const setDeep = (object, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  let parent = object;
  for (let index_ = 0;index_ < path.length - 1; index_++) {
    const key = path[index_];
    if (isArray(parent)) {
      const index2 = +key;
      parent = parent[index2];
    } else if (isPlainObject(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = index_ === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type = +path[++index_] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key": {
          parent = keyOfRow;
          break;
        }
        case "value": {
          parent = parent.get(keyOfRow);
          break;
        }
      }
    }
  }
  const lastKey = path.at(-1);
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path.at(-2);
    const keyToRow = getNthKey(parent, row);
    const type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};

// node_modules/superjson/dist/plainer.js
function traverse(tree, walker, origin = []) {
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker, [...origin, ...parsePath(key)]);
    });
  }
  walker(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v) => untransformValue(v, type, superJson));
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path));
    for (const identicalObjectPath of identicalPaths.map(parsePath)) {
      plain = setDeep(plain, identicalObjectPath, () => object);
    }
  }
  if (isArray(annotations)) {
    const [root, other] = annotations;
    for (const identicalPath of root) {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    }
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
const isDeep = (object, superJson) => isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths;
  for (let paths of identitites) {
    if (paths.length <= 1) {
      continue;
    }
    if (!dedupe) {
      paths = paths.map((path) => path.map(String)).sort((a, b) => a.length - b.length);
    }
    const [representativePath, ...identicalPaths] = paths;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  }
  if (rootEqualityPaths) {
    return isEmptyObject(result) ? [rootEqualityPaths] : [rootEqualityPaths, result];
  } else {
    return isEmptyObject(result) ? undefined : result;
  }
}
const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = new Map) => {
  const primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson);
    const result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result2);
    }
    return result2;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object, superJson);
  const transformed = transformationResult?.value ?? object;
  const transformedValue = isArray(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value, index2) => {
    if (index2 === "__proto__" || index2 === "constructor" || index2 === "prototype") {
      throw new Error(`Detected property ${index2}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index2], [...objectsInThisPath, object], seenObjects);
    transformedValue[index2] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index2] = recursiveResult.annotations;
    } else if (isPlainObject(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index2) + "." + key] = tree;
      });
    }
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: transformationResult ? [transformationResult.type] : undefined
  } : {
    transformedValue,
    annotations: transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
};

// node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject2(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return Boolean(prototype) && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull2(payload) {
  return getType2(payload) === "Null";
}
function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || Boolean(c) && c(value) || Boolean(d) && d(value) || Boolean(e) && e(value);
}
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
const isNullOrUndefined = isOneOf(isNull2, isUndefined2);

// node_modules/copy-anything/dist/index.js
function assignProperty(carry, key, newValue, originalObject, includeNonenumerable) {
  const propertyType = Object.prototype.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propertyType === "enumerable")
    carry[key] = newValue;
  if (includeNonenumerable && propertyType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newValue,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject2(target)) {
    return target;
  }
  const properties = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...properties, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const value = target[key];
    const newValue = copy(value, options);
    assignProperty(carry, key, newValue, target, options.nonenumerable);
    return carry;
  }, {});
}

// node_modules/superjson/dist/index.js
class SuperJSON {
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry;
    this.symbolRegistry = new Registry((s) => s.description ?? "");
    this.customTransformerRegistry = new CustomTransformerRegistry;
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = new Map;
    const output = walker(object, identities, this, this.dedupe);
    const res = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res.meta = {
        ...res.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res.meta = {
        ...res.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    return res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    if (meta?.values) {
      result = applyValueAnnotations(result, meta.values, this);
    }
    if (meta?.referentialEqualities) {
      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
    }
    return result;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string) {
    return this.deserialize(JSON.parse(string));
  }
  registerClass(v, options) {
    this.classRegistry.register(v, options);
  }
  registerSymbol(v, identifier) {
    this.symbolRegistry.register(v, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...properties) {
    this.allowedErrorProps.push(...properties);
  }
}
SuperJSON.defaultInstance = new SuperJSON;
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
const serialize = SuperJSON.serialize;
const deserialize = SuperJSON.deserialize;
const stringify3 = SuperJSON.stringify;
const parse = SuperJSON.parse;
const registerClass = SuperJSON.registerClass;
const registerCustom = SuperJSON.registerCustom;
const registerSymbol = SuperJSON.registerSymbol;
const allowErrorProperties = SuperJSON.allowErrorProps;

// src/hooks/useUpdateable.ts
const depUpdateLog = [];
const manUpdateLog = [];
function useUpdateable(factory, deps, label, initial) {
  const [updateCount, setUpdateCount] = import_react3.useState(0);
  const [value, setValue] = initial === undefined ? import_react3.useState() : import_react3.useState(initial);
  import_react3.useEffect(() => {
    (async () => {
      const newValue = await factory();
      if (newValue !== undefined)
        setValue(newValue);
    })();
  }, [...deps, updateCount]);
  import_react3.useEffect(() => {
    if (depUpdateLog.includes(label))
      console.log(`${label} deps updated: ${value}`);
    else
      depUpdateLog.push(label);
  }, deps);
  import_react3.useEffect(() => {
    if (manUpdateLog.includes(label))
      console.log(`${label} manually updated: ${value}`);
    else
      manUpdateLog.push(label);
  }, [updateCount]);
  const update = () => setUpdateCount((c) => c + 1);
  return [value, update];
}
function useCachedUpdateable(factory, deps, label, initial) {
  const item = localStorage.getItem(label);
  if (item !== null)
    initial = SuperJSON.parse(item);
  const updateable = useUpdateable(factory, deps, label, initial);
  import_react3.useEffect(() => {
    if (updateable[0] !== undefined)
      localStorage.setItem(label, SuperJSON.stringify(updateable[0]));
  }, [updateable[0]]);
  return updateable;
}

// src/hooks/useWallet.ts
const useWallet = ({ setError }) => {
  const [clients, setClients] = import_react4.useState();
  const [chain, setChain] = import_react4.useState(42_161);
  const [account, updateAccount] = useCachedUpdateable(async () => {
    if (!clients)
      return;
    const addresses = await clients[chain].requestAddresses();
    return addresses[0];
  }, [clients], "account");
  const [isConnecting, setIsConnecting] = import_react4.useState(false);
  const [connectRequired, setConnectRequired] = import_react4.useState(false);
  const [ens] = useCachedUpdateable(async () => account === undefined ? undefined : await publicClients[1].getEnsName({ address: account }) ?? undefined, [account], "ens");
  const connectWallet = import_react4.useCallback(() => {
    if (globalThis.ethereum === undefined)
      return setError("No wallet found. Please install MetaMask to use Reefi.");
    setIsConnecting(true);
    const clients2 = {
      56: createWalletClient({ chain: bsc, transport: custom(globalThis.ethereum) }).extend(publicActions),
      42_161: createWalletClient({ chain: arbitrum, transport: custom(globalThis.ethereum) }).extend(publicActions)
    };
    setClients(clients2);
    updateAccount();
    setIsConnecting(false);
    setConnectRequired(false);
  }, []);
  import_react4.useEffect(() => {
    if (globalThis.ethereum)
      connectWallet();
    const savedChain = globalThis.localStorage.getItem("chain");
    if (savedChain !== null)
      setChain(Number(savedChain));
  }, []);
  import_react4.useEffect(() => {
    if (clients)
      (async () => clients[chain].switchChain({ id: chain }))().catch(() => setError("Failed to switch chains"));
    connectWallet();
  }, [chain]);
  return { clients, chain, account, isConnecting, connectRequired, connectWallet, setChain, setConnectRequired, ens };
};

// src/hooks/useBalances.ts
const useBalances = ({ wallet }) => {
  const MGP = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].MGP.read.balanceOf([wallet.account]), [contracts, wallet.account], "mgp balance", 0n);
  const rMGP2 = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].rMGP.read.balanceOf([wallet.account]), [contracts, wallet.account], "rmgp balance", 0n);
  const yMGP2 = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].yMGP.read.balanceOf([wallet.account]), [contracts, wallet.account], "ymgp balance", 0n);
  const cMGP2 = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].cMGP.read.balanceOf([wallet.account]), [contracts, wallet.account], "cmgp balance", 0n);
  const CKP = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].CKP.read.balanceOf([wallet.account]), [contracts, wallet.account], "CKP balance", 0n);
  const PNP = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].PNP.read.balanceOf([wallet.account]), [contracts, wallet.account], "PNP balance", 0n);
  const EGP = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].EGP.read.balanceOf([wallet.account]), [contracts, wallet.account], "EGP balance", 0n);
  const LTP = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].LTP.read.balanceOf([wallet.account]), [contracts, wallet.account], "LTP balance", 0n);
  const WETH2 = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].WETH.read.balanceOf([wallet.account]), [contracts, wallet.account], "WETH balance", 0n);
  const ETH = useCachedUpdateable(() => wallet.account === undefined ? 0n : publicClients[wallet.chain].getBalance({ address: wallet.account }), [contracts, wallet.account], "ETH balance", 0n);
  const [mgpCurve, updateMGPCurve] = useCachedUpdateable(() => contracts[wallet.chain].MGP.read.balanceOf([contracts[wallet.chain].cMGP.address]), [contracts, wallet.chain, wallet.account], "mgpCurve balance", 0n);
  const [rmgpCurve, updateRMGPCurve] = useCachedUpdateable(() => contracts[wallet.chain].rMGP.read.balanceOf([contracts[wallet.chain].cMGP.address]), [contracts, wallet.chain, wallet.account], "rmgpCurve balance", 0n);
  const [ymgpCurve, updateYMGPCurve] = useCachedUpdateable(() => contracts[wallet.chain].yMGP.read.balanceOf([contracts[wallet.chain].cMGP.address]), [contracts, wallet.chain, wallet.account], "ymgpCurve balance", 0n);
  const [ymgpHoldings, updateYMGPHoldings] = useCachedUpdateable(() => contracts[wallet.chain].rMGP.read.balanceOf([contracts[wallet.chain].yMGP.address]), [contracts, wallet.chain, wallet.account], "ymgpHoldings balance", 0n);
  return { MGP, rMGP: rMGP2, yMGP: yMGP2, cMGP: cMGP2, CKP, PNP, EGP, LTP, WETH: WETH2, ETH, mgpCurve, rmgpCurve, ymgpCurve, ymgpHoldings, updateMGPCurve, updateRMGPCurve, updateYMGPCurve, updateYMGPHoldings };
};

// src/hooks/useAllowances.ts
const useAllowances = ({ wallet }) => {
  const MGP = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].MGP.read.allowance([wallet.account, contracts[wallet.chain].rMGP.address]), [contracts, wallet.chain, wallet.account], "mgp allowance", 0n);
  const rMGP2 = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].rMGP.read.allowance([wallet.account, contracts[wallet.chain].yMGP.address]), [contracts, wallet.chain, wallet.account], "rmgp allowance", 0n);
  const curve = {
    MGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].MGP.read.allowance([wallet.account, contracts[wallet.chain].cMGP.address]), [contracts, wallet.chain, wallet.account], "mgpCurve allowance", 0n),
    rMGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].rMGP.read.allowance([wallet.account, contracts[wallet.chain].cMGP.address]), [contracts, wallet.chain, wallet.account], "rmgpCurve allowance", 0n),
    yMGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].yMGP.read.allowance([wallet.account, contracts[wallet.chain].cMGP.address]), [contracts, wallet.account], "ymgpCurve allowance", 0n),
    cMGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].cMGP.read.allowance([wallet.account, contracts[wallet.chain].cMGP.address]), [contracts, wallet.account], "CMGPCurve allowance", 0n)
  };
  const odos = {
    MGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].MGP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.chain, wallet.account], "mgp ODOS allowance", 0n),
    rMGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].rMGP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.chain, wallet.account], "rmgp ODOS allowance", 0n),
    yMGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].yMGP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.account], "ymgp ODOS allowance", 0n),
    cMGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].cMGP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.account], "CMGP ODOS allowance", 0n),
    CKP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].CKP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.account], "CKP ODOS allowance", 0n),
    PNP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].PNP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.account], "PNP ODOS allowance", 0n),
    EGP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].EGP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.account], "EGP ODOS allowance", 0n),
    LTP: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].LTP.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.account], "LTP ODOS allowance", 0n),
    WETH: useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].WETH.read.allowance([wallet.account, contracts[wallet.chain].ODOSRouter.address]), [contracts, wallet.account], "WETH ODOS allowance", 0n)
  };
  return { MGP, rMGP: rMGP2, curve, odos };
};

// src/hooks/actions/useApprove.ts
const import_react5 = __toESM(require_react(), 1);
const useApprove = ({ account, allowances, chain, clients, page, sendAmount, setConnectRequired, writeContracts }) => {
  const accountReference = import_react5.useRef(account);
  const allowancesReference = import_react5.useRef(allowances);
  const chainReference = import_react5.useRef(chain);
  const clientsReference = import_react5.useRef(clients);
  const pageReference = import_react5.useRef(page);
  const sendAmountReference = import_react5.useRef(sendAmount);
  const setConnectRequiredReference = import_react5.useRef(setConnectRequired);
  const writeContractsReference = import_react5.useRef(writeContracts);
  import_react5.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react5.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react5.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react5.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react5.useEffect(() => {
    pageReference.current = page;
  }, [page]);
  import_react5.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react5.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react5.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const approve = import_react5.useCallback(async (contract, coin, infinity) => {
    if (clientsReference.current === undefined || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    const amount = infinity ? 2n ** 256n - 1n : sendAmountReference.current;
    await writeContractsReference.current[chainReference.current][coin].write.approve([contracts[chainReference.current][contract].address, amount], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    if (contract === "cMGP")
      allowancesReference.current.curve[coin][1]();
    else if (contract === "ODOSRouter")
      allowancesReference.current.odos[coin][1]();
    else
      allowancesReference.current.curve[coin][1]();
  }, []);
  return approve;
};

// src/hooks/actions/useBuyRMGP.ts
const import_react6 = __toESM(require_react(), 1);
const useBuyRMGP = ({ account, allowances, balances, chain, clients, sendAmount, setConnectRequired, setError, writeContracts }) => {
  const accountReference = import_react6.useRef(account);
  const allowancesReference = import_react6.useRef(allowances);
  const balancesReference = import_react6.useRef(balances);
  const chainReference = import_react6.useRef(chain);
  const clientsReference = import_react6.useRef(clients);
  const sendAmountReference = import_react6.useRef(sendAmount);
  const setConnectRequiredReference = import_react6.useRef(setConnectRequired);
  const setErrorReference = import_react6.useRef(setError);
  const writeContractsReference = import_react6.useRef(writeContracts);
  import_react6.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react6.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react6.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react6.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react6.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react6.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react6.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react6.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react6.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const buyRMGP = import_react6.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.curve.MGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].cMGP.write.exchange([0n, 1n, sendAmountReference.current, 0n], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.MGP[1]();
    balancesReference.current.rMGP[1]();
    balancesReference.current.updateMGPCurve();
    balancesReference.current.updateRMGPCurve();
  }, []);
  return buyRMGP;
};

// src/hooks/actions/useDepositRMGP.ts
const import_react7 = __toESM(require_react(), 1);
const useDepositRMGP = ({ account, allowances, balances, chain, clients, sendAmount, setConnectRequired, setError, supplies, updateYMGPHoldings, writeContracts }) => {
  const accountReference = import_react7.useRef(account);
  const allowancesReference = import_react7.useRef(allowances);
  const balancesReference = import_react7.useRef(balances);
  const chainReference = import_react7.useRef(chain);
  const clientsReference = import_react7.useRef(clients);
  const sendAmountReference = import_react7.useRef(sendAmount);
  const setConnectRequiredReference = import_react7.useRef(setConnectRequired);
  const setErrorReference = import_react7.useRef(setError);
  const suppliesReference = import_react7.useRef(supplies);
  const updateYMGPHoldingsReference = import_react7.useRef(updateYMGPHoldings);
  const writeContractsReference = import_react7.useRef(writeContracts);
  import_react7.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react7.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react7.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react7.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react7.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react7.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react7.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react7.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react7.useEffect(() => {
    suppliesReference.current = supplies;
  }, [supplies]);
  import_react7.useEffect(() => {
    updateYMGPHoldingsReference.current = updateYMGPHoldings;
  }, [updateYMGPHoldings]);
  import_react7.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const depositRMGP = import_react7.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.rMGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].yMGP.write.deposit([sendAmountReference.current], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.rMGP[1]();
    balancesReference.current.yMGP[1]();
    suppliesReference.current.updateRMGP();
    suppliesReference.current.updateYMGP();
    updateYMGPHoldingsReference.current();
  }, []);
  return depositRMGP;
};

// src/hooks/actions/useCompoundRMGP.ts
const import_react8 = __toESM(require_react(), 1);
const useCompoundRMGP = ({ account, balances, chain, clients, setConnectRequired, supplies, updatePendingRewards, updateReefiLockedMGP, updateTotalLockedMGP, updateUnclaimedUserYield, writeContracts }) => {
  const accountReference = import_react8.useRef(account);
  const balancesReference = import_react8.useRef(balances);
  const chainReference = import_react8.useRef(chain);
  const clientsReference = import_react8.useRef(clients);
  const setConnectRequiredReference = import_react8.useRef(setConnectRequired);
  const suppliesReference = import_react8.useRef(supplies);
  const updatePendingRewardsReference = import_react8.useRef(updatePendingRewards);
  const updateReefiLockedMGPReference = import_react8.useRef(updateReefiLockedMGP);
  const updateTotalLockedMGPReference = import_react8.useRef(updateTotalLockedMGP);
  const updateUnclaimedUserYieldReference = import_react8.useRef(updateUnclaimedUserYield);
  const writeContractsReference = import_react8.useRef(writeContracts);
  import_react8.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react8.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react8.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react8.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react8.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react8.useEffect(() => {
    suppliesReference.current = supplies;
  }, [supplies]);
  import_react8.useEffect(() => {
    updatePendingRewardsReference.current = updatePendingRewards;
  }, [updatePendingRewards]);
  import_react8.useEffect(() => {
    updateReefiLockedMGPReference.current = updateReefiLockedMGP;
  }, [updateReefiLockedMGP]);
  import_react8.useEffect(() => {
    updateTotalLockedMGPReference.current = updateTotalLockedMGP;
  }, [updateTotalLockedMGP]);
  import_react8.useEffect(() => {
    updateUnclaimedUserYieldReference.current = updateUnclaimedUserYield;
  }, [updateUnclaimedUserYield]);
  import_react8.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const compoundRMGP = import_react8.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    await writeContractsReference.current[chainReference.current].rMGP.write.claim({ account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    updatePendingRewardsReference.current();
    updateUnclaimedUserYieldReference.current();
    suppliesReference.current.updateRMGP();
    balancesReference.current.rMGP[1]();
    updateTotalLockedMGPReference.current();
    updateReefiLockedMGPReference.current();
  }, []);
  return compoundRMGP;
};

// src/hooks/actions/useClaimYMGPRewards.ts
const import_react9 = __toESM(require_react(), 1);
const useClaimYMGPRewards = ({ account, chain, clients, setConnectRequired, updateUnclaimedUserYield, writeContracts }) => {
  const accountReference = import_react9.useRef(account);
  const chainReference = import_react9.useRef(chain);
  const clientsReference = import_react9.useRef(clients);
  const setConnectRequiredReference = import_react9.useRef(setConnectRequired);
  const updateUnclaimedUserYieldReference = import_react9.useRef(updateUnclaimedUserYield);
  const writeContractsReference = import_react9.useRef(writeContracts);
  import_react9.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react9.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react9.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react9.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react9.useEffect(() => {
    updateUnclaimedUserYieldReference.current = updateUnclaimedUserYield;
  }, [updateUnclaimedUserYield]);
  import_react9.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const claimYMGPRewards = import_react9.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    await writeContractsReference.current[chainReference.current].yMGP.write.claim({ account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    updateUnclaimedUserYieldReference.current();
  }, []);
  return claimYMGPRewards;
};

// src/hooks/actions/useSupplyLiquidity.ts
const import_react10 = __toESM(require_react(), 1);
const useSupplyLiquidity = ({ account, balances, chain, clients, mgpLPAmount, rmgpLPAmount, setConnectRequired, writeContracts, ymgpLPAmount }) => {
  const accountReference = import_react10.useRef(account);
  const balancesReference = import_react10.useRef(balances);
  const chainReference = import_react10.useRef(chain);
  const clientsReference = import_react10.useRef(clients);
  const mgpLPAmountReference = import_react10.useRef(mgpLPAmount);
  const rmgpLPAmountReference = import_react10.useRef(rmgpLPAmount);
  const setConnectRequiredReference = import_react10.useRef(setConnectRequired);
  const writeContractsReference = import_react10.useRef(writeContracts);
  const ymgpLPAmountReference = import_react10.useRef(ymgpLPAmount);
  import_react10.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react10.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react10.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react10.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react10.useEffect(() => {
    mgpLPAmountReference.current = mgpLPAmount;
  }, [mgpLPAmount]);
  import_react10.useEffect(() => {
    rmgpLPAmountReference.current = rmgpLPAmount;
  }, [rmgpLPAmount]);
  import_react10.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react10.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  import_react10.useEffect(() => {
    ymgpLPAmountReference.current = ymgpLPAmount;
  }, [ymgpLPAmount]);
  const supplyLiquidity = import_react10.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    await writeContractsReference.current[chainReference.current].cMGP.write.add_liquidity([[mgpLPAmountReference.current, rmgpLPAmountReference.current, ymgpLPAmountReference.current], 0n], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.MGP[1]();
    balancesReference.current.rMGP[1]();
    balancesReference.current.yMGP[1]();
    balancesReference.current.cMGP[1]();
    balancesReference.current.updateMGPCurve();
    balancesReference.current.updateRMGPCurve();
    balancesReference.current.updateYMGPCurve();
  }, []);
  return supplyLiquidity;
};

// src/hooks/actions/useDepositMGP.ts
const import_react11 = __toESM(require_react(), 1);
const useDepositMGP = ({ account, allowances, balances, chain, clients, sendAmount, setConnectRequired, setError, supplies, updateReefiLockedMGP, updateTotalLockedMGP, writeContracts }) => {
  const accountReference = import_react11.useRef(account);
  const allowancesReference = import_react11.useRef(allowances);
  const balancesReference = import_react11.useRef(balances);
  const chainReference = import_react11.useRef(chain);
  const clientsReference = import_react11.useRef(clients);
  const sendAmountReference = import_react11.useRef(sendAmount);
  const setConnectRequiredReference = import_react11.useRef(setConnectRequired);
  const setErrorReference = import_react11.useRef(setError);
  const suppliesReference = import_react11.useRef(supplies);
  const updateReefiLockedMGPReference = import_react11.useRef(updateReefiLockedMGP);
  const updateTotalLockedMGPReference = import_react11.useRef(updateTotalLockedMGP);
  const writeContractsReference = import_react11.useRef(writeContracts);
  import_react11.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react11.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react11.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react11.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react11.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react11.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react11.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react11.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react11.useEffect(() => {
    suppliesReference.current = supplies;
  }, [supplies]);
  import_react11.useEffect(() => {
    updateReefiLockedMGPReference.current = updateReefiLockedMGP;
  }, [updateReefiLockedMGP]);
  import_react11.useEffect(() => {
    updateTotalLockedMGPReference.current = updateTotalLockedMGP;
  }, [updateTotalLockedMGP]);
  import_react11.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const depositMGP = import_react11.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.MGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].rMGP.write.deposit([sendAmountReference.current], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.MGP[1]();
    balancesReference.current.rMGP[1]();
    suppliesReference.current.updateMGP();
    suppliesReference.current.updateRMGP();
    updateTotalLockedMGPReference.current();
    updateReefiLockedMGPReference.current();
  }, []);
  return depositMGP;
};

// src/hooks/actions/useBuyYMGP.ts
const import_react12 = __toESM(require_react(), 1);
const useBuyYMGP = ({ account, allowances, balances, chain, clients, sendAmount, setConnectRequired, setError, writeContracts }) => {
  const accountReference = import_react12.useRef(account);
  const allowancesReference = import_react12.useRef(allowances);
  const balancesReference = import_react12.useRef(balances);
  const chainReference = import_react12.useRef(chain);
  const clientsReference = import_react12.useRef(clients);
  const sendAmountReference = import_react12.useRef(sendAmount);
  const setConnectRequiredReference = import_react12.useRef(setConnectRequired);
  const setErrorReference = import_react12.useRef(setError);
  const writeContractsReference = import_react12.useRef(writeContracts);
  import_react12.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react12.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react12.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react12.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react12.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react12.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react12.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react12.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react12.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const buyYMGP = import_react12.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.curve.rMGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].cMGP.write.exchange([1n, 2n, sendAmountReference.current, 0n], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.rMGP[1]();
    balancesReference.current.yMGP[1]();
    balancesReference.current.updateRMGPCurve();
    balancesReference.current.updateYMGPCurve();
  }, []);
  return buyYMGP;
};

// src/hooks/actions/useBuyMGP.ts
const import_react13 = __toESM(require_react(), 1);
const useBuyMGP = ({ account, allowances, balances, chain, clients, sendAmount, setConnectRequired, setError, writeContracts }) => {
  const accountReference = import_react13.useRef(account);
  const allowancesReference = import_react13.useRef(allowances);
  const balancesReference = import_react13.useRef(balances);
  const chainReference = import_react13.useRef(chain);
  const clientsReference = import_react13.useRef(clients);
  const sendAmountReference = import_react13.useRef(sendAmount);
  const setConnectRequiredReference = import_react13.useRef(setConnectRequired);
  const setErrorReference = import_react13.useRef(setError);
  const writeContractsReference = import_react13.useRef(writeContracts);
  import_react13.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react13.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react13.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react13.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react13.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react13.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react13.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react13.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react13.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const buyMGP = import_react13.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.curve.rMGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].cMGP.write.exchange([1n, 0n, sendAmountReference.current, 0n], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.MGP[1]();
    balancesReference.current.rMGP[1]();
    balancesReference.current.updateMGPCurve();
    balancesReference.current.updateRMGPCurve();
  }, []);
  return buyMGP;
};

// src/hooks/actions/useLockYMGP.ts
const import_react14 = __toESM(require_react(), 1);
const useLockYMGP = ({ account, chain, clients, sendAmount, setConnectRequired, supplies, updateTotalLockedYMGP, updateUserLockedYMGP, writeContracts }) => {
  const accountReference = import_react14.useRef(account);
  const chainReference = import_react14.useRef(chain);
  const clientsReference = import_react14.useRef(clients);
  const sendAmountReference = import_react14.useRef(sendAmount);
  const setConnectRequiredReference = import_react14.useRef(setConnectRequired);
  const suppliesReference = import_react14.useRef(supplies);
  const updateTotalLockedYMGPReference = import_react14.useRef(updateTotalLockedYMGP);
  const updateUserLockedYMGPReference = import_react14.useRef(updateUserLockedYMGP);
  const writeContractsReference = import_react14.useRef(writeContracts);
  import_react14.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react14.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react14.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react14.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react14.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react14.useEffect(() => {
    suppliesReference.current = supplies;
  }, [supplies]);
  import_react14.useEffect(() => {
    updateTotalLockedYMGPReference.current = updateTotalLockedYMGP;
  }, [updateTotalLockedYMGP]);
  import_react14.useEffect(() => {
    updateUserLockedYMGPReference.current = updateUserLockedYMGP;
  }, [updateUserLockedYMGP]);
  import_react14.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const lockYMGP = import_react14.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    await writeContractsReference.current[chainReference.current].yMGP.write.lock([sendAmountReference.current], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    suppliesReference.current.updateYMGP();
    updateTotalLockedYMGPReference.current();
    updateUserLockedYMGPReference.current();
  }, []);
  return lockYMGP;
};

// src/hooks/actions/useUnlockYMGP.ts
const import_react15 = __toESM(require_react(), 1);
const useUnlockYMGP = ({ account, chain, clients, sendAmount, setConnectRequired, supplies, updateTotalLockedYMGP, updateUserLockedYMGP, writeContracts }) => {
  const accountReference = import_react15.useRef(account);
  const chainReference = import_react15.useRef(chain);
  const clientsReference = import_react15.useRef(clients);
  const sendAmountReference = import_react15.useRef(sendAmount);
  const setConnectRequiredReference = import_react15.useRef(setConnectRequired);
  const suppliesReference = import_react15.useRef(supplies);
  const updateTotalLockedYMGPReference = import_react15.useRef(updateTotalLockedYMGP);
  const updateUserLockedYMGPReference = import_react15.useRef(updateUserLockedYMGP);
  const writeContractsReference = import_react15.useRef(writeContracts);
  import_react15.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react15.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react15.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react15.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react15.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react15.useEffect(() => {
    suppliesReference.current = supplies;
  }, [supplies]);
  import_react15.useEffect(() => {
    updateTotalLockedYMGPReference.current = updateTotalLockedYMGP;
  }, [updateTotalLockedYMGP]);
  import_react15.useEffect(() => {
    updateUserLockedYMGPReference.current = updateUserLockedYMGP;
  }, [updateUserLockedYMGP]);
  import_react15.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const unlockYMGP = import_react15.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    await writeContractsReference.current[chainReference.current].yMGP.write.unlock([sendAmountReference.current], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    suppliesReference.current.updateYMGP();
    updateTotalLockedYMGPReference.current();
    updateUserLockedYMGPReference.current();
  }, []);
  return unlockYMGP;
};

// src/hooks/actions/useRedeemRMGP.ts
const import_react16 = __toESM(require_react(), 1);
const useRedeemRMGP = ({ account, balances, chain, clients, sendAmount, setConnectRequired, supplies, updateReefiLockedMGP, updateTotalLockedMGP, updateUnclaimedUserYield, updateUnlockSchedule, updateUnsubmittedWithdraws, updateUserPendingWithdraws, updateUserWithdrawable, writeContracts }) => {
  const accountReference = import_react16.useRef(account);
  const balancesReference = import_react16.useRef(balances);
  const chainReference = import_react16.useRef(chain);
  const clientsReference = import_react16.useRef(clients);
  const sendAmountReference = import_react16.useRef(sendAmount);
  const setConnectRequiredReference = import_react16.useRef(setConnectRequired);
  const suppliesReference = import_react16.useRef(supplies);
  const updateReefiLockedMGPReference = import_react16.useRef(updateReefiLockedMGP);
  const updateTotalLockedMGPReference = import_react16.useRef(updateTotalLockedMGP);
  const updateUnclaimedUserYieldReference = import_react16.useRef(updateUnclaimedUserYield);
  const updateUnlockScheduleReference = import_react16.useRef(updateUnlockSchedule);
  const updateUnsubmittedWithdrawsReference = import_react16.useRef(updateUnsubmittedWithdraws);
  const updateUserPendingWithdrawsReference = import_react16.useRef(updateUserPendingWithdraws);
  const updateUserWithdrawableReference = import_react16.useRef(updateUserWithdrawable);
  const writeContractsReference = import_react16.useRef(writeContracts);
  import_react16.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react16.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react16.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react16.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react16.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react16.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react16.useEffect(() => {
    suppliesReference.current = supplies;
  }, [supplies]);
  import_react16.useEffect(() => {
    updateReefiLockedMGPReference.current = updateReefiLockedMGP;
  }, [updateReefiLockedMGP]);
  import_react16.useEffect(() => {
    updateTotalLockedMGPReference.current = updateTotalLockedMGP;
  }, [updateTotalLockedMGP]);
  import_react16.useEffect(() => {
    updateUnclaimedUserYieldReference.current = updateUnclaimedUserYield;
  }, [updateUnclaimedUserYield]);
  import_react16.useEffect(() => {
    updateUnlockScheduleReference.current = updateUnlockSchedule;
  }, [updateUnlockSchedule]);
  import_react16.useEffect(() => {
    updateUnsubmittedWithdrawsReference.current = updateUnsubmittedWithdraws;
  }, [updateUnsubmittedWithdraws]);
  import_react16.useEffect(() => {
    updateUserPendingWithdrawsReference.current = updateUserPendingWithdraws;
  }, [updateUserPendingWithdraws]);
  import_react16.useEffect(() => {
    updateUserWithdrawableReference.current = updateUserWithdrawable;
  }, [updateUserWithdrawable]);
  import_react16.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const redeemRMGP = import_react16.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    await writeContractsReference.current[chainReference.current].rMGP.write.startUnlock([sendAmountReference.current], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    updateUnlockScheduleReference.current();
    suppliesReference.current.updateRMGP();
    balancesReference.current.rMGP[1]();
    updateTotalLockedMGPReference.current();
    updateReefiLockedMGPReference.current();
    updateUserPendingWithdrawsReference.current();
    updateUnsubmittedWithdrawsReference.current();
    updateUserWithdrawableReference.current();
    updateUnclaimedUserYieldReference.current();
  }, []);
  return redeemRMGP;
};

// src/hooks/actions/useWithdrawMGP.ts
const import_react17 = __toESM(require_react(), 1);
const useWithdrawMGP = ({ account, balances, chain, clients, setConnectRequired, updateUnsubmittedWithdraws, updateUserPendingWithdraws, updateUserWithdrawable, writeContracts }) => {
  const accountReference = import_react17.useRef(account);
  const balancesReference = import_react17.useRef(balances);
  const chainReference = import_react17.useRef(chain);
  const clientsReference = import_react17.useRef(clients);
  const setConnectRequiredReference = import_react17.useRef(setConnectRequired);
  const updateUnsubmittedWithdrawsReference = import_react17.useRef(updateUnsubmittedWithdraws);
  const updateUserPendingWithdrawsReference = import_react17.useRef(updateUserPendingWithdraws);
  const updateUserWithdrawableReference = import_react17.useRef(updateUserWithdrawable);
  const writeContractsReference = import_react17.useRef(writeContracts);
  import_react17.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react17.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react17.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react17.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react17.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react17.useEffect(() => {
    updateUnsubmittedWithdrawsReference.current = updateUnsubmittedWithdraws;
  }, [updateUnsubmittedWithdraws]);
  import_react17.useEffect(() => {
    updateUserPendingWithdrawsReference.current = updateUserPendingWithdraws;
  }, [updateUserPendingWithdraws]);
  import_react17.useEffect(() => {
    updateUserWithdrawableReference.current = updateUserWithdrawable;
  }, [updateUserWithdrawable]);
  import_react17.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const withdrawMGP = import_react17.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    await writeContractsReference.current[chainReference.current].rMGP.write.unlock({ account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    await writeContractsReference.current[chainReference.current].rMGP.write.withdraw({ account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.MGP[1]();
    updateUserPendingWithdrawsReference.current();
    updateUnsubmittedWithdrawsReference.current();
    updateUserWithdrawableReference.current();
  }, []);
  return withdrawMGP;
};

// src/hooks/actions/useSwap.ts
const import_react18 = __toESM(require_react(), 1);
const useSwap = ({ account, allowances, chain, clients, sendAmount, setConnectRequired, setError, setNotification }) => {
  const accountReference = import_react18.useRef(account);
  const allowancesReference = import_react18.useRef(allowances);
  const chainReference = import_react18.useRef(chain);
  const clientsReference = import_react18.useRef(clients);
  const sendAmountReference = import_react18.useRef(sendAmount);
  const setConnectRequiredReference = import_react18.useRef(setConnectRequired);
  const setErrorReference = import_react18.useRef(setError);
  const setNotificationReference = import_react18.useRef(setNotification);
  import_react18.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react18.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react18.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react18.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react18.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react18.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react18.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react18.useEffect(() => {
    setNotificationReference.current = setNotification;
  }, [setNotification]);
  const buyRMGP = import_react18.useCallback(async (tokenIn, tokenOut) => {
    if (!clientsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.curve.MGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    setNotificationReference.current("Fetching swap route");
    const quoteRequestBody = {
      chainId: chainReference.current,
      inputTokens: [{ tokenAddress: tokenIn, amount: String(sendAmountReference.current) }],
      outputTokens: [{ tokenAddress: tokenOut, proportion: 1 }],
      userAddr: accountReference.current,
      slippageLimitPercent: 5,
      referralCode: 0,
      disableRFQs: true,
      compact: true
    };
    const response = await fetch("https://api.odos.xyz/sor/quote/v2", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(quoteRequestBody) });
    if (!response.ok)
      return setError("Failed to find route");
    setNotificationReference.current("Assembling transaction");
    const assembleRequestBody = { userAddr: accountReference.current, pathId: (await response.json()).pathId, simulate: false };
    const response2 = await fetch("https://api.odos.xyz/sor/assemble", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(assembleRequestBody) });
    const { transaction } = await response2.json();
    await clientsReference.current[chainReference.current].sendTransaction({ ...transaction, account: accountReference.current, chain: undefined, gas: BigInt(Math.max(transaction.gas, 0)) });
  }, []);
  return buyRMGP;
};

// src/hooks/actions/useMintWETH.ts
const import_react19 = __toESM(require_react(), 1);
const useMintWETH = ({ account, allowances, chain, clients, sendAmount, setConnectRequired, setError, writeContracts }) => {
  const accountReference = import_react19.useRef(account);
  const allowancesReference = import_react19.useRef(allowances);
  const chainReference = import_react19.useRef(chain);
  const clientsReference = import_react19.useRef(clients);
  const sendAmountReference = import_react19.useRef(sendAmount);
  const setConnectRequiredReference = import_react19.useRef(setConnectRequired);
  const setErrorReference = import_react19.useRef(setError);
  const writeContractsReference = import_react19.useRef(writeContracts);
  import_react19.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react19.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react19.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react19.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react19.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react19.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react19.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react19.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const depositMGP = import_react19.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.MGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].WETH.write.deposit({ value: sendAmountReference.current, account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
  }, []);
  return depositMGP;
};

// src/hooks/actions/useSellRMGP.ts
const import_react20 = __toESM(require_react(), 1);
const useSellRMGP = ({ account, allowances, balances, chain, clients, sendAmount, setConnectRequired, setError, writeContracts }) => {
  const accountReference = import_react20.useRef(account);
  const allowancesReference = import_react20.useRef(allowances);
  const balancesReference = import_react20.useRef(balances);
  const chainReference = import_react20.useRef(chain);
  const clientsReference = import_react20.useRef(clients);
  const sendAmountReference = import_react20.useRef(sendAmount);
  const setConnectRequiredReference = import_react20.useRef(setConnectRequired);
  const setErrorReference = import_react20.useRef(setError);
  const writeContractsReference = import_react20.useRef(writeContracts);
  import_react20.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react20.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react20.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react20.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react20.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react20.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react20.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react20.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react20.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const sellYMGP = import_react20.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.curve.yMGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].cMGP.write.exchange([2n, 1n, sendAmountReference.current, 0n], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.yMGP[1]();
    balancesReference.current.rMGP[1]();
    balancesReference.current.updateYMGPCurve();
    balancesReference.current.updateRMGPCurve();
  }, []);
  return sellYMGP;
};

// src/hooks/actions/useConvertMGP.ts
const import_react21 = __toESM(require_react(), 1);
const useConvertMGP = ({ account, allowances, balances, chain, clients, sendAmount, setConnectRequired, setError, writeContracts }) => {
  const accountReference = import_react21.useRef(account);
  const allowancesReference = import_react21.useRef(allowances);
  const balancesReference = import_react21.useRef(balances);
  const chainReference = import_react21.useRef(chain);
  const clientsReference = import_react21.useRef(clients);
  const sendAmountReference = import_react21.useRef(sendAmount);
  const setConnectRequiredReference = import_react21.useRef(setConnectRequired);
  const setErrorReference = import_react21.useRef(setError);
  const writeContractsReference = import_react21.useRef(writeContracts);
  import_react21.useEffect(() => {
    accountReference.current = account;
  }, [account]);
  import_react21.useEffect(() => {
    allowancesReference.current = allowances;
  }, [allowances]);
  import_react21.useEffect(() => {
    balancesReference.current = balances;
  }, [balances]);
  import_react21.useEffect(() => {
    chainReference.current = chain;
  }, [chain]);
  import_react21.useEffect(() => {
    clientsReference.current = clients;
  }, [clients]);
  import_react21.useEffect(() => {
    sendAmountReference.current = sendAmount;
  }, [sendAmount]);
  import_react21.useEffect(() => {
    setConnectRequiredReference.current = setConnectRequired;
  }, [setConnectRequired]);
  import_react21.useEffect(() => {
    setErrorReference.current = setError;
  }, [setError]);
  import_react21.useEffect(() => {
    writeContractsReference.current = writeContracts;
  }, [writeContracts]);
  const buyYMGP = import_react21.useCallback(async () => {
    if (!clientsReference.current || !writeContractsReference.current || accountReference.current === undefined)
      return setConnectRequiredReference.current(true);
    if (allowancesReference.current.curve.rMGP[0] < sendAmountReference.current)
      return setErrorReference.current("Allowance too low");
    await writeContractsReference.current[chainReference.current].cMGP.write.exchange([0n, 2n, sendAmountReference.current, 0n], { account: accountReference.current, chain: clientsReference.current[chainReference.current].chain });
    balancesReference.current.rMGP[1]();
    balancesReference.current.yMGP[1]();
    balancesReference.current.updateRMGPCurve();
    balancesReference.current.updateYMGPCurve();
  }, []);
  return buyYMGP;
};

// src/hooks/useActions.ts
const useActions = ({ page, setError, setNotification, wallet, balances, allowances, supplies, writeContracts, locked, amounts, withdraws, rewards }) => {
  const approve = useApprove({ account: wallet.account, allowances, chain: wallet.chain, clients: wallet.clients, page, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, writeContracts });
  const depositMGP = useDepositMGP({ account: wallet.account, allowances, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, supplies, updateReefiLockedMGP: locked.updateReefiMGP, updateTotalLockedMGP: locked.updateMGP, writeContracts });
  const buyRMGP = useBuyRMGP({ account: wallet.account, allowances, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, writeContracts });
  const sellYMGP = useSellRMGP({ account: wallet.account, allowances, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, writeContracts });
  const buyYMGP = useBuyYMGP({ account: wallet.account, allowances, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, writeContracts });
  const convertMGP = useConvertMGP({ account: wallet.account, allowances, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, writeContracts });
  const buyMGP = useBuyMGP({ account: wallet.account, allowances, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, writeContracts });
  const depositRMGP = useDepositRMGP({ account: wallet.account, allowances, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, supplies, updateYMGPHoldings: balances.updateYMGPHoldings, writeContracts });
  const lockYMGP = useLockYMGP({ account: wallet.account, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, supplies, updateTotalLockedYMGP: locked.updateMGP, updateUserLockedYMGP: locked.updateUserYMGP, writeContracts });
  const unlockYMGP = useUnlockYMGP({ account: wallet.account, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, supplies, updateTotalLockedYMGP: locked.updateMGP, updateUserLockedYMGP: locked.updateUserYMGP, writeContracts });
  const redeemRMGP = useRedeemRMGP({ account: wallet.account, balances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, supplies, updateReefiLockedMGP: locked.updateReefiMGP, updateTotalLockedMGP: locked.updateMGP, updateUnclaimedUserYield: rewards.updateUnclaimedUserYield, updateUnlockSchedule: withdraws.updateUnlockSchedule, updateUnsubmittedWithdraws: withdraws.updateUnsubmittedWithdraws, updateUserPendingWithdraws: withdraws.updateUserPendingWithdraws, updateUserWithdrawable: withdraws.updateUserWithdrawable, writeContracts });
  const withdrawMGP = useWithdrawMGP({ account: wallet.account, balances, chain: wallet.chain, clients: wallet.clients, setConnectRequired: wallet.setConnectRequired, updateUnsubmittedWithdraws: withdraws.updateUnsubmittedWithdraws, updateUserPendingWithdraws: withdraws.updateUserPendingWithdraws, updateUserWithdrawable: withdraws.updateUserWithdrawable, writeContracts });
  const compoundRMGP = useCompoundRMGP({ account: wallet.account, balances, chain: wallet.chain, clients: wallet.clients, setConnectRequired: wallet.setConnectRequired, supplies, updatePendingRewards: rewards.updatePendingRewards, updateReefiLockedMGP: locked.updateReefiMGP, updateTotalLockedMGP: locked.updateMGP, updateUnclaimedUserYield: rewards.updateUnclaimedUserYield, writeContracts });
  const claimYMGPRewards = useClaimYMGPRewards({ account: wallet.account, chain: wallet.chain, clients: wallet.clients, setConnectRequired: wallet.setConnectRequired, updateUnclaimedUserYield: rewards.updateUnclaimedUserYield, writeContracts });
  const supplyLiquidity = useSupplyLiquidity({ account: wallet.account, balances, chain: wallet.chain, clients: wallet.clients, mgpLPAmount: amounts.mgpLP, rmgpLPAmount: amounts.rmgpLP, setConnectRequired: wallet.setConnectRequired, writeContracts, ymgpLPAmount: amounts.ymgpLP });
  const swap = useSwap({ account: wallet.account, allowances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, setNotification });
  const mintWETH = useMintWETH({ account: wallet.account, allowances, chain: wallet.chain, clients: wallet.clients, sendAmount: amounts.send, setConnectRequired: wallet.setConnectRequired, setError, writeContracts });
  return { approve, depositMGP, buyRMGP, buyYMGP, buyMGP, sellYMGP, depositRMGP, lockYMGP, unlockYMGP, redeemRMGP, withdrawMGP, convertMGP, compoundRMGP, claimYMGPRewards, supplyLiquidity, swap, mintWETH };
};

// src/hooks/useAmounts.ts
const import_react22 = __toESM(require_react(), 1);
const useAmounts = ({ wallet }) => {
  const [send, setSend] = import_react22.useState(parseEther(1));
  const [mgpLP, setMGPLP] = import_react22.useState(0n);
  const [rmgpLP, setRMGPLP] = import_react22.useState(0n);
  const [ymgpLP, setYMGPLP] = import_react22.useState(0n);
  const [mgpRmgpCurve] = useCachedUpdateable(() => send === 0n ? 0n : contracts[wallet.chain].cMGP.read.get_dy([0n, 1n, send], { account: wallet.account }), [contracts, wallet.chain, send], "mgpRmgpCurveAmount", 0n);
  const [mgpYmgpCurve] = useCachedUpdateable(() => send === 0n ? 0n : contracts[wallet.chain].cMGP.read.get_dy([0n, 2n, send], { account: wallet.account }), [contracts, wallet.chain, send], "ymgpMgpCurve", 0n);
  const [rmgpMgpCurve] = useCachedUpdateable(() => send === 0n ? 0n : contracts[wallet.chain].cMGP.read.get_dy([1n, 0n, send], { account: wallet.account }), [contracts, wallet.chain, send], "rmgpMgpCurveAmount", 0n);
  const [rmgpYmgpCurve] = useCachedUpdateable(() => send === 0n ? 0n : contracts[wallet.chain].cMGP.read.get_dy([1n, 2n, send], { account: wallet.account }), [contracts, wallet.chain, send], "rmgpYmgpCurveAmount", 0n);
  const [ymgpMgpCurve] = useCachedUpdateable(() => send === 0n ? 0n : contracts[wallet.chain].cMGP.read.get_dy([2n, 0n, send], { account: wallet.account }), [contracts, wallet.chain, send], "ymgpMgpCurve", 0n);
  const [ymgpRmgpCurve] = useCachedUpdateable(() => send === 0n ? 0n : contracts[wallet.chain].cMGP.read.get_dy([2n, 1n, send], { account: wallet.account }), [contracts, wallet.chain, send], "ymgpRmgpCurve", 0n);
  return { send, setSend, mgpRmgpCurve, rmgpMgpCurve, rmgpYmgpCurve, ymgpRmgpCurve, ymgpMgpCurve, mgpYmgpCurve, mgpLP, setMGPLP, rmgpLP, setRMGPLP, ymgpLP, setYMGPLP };
};

// src/hooks/useContracts.ts
const import_react23 = __toESM(require_react(), 1);
const useContracts = ({ wallet }) => {
  const writeContracts = import_react23.useMemo(() => {
    if (!wallet.clients)
      return;
    return {
      56: {
        MGP: getContract({ address: contracts[56].MGP.address, abi: ABIs.MGP, client: wallet.clients[56] }),
        rMGP: getContract({ address: contracts[56].rMGP.address, abi: ABIs.rMGP, client: wallet.clients[56] }),
        yMGP: getContract({ address: contracts[56].yMGP.address, abi: ABIs.yMGP, client: wallet.clients[56] }),
        vMGP: getContract({ address: contracts[56].vMGP.address, abi: ABIs.vMGP, client: wallet.clients[56] }),
        cMGP: getContract({ address: contracts[56].cMGP.address, abi: ABIs.cMGP, client: wallet.clients[56] }),
        VLMGP: getContract({ address: contracts[56].VLMGP.address, abi: ABIs.VLMGP, client: wallet.clients[56] }),
        masterMGP: getContract({ address: contracts[56].MASTERMGP.address, abi: ABIs.MASTERMGP, client: wallet.clients[56] }),
        VLREWARDER: getContract({ address: contracts[56].VLREWARDER.address, abi: ABIs.VLREWARDER, client: wallet.clients[56] }),
        PNP: getContract({ address: contracts[56].PNP.address, abi: ABIs.PNP, client: wallet.clients[56] }),
        EGP: getContract({ address: contracts[56].EGP.address, abi: ABIs.EGP, client: wallet.clients[56] }),
        LTP: getContract({ address: contracts[56].LTP.address, abi: ABIs.LTP, client: wallet.clients[56] }),
        WETH: getContract({ address: contracts[56].WETH.address, abi: ABIs.WETH, client: wallet.clients[56] }),
        WBNB: getContract({ address: contracts[56].WBNB.address, abi: ABIs.WBNB, client: wallet.clients[56] }),
        MASTERMGP: getContract({ address: contracts[56].MASTERMGP.address, abi: ABIs.MASTERMGP, client: wallet.clients[56] }),
        CKP: getContract({ address: contracts[56].CKP.address, abi: ABIs.CKP, client: wallet.clients[56] }),
        ODOSRouter: getContract({ address: contracts[56].ODOSRouter.address, abi: ABIs.ODOSRouter, client: wallet.clients[56] })
      },
      42_161: {
        MGP: getContract({ address: contracts[42_161].MGP.address, abi: ABIs.MGP, client: wallet.clients[42_161] }),
        rMGP: getContract({ address: contracts[42_161].rMGP.address, abi: ABIs.rMGP, client: wallet.clients[42_161] }),
        yMGP: getContract({ address: contracts[42_161].yMGP.address, abi: ABIs.yMGP, client: wallet.clients[42_161] }),
        cMGP: getContract({ address: contracts[42_161].cMGP.address, abi: ABIs.cMGP, client: wallet.clients[42_161] }),
        VLMGP: getContract({ address: contracts[42_161].VLMGP.address, abi: ABIs.VLMGP, client: wallet.clients[42_161] }),
        masterMGP: getContract({ address: contracts[42_161].MASTERMGP.address, abi: ABIs.MASTERMGP, client: wallet.clients[42_161] }),
        VLREWARDER: getContract({ address: contracts[42_161].VLREWARDER.address, abi: ABIs.VLREWARDER, client: wallet.clients[42_161] }),
        PNP: getContract({ address: contracts[42_161].PNP.address, abi: ABIs.PNP, client: wallet.clients[42_161] }),
        EGP: getContract({ address: contracts[42_161].EGP.address, abi: ABIs.EGP, client: wallet.clients[42_161] }),
        LTP: getContract({ address: contracts[42_161].LTP.address, abi: ABIs.LTP, client: wallet.clients[42_161] }),
        WETH: getContract({ address: contracts[42_161].WETH.address, abi: ABIs.WETH, client: wallet.clients[42_161] }),
        WBNB: getContract({ address: contracts[42_161].WBNB.address, abi: ABIs.WBNB, client: wallet.clients[42_161] }),
        vMGP: getContract({ address: contracts[42_161].vMGP.address, abi: ABIs.vMGP, client: wallet.clients[42_161] }),
        MASTERMGP: getContract({ address: contracts[42_161].MASTERMGP.address, abi: ABIs.MASTERMGP, client: wallet.clients[42_161] }),
        CKP: getContract({ address: contracts[42_161].CKP.address, abi: ABIs.CKP, client: wallet.clients[42_161] }),
        ODOSRouter: getContract({ address: contracts[42_161].ODOSRouter.address, abi: ABIs.ODOSRouter, client: wallet.clients[42_161] })
      }
    };
  }, [wallet.clients]);
  return writeContracts;
};

// src/hooks/useExchangeRates.ts
const import_react24 = __toESM(require_react(), 1);
function useExchangeRates({ locked, wallet, supplies }) {
  const mintRMGP = import_react24.useMemo(() => {
    return supplies.rmgp === 0n ? 1 : Number(locked.reefiMGP) / Number(supplies.rmgp);
  }, [supplies.rmgp, locked.reefiMGP]);
  const [mgpRMGP] = useCachedUpdateable(async () => {
    return Number(await contracts[wallet.chain].cMGP.read.get_dy([0n, 1n, parseEther(0.000_01)], { account: wallet.account })) / Number(parseEther(0.000_01));
  }, [contracts, wallet.chain], "mgpRMGP curve", 0);
  const [mgpYMGP] = useCachedUpdateable(async () => {
    return Number(await contracts[wallet.chain].cMGP.read.get_dy([0n, 2n, parseEther(0.000_01)], { account: wallet.account })) / Number(parseEther(0.000_01));
  }, [contracts, wallet.chain], "mgpYMGP curve", 0);
  const [rmgpYMGP] = useCachedUpdateable(async () => {
    return Number(await contracts[wallet.chain].cMGP.read.get_dy([1n, 2n, parseEther(0.000_01)], { account: wallet.account })) / Number(parseEther(0.000_01));
  }, [contracts, wallet.chain], "rmgpYMGP curve", 0);
  const [rmgpMGP] = useCachedUpdateable(async () => {
    return Number(await contracts[wallet.chain].cMGP.read.get_dy([1n, 0n, parseEther(0.000_01)], { account: wallet.account })) / Number(parseEther(0.000_01));
  }, [contracts, wallet.chain], "rmgpMGP curve", 0);
  const [ymgpRMGP] = useCachedUpdateable(async () => {
    return Number(await contracts[wallet.chain].cMGP.read.get_dy([2n, 1n, parseEther(0.000_01)], { account: wallet.account })) / Number(parseEther(0.000_01));
  }, [contracts, wallet.chain], "ymgpRMGP curve", 0);
  const [ymgpMGP] = useCachedUpdateable(async () => {
    return Number(await contracts[wallet.chain].cMGP.read.get_dy([2n, 0n, parseEther(0.000_01)], { account: wallet.account })) / Number(parseEther(0.000_01));
  }, [contracts, wallet.chain], "ymgpMGP curve", 0);
  const vmgpMGP = 0.8;
  return { mintRMGP, curve: { mgpRMGP, mgpYMGP, rmgpYMGP, rmgpMGP, ymgpRMGP, ymgpMGP, vmgpMGP } };
}

// src/hooks/useLocked.ts
const import_react25 = __toESM(require_react(), 1);
const useLocked = ({ wallet }) => {
  const [reefiMGP, updateReefiMGP] = useCachedUpdateable(() => contracts[wallet.chain].VLMGP.read.getUserTotalLocked([contracts[wallet.chain].rMGP.address]), [contracts, wallet.account, wallet.chain], "reefiMGP locked", 0n);
  const [mgpBSC, updateMGPBSC] = useCachedUpdateable(() => contracts[56].VLMGP.read.totalLocked(), [contracts, wallet.account], "mgpBSC locked", 0n);
  const [mgpARB, updateMGPARB] = useCachedUpdateable(() => contracts[42_161].VLMGP.read.totalLocked(), [contracts, wallet.account], "mgpARB locked", 0n);
  const mgp = import_react25.useMemo(() => mgpBSC + mgpARB, [mgpBSC, mgpARB]);
  const updateMGP = () => {
    updateMGPBSC();
    updateMGPARB();
  };
  const [ymgp, updateYMGP] = useCachedUpdateable(() => contracts[wallet.chain].yMGP.read.totalLocked(), [contracts, wallet.account], "ymgp locked", 0n);
  const [userYMGP, updateUserYMGP] = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].yMGP.read.lockedBalances([wallet.account]), [contracts, wallet.account], "userYMGP locked", 0n);
  return { reefiMGP, ymgp, userYMGP, mgp, updateReefiMGP, updateYMGP, updateUserYMGP, updateMGP };
};

// src/hooks/usePrices.ts
const import_react26 = __toESM(require_react(), 1);
const usePrices = () => {
  const [prices, setPrices] = import_react26.useState({ MGP: 0, rMGP: 0, yMGP: 0, cMGP: 0, CKP: 0, PNP: 0, EGP: 0, LTP: 0, WETH: 0 });
  import_react26.useEffect(() => {
    (async () => {
      const res = await fetch("https://api.magpiexyz.io/getalltokenprice");
      res.json().then((body) => setPrices(body.data.AllPrice));
    })();
  }, []);
  return prices;
};

// src/hooks/useSupplies.ts
const useSupplies = ({ wallet }) => {
  const [mgp, updateMGP] = useCachedUpdateable(() => contracts[56].MGP.read.totalSupply(), [contracts], "mgp supply", 0n);
  const [rmgp, updateRMGP] = useCachedUpdateable(() => contracts[wallet.chain].rMGP.read.totalSupply(), [contracts, wallet.chain], "rmgp supply", 0n);
  const [ymgp, updateYMGP] = useCachedUpdateable(() => contracts[wallet.chain].yMGP.read.totalSupply(), [contracts, wallet.chain], "ymgp supply", 0n);
  const vmgp = parseEther(8.5);
  return { mgp, rmgp, ymgp, vmgp, updateMGP, updateRMGP, updateYMGP };
};

// src/hooks/useWithdraws.ts
const useWithdraws = ({ wallet }) => {
  const [userPendingWithdraws, updateUserPendingWithdraws] = useCachedUpdateable(() => wallet.account === undefined ? 0n : contracts[wallet.chain].rMGP.read.getUserPendingWithdraws([wallet.account]), [contracts, wallet.account, wallet.chain], "userPendingWithdraws", 0n);
  const [unsubmittedWithdraws, updateUnsubmittedWithdraws] = useCachedUpdateable(() => contracts[wallet.chain].rMGP.read.unsubmittedWithdraws(), [contracts, wallet.chain], "unsubmittedWithdraws", 0n);
  const [userWithdrawable, updateUserWithdrawable] = useCachedUpdateable(() => contracts[wallet.chain].rMGP.read.getUserWithdrawable(), [contracts, wallet.chain], "userWithdrawable", 0n);
  const [unlockSchedule, updateUnlockSchedule] = useCachedUpdateable(() => contracts[wallet.chain].VLMGP.read.getUserUnlockingSchedule([contracts[wallet.chain].rMGP.address]), [contracts, wallet.chain], "unlockSchedule", []);
  return { userPendingWithdraws, updateUserPendingWithdraws, unsubmittedWithdraws, updateUnsubmittedWithdraws, userWithdrawable, updateUserWithdrawable, unlockSchedule, updateUnlockSchedule };
};

// src/hooks/useRewards.ts
const import_react27 = __toESM(require_react(), 1);
const useRewards = ({ wallet, prices, balances, locked }) => {
  const [cmgpPoolAPY] = useCachedUpdateable(async () => {
    const res = await fetch("https://api.curve.finance/api/getVolumes/arbitrum");
    const curveBody = await res.json();
    for (const pool of curveBody.data.pools)
      if (pool.address === contracts[wallet.chain].cMGP.address)
        return pool.latestWeeklyApyPcent / 100;
    return 0;
  }, [wallet.chain], "cMGP Pool APY", 0);
  const [mgpAPR] = useCachedUpdateable(async () => {
    const res = await fetch(`https://dev.api.magpiexyz.io/streamReward?chainId=${wallet.chain}&rewarder=${contracts[wallet.chain].VLREWARDER.address}`);
    const body = await res.json();
    let apr = 0;
    for (const token of body.data.rewardTokenInfo)
      apr += token.apr;
    return apr;
  }, [], "MGP APR", 0);
  const cmgpAPY = import_react27.useMemo(() => {
    const yieldBearingUnderlyingPercent = Number(balances.rmgpCurve + balances.ymgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve + balances.ymgpCurve);
    const underlyingYield = yieldBearingUnderlyingPercent * aprToApy(mgpAPR) * 0.9;
    return underlyingYield + cmgpPoolAPY;
  }, [cmgpPoolAPY, mgpAPR, balances.mgpCurve, balances.rmgpCurve, balances.ymgpCurve]);
  const [unclaimedUserYield, updateUnclaimedUserYield] = useCachedUpdateable(() => contracts[wallet.chain].yMGP.read.unclaimedUserYield(), [contracts, wallet.chain], "unclaimedUserYield", 0n);
  const [compoundRMGPGas] = useCachedUpdateable(async () => {
    const [gasPrice, gas] = await Promise.all([publicClients[wallet.chain].getGasPrice(), wallet.account === undefined ? 0n : contracts[wallet.chain].rMGP.estimateGas.claim({ account: wallet.account })]);
    return gasPrice * gas;
  }, [wallet.account, wallet.chain], "Compound rMGP Gas", 0n);
  const [pendingRewards, updatePendingRewards] = useCachedUpdateable(async () => {
    const data = await contracts[wallet.chain].MASTERMGP.read.allPendingTokens([contracts[wallet.chain].VLMGP.address, contracts[wallet.chain].rMGP.address]);
    const newPendingRewards = { MGP: { address: contracts[wallet.chain].MGP.address, rewards: data[0] } };
    for (const index_ in data[2])
      if (data[2][index_] !== undefined && data[3][index_] !== undefined && data[1][index_] !== undefined)
        newPendingRewards[data[2][index_].replace("Bridged ", "").toUpperCase()] = { rewards: data[3][index_], address: data[1][index_] };
    return newPendingRewards;
  }, [wallet.chain], "Pending Rewards", {});
  const uncompoundedMGPYield = import_react27.useMemo(() => Object.keys(pendingRewards).length > 0 ? Object.keys(pendingRewards).map((symbol) => prices[symbol] * Number(formatEther(pendingRewards[symbol].rewards, decimals[symbol]))).reduce((sum, value) => sum + value, 0) / prices.MGP : 0, [pendingRewards, prices]);
  const estimatedCompoundGasFee = import_react27.useMemo(() => formatEther(compoundRMGPGas, decimals["WETH"]) * prices["WETH"], [wallet.chain, compoundRMGPGas, prices]);
  const lockedYmgpAPY = import_react27.useMemo(() => Number(locked.reefiMGP) * aprToApy(mgpAPR) * 0.05 / Number(locked.ymgp) + aprToApy(mgpAPR) * 0.9, [locked.reefiMGP, mgpAPR, locked.ymgp]);
  const estimatedCompoundAmount = useCachedUpdateable(async () => {
    if (wallet.clients === undefined || wallet.account === undefined)
      return;
    const simulation = await contracts[wallet.chain].rMGP.simulate.claim({ account: wallet.account, chain: wallet.clients[wallet.chain].chain });
    return simulation.result;
  }, [wallet.clients, wallet.chain, wallet.account], "estimatedCompoundReward");
  import_react27.useCallback(() => {
    const interval = setInterval(() => {
      updatePendingRewards();
    }, 30_000);
    return () => clearInterval(interval);
  }, [updatePendingRewards]);
  return { mgpAPR, pendingRewards, unclaimedUserYield, cmgpAPY, cmgpPoolAPY, uncompoundedMGPYield, estimatedCompoundGasFee, updatePendingRewards, updateUnclaimedUserYield, estimatedCompoundAmount, lockedYmgpAPY };
};

// src/contexts/GlobalContext.tsx
const jsx_development_runtime3 = __toESM(require_jsx_development_runtime(), 1);
const GlobalContext = import_react28.createContext(undefined);
const GlobalProvider = ({ children, page, setError, setNotification }) => {
  const wallet = useWallet({ setError });
  const balances = useBalances({ wallet });
  const allowances = useAllowances({ wallet });
  const supplies = useSupplies({ wallet });
  const prices = usePrices();
  const writeContracts = useContracts({ wallet });
  const locked = useLocked({ wallet });
  const amounts = useAmounts({ wallet });
  const withdraws = useWithdraws({ wallet });
  const exchangeRates = useExchangeRates({ wallet, locked, supplies });
  const rewards = useRewards({ wallet, prices, balances, locked });
  const actions = useActions({ page, setError, setNotification, wallet, balances, allowances, supplies, writeContracts, locked, amounts, withdraws, rewards });
  return /* @__PURE__ */ jsx_development_runtime3.jsxDEV(GlobalContext.Provider, {
    value: { wallet, balances, allowances, supplies, prices, writeContracts, locked, exchangeRates, amounts, rewards, withdraws, actions },
    children
  }, undefined, false, undefined, this);
};
const useGlobalContext = () => {
  const context = import_react28.useContext(GlobalContext);
  if (context === undefined)
    throw new Error("useGlobalContext must be used within a GlobalProvider");
  return context;
};

// src/components/TokenCards.tsx
const jsx_development_runtime4 = __toESM(require_jsx_development_runtime(), 1);
const TokenCards = import_react29.memo(() => {
  const { prices, supplies, locked, exchangeRates } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime4.jsxDEV("div", {
    className: "grid grid-cols-2 md:grid-cols-4 gap-4",
    children: [
      /* @__PURE__ */ jsx_development_runtime4.jsxDEV(TokenCard, {
        symbol: "MGP",
        color: "blue",
        price: prices.MGP,
        decimals: decimals.MGP,
        supply: supplies.mgp,
        locked: locked.mgp,
        description: "MGP is the underlying asset all derivatives rely on."
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime4.jsxDEV(TokenCard, {
        symbol: "rMGP",
        decimals: decimals.rMGP,
        supply: supplies.rmgp,
        underlying: locked.reefiMGP,
        marketRate: exchangeRates.curve.mgpRMGP,
        underlyingSymbol: "MGP",
        description: "rMGP earns auto compounding yield from locked MGP, while remaining liquid. rMGP can be converted back to MGP.",
        color: "green"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime4.jsxDEV(TokenCard, {
        symbol: "yMGP",
        decimals: decimals.yMGP,
        supply: supplies.ymgp + locked.ymgp,
        marketRate: exchangeRates.curve.rmgpYMGP,
        locked: locked.ymgp,
        underlying: supplies.ymgp + locked.ymgp,
        underlyingSymbol: "rMGP",
        description: "yMGP is backed 1:1 by rMGP but cannot be converted back to rMGP. 5% of protocol yield and withdrawals are distributed to locked yMGP paid in rMGP.",
        color: "green"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
TokenCards.displayName = "TokenCards";

// src/components/Header.tsx
const import_react32 = __toESM(require_react(), 1);

// src/components/TokenBalances.tsx
const import_react31 = __toESM(require_react(), 1);

// src/components/TokenBalance.tsx
const import_react30 = __toESM(require_react(), 1);
const jsx_development_runtime5 = __toESM(require_jsx_development_runtime(), 1);
const TokenBalance = import_react30.memo(({ symbol, balance, decimals: decimals2 }) => {
  return /* @__PURE__ */ jsx_development_runtime5.jsxDEV("div", {
    className: "bg-gray-700 rounded-lg px-3 py-2 text-sm",
    children: [
      symbol,
      ": ",
      formatEther(balance, decimals2).toFixed(2)
    ]
  }, undefined, true, undefined, this);
});
TokenBalance.displayName = "TokenBalance";

// src/components/TokenBalances.tsx
const jsx_development_runtime6 = __toESM(require_jsx_development_runtime(), 1);
const TokenBalances = import_react31.memo(() => {
  const { balances } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime6.jsxDEV("div", {
    className: "hidden md:flex items-center space-x-2",
    children: [
      /* @__PURE__ */ jsx_development_runtime6.jsxDEV(TokenBalance, {
        symbol: "MGP",
        balance: balances.MGP[0],
        decimals: decimals.MGP
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime6.jsxDEV(TokenBalance, {
        symbol: "rMGP",
        balance: balances.rMGP[0],
        decimals: decimals.rMGP
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime6.jsxDEV(TokenBalance, {
        symbol: "yMGP",
        balance: balances.yMGP[0],
        decimals: decimals.yMGP
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime6.jsxDEV(TokenBalance, {
        symbol: "cMGP",
        balance: balances.cMGP[0],
        decimals: decimals.cMGP
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
TokenBalances.displayName = "TokenBalance";

// src/components/Header.tsx
const jsx_development_runtime7 = __toESM(require_jsx_development_runtime(), 1);
const Header = import_react32.memo(() => {
  const { wallet } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime7.jsxDEV("div", {
    className: "sticky top-0 w-full bg-gray-800 p-4 flex justify-between items-center z-1",
    children: [
      /* @__PURE__ */ jsx_development_runtime7.jsxDEV("div", {
        className: "flex items-center gap-4",
        children: [
          /* @__PURE__ */ jsx_development_runtime7.jsxDEV("h1", {
            className: "text-xl font-bold",
            children: "REEFI"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime7.jsxDEV("p", {
            className: "hidden lg:block",
            children: "Refinance Magpie Yield and Governance"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      wallet.account === undefined ? /* @__PURE__ */ jsx_development_runtime7.jsxDEV("button", {
        type: "button",
        className: "bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg transition-colors",
        onClick: wallet.connectWallet,
        disabled: wallet.isConnecting,
        children: wallet.isConnecting ? "Connecting..." : "Connect Wallet"
      }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_development_runtime7.jsxDEV("div", {
        className: "flex items-center space-x-4",
        children: [
          /* @__PURE__ */ jsx_development_runtime7.jsxDEV(TokenBalances, {}, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime7.jsxDEV("div", {
            className: "bg-green-600/20 text-green-400 rounded-lg px-3 py-2 text-sm",
            children: wallet.ens ?? `${wallet.account.slice(0, 6)}...${wallet.account.slice(-4)}`
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime7.jsxDEV("select", {
            className: "bg-gray-800 border border-gray-700 rounded-lg px-3 py-2 text-sm text-white",
            value: wallet.chain,
            onChange: (e) => {
              wallet.setChain(Number(e.target.value));
              globalThis.localStorage.setItem("chain", String(e.target.value));
            },
            children: [
              /* @__PURE__ */ jsx_development_runtime7.jsxDEV("option", {
                value: "56",
                children: "BNB Chain"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime7.jsxDEV("option", {
                value: "42161",
                children: "Arbitrum"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
Header.displayName = "Header";

// src/components/ConversionRates.tsx
const import_react33 = __toESM(require_react(), 1);
const jsx_development_runtime8 = __toESM(require_jsx_development_runtime(), 1);
const ConversionRates = import_react33.memo(() => {
  const { exchangeRates } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime8.jsxDEV("div", {
    className: "bg-gray-800 p-3 rounded-xl border border-gray-700 flex flex-col items-center",
    children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("div", {
      className: "w-full max-w-256 flex flex-col items-center",
      children: [
        /* @__PURE__ */ jsx_development_runtime8.jsxDEV("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Conversion Rates"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_development_runtime8.jsxDEV("div", {
          className: "bg-gray-700/50 rounded-lg p-1 sm:p-4",
          children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("table", {
            children: [
              /* @__PURE__ */ jsx_development_runtime8.jsxDEV("thead", {
                children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("tr", {
                  children: [
                    /* @__PURE__ */ jsx_development_runtime8.jsxDEV("th", {
                      children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("h3", {
                        className: "text-lg font-bold mb-2"
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_development_runtime8.jsxDEV("th", {
                      children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("h3", {
                        className: "text-lg font-bold mb-2",
                        children: "Mint"
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_development_runtime8.jsxDEV("th", {
                      children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("h3", {
                        className: "text-lg font-bold mb-2",
                        children: "Market Buy"
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_development_runtime8.jsxDEV("th", {
                      children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("h3", {
                        className: "text-lg font-bold mb-2",
                        children: "Market Sell"
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_development_runtime8.jsxDEV("th", {
                      children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("h3", {
                        className: "text-lg font-bold mb-2",
                        children: "Burn"
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime8.jsxDEV("tbody", {
                children: [
                  /* @__PURE__ */ jsx_development_runtime8.jsxDEV("tr", {
                    children: [
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm font-bold",
                          children: "rMGP"
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: [
                            formatNumber(exchangeRates.mintRMGP, 4),
                            " MGP"
                          ]
                        }, undefined, true, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: [
                            formatNumber(exchangeRates.curve.mgpRMGP, 4),
                            " MGP"
                          ]
                        }, undefined, true, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: [
                            formatNumber(exchangeRates.curve.rmgpMGP, 4),
                            " MGP"
                          ]
                        }, undefined, true, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: [
                            formatNumber(exchangeRates.mintRMGP * 0.9, 4),
                            " MGP"
                          ]
                        }, undefined, true, undefined, this)
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_development_runtime8.jsxDEV("tr", {
                    children: [
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm font-bold",
                          children: "yMGP"
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: "1 rMGP"
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: [
                            formatNumber(exchangeRates.curve.rmgpYMGP, 4),
                            " rMGP"
                          ]
                        }, undefined, true, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: [
                            formatNumber(exchangeRates.curve.ymgpRMGP, 4),
                            " rMGP"
                          ]
                        }, undefined, true, undefined, this)
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime8.jsxDEV("td", {
                        children: /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
                          className: "mx-2 sm:mx-4 my-1 text-sm",
                          children: "0 rMGP"
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_development_runtime8.jsxDEV("ul", {
          className: "text-gray-400 text-xs mt-4",
          children: [
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("li", {
              children: [
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("span", {
                  className: "font-bold",
                  children: "Mint"
                }, undefined, false, undefined, this),
                ": The native rate Reefi will fulfill mints at"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("li", {
              children: [
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("span", {
                  className: "font-bold",
                  children: "Market Buy"
                }, undefined, false, undefined, this),
                ": The rate Curve will fulfill buys at"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("li", {
              children: [
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("span", {
                  className: "font-bold",
                  children: "Market Sell"
                }, undefined, false, undefined, this),
                ": The rate Curve will fulfill sells at"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("li", {
              children: [
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("span", {
                  className: "font-bold",
                  children: "Burn"
                }, undefined, false, undefined, this),
                ": The native rate Reefi will fulfill burns at"
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx_development_runtime8.jsxDEV("div", {
          className: "mt-6 bg-gray-900/80 rounded-xl p-4 border border-dashed border-green-700",
          children: [
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("h3", {
              className: "text-lg font-semibold mb-2 text-green-400",
              children: "Developer Tip: Arbitraging Conversion Rates"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
              className: "text-gray-300 text-sm mb-2",
              children: "rMGP can be minted for an only increasing amount of MGP and burnt for 90% the mint rate with a delay. When the market rate moves out of the mint-rate to burn-rate range, this can be arbitraged."
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("ul", {
              className: "list-disc list-inside text-gray-400 text-xs mb-2",
              children: [
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("li", {
                  children: [
                    "If rMGP becomes cheaper the burn rate, you can buy rMGP and natively burn it. This requires you to wait 60-120 days. ",
                    /* @__PURE__ */ jsx_development_runtime8.jsxDEV("strong", {
                      children: "If you don't want to wait the burn period"
                    }, undefined, false, undefined, this),
                    ", you can indirectly arbitrage by buying rMGP and waiting for others to burn."
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("li", {
                  children: "If rMGP becomes more expensive than the mint rate, you can mint rMGP and swap back to MGP."
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
              className: "list-disc list-inside text-gray-400 text-xs mb-2",
              children: "By arbitraging you help tighten the spread by maintaining the 90%-100% peg and increase liquidity through trading volume. This also increases revenue for cMGP holders through swap fees and for locked yMGP holders through withdrawal fees."
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime8.jsxDEV("p", {
              className: "text-gray-400 text-xs",
              children: [
                "Example: Use ",
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("span", {
                  className: "font-mono bg-gray-800 px-1 py-0.5 rounded",
                  children: "Viem"
                }, undefined, false, undefined, this),
                ", ",
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("span", {
                  className: "font-mono bg-gray-800 px-1 py-0.5 rounded",
                  children: "ethers.js"
                }, undefined, false, undefined, this),
                " or ",
                /* @__PURE__ */ jsx_development_runtime8.jsxDEV("span", {
                  className: "font-mono bg-gray-800 px-1 py-0.5 rounded",
                  children: "web3.js"
                }, undefined, false, undefined, this),
                " in a scheduled script to call the contract method and claim your reward automatically."
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
});
ConversionRates.displayName = "ConversionRates";

// src/components/Contracts.tsx
const import_react34 = __toESM(require_react(), 1);
const jsx_development_runtime9 = __toESM(require_jsx_development_runtime(), 1);
const Contracts = import_react34.memo(() => {
  const { wallet } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime9.jsxDEV("div", {
    className: "bg-gray-800 p-4 rounded-xl border border-gray-700 mb-6",
    children: [
      /* @__PURE__ */ jsx_development_runtime9.jsxDEV("h2", {
        className: "text-lg font-bold mb-2",
        children: "Contract Addresses"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime9.jsxDEV("div", {
        className: "grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-2 text-xs",
        children: Object.keys(contracts[wallet.chain]).map((contract) => /* @__PURE__ */ jsx_development_runtime9.jsxDEV("div", {
          children: [
            /* @__PURE__ */ jsx_development_runtime9.jsxDEV("span", {
              className: "font-semibold",
              children: [
                contract,
                ":"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_development_runtime9.jsxDEV("a", {
              href: `${publicClients[wallet.chain].chain.blockExplorers.default.url}/address/${contracts[wallet.chain][contract].address}`,
              className: "ml-2 break-all text-green-300",
              children: contracts[wallet.chain][contract].address
            }, undefined, false, undefined, this)
          ]
        }, contract, true, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
Contracts.displayName = "Contracts";

// src/components/ConnectWallet.tsx
const import_react35 = __toESM(require_react(), 1);
const jsx_development_runtime10 = __toESM(require_jsx_development_runtime(), 1);
const ConnectWallet = import_react35.memo(() => {
  const { wallet } = useGlobalContext();
  return wallet.connectRequired ? /* @__PURE__ */ jsx_development_runtime10.jsxDEV("div", {
    className: "absolute w-full h-full bg-black z-1 flex items-center justify-center",
    children: /* @__PURE__ */ jsx_development_runtime10.jsxDEV("div", {
      className: "bg-gray-700/50 p-10 rounded-lg text-center",
      children: [
        /* @__PURE__ */ jsx_development_runtime10.jsxDEV("p", {
          className: "text-xl mb-4",
          children: "Connect your wallet to use Reefi"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_development_runtime10.jsxDEV("button", {
          type: "button",
          className: "bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg transition-colors",
          onClick: wallet.connectWallet,
          disabled: wallet.isConnecting,
          children: wallet.isConnecting ? "Connecting..." : "Connect Wallet"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_development_runtime10.jsxDEV(jsx_development_runtime10.Fragment, {}, undefined, false, undefined, this);
});
ConnectWallet.displayName = "ConnectWallet";

// src/components/ErrorCard.tsx
const import_react36 = __toESM(require_react(), 1);
const jsx_development_runtime11 = __toESM(require_jsx_development_runtime(), 1);
const ErrorCard = ({ error, setError }) => {
  import_react36.useEffect(() => {
    if (error.length > 0)
      setTimeout(() => {
        setError("");
      }, 2000);
  }, [error, setError]);
  return error.length > 0 ? /* @__PURE__ */ jsx_development_runtime11.jsxDEV("div", {
    className: "absolute z-2 top-2 right-2",
    children: /* @__PURE__ */ jsx_development_runtime11.jsxDEV("div", {
      className: "bg-red-700 p-4 rounded-lg text-center",
      children: [
        /* @__PURE__ */ jsx_development_runtime11.jsxDEV("p", {
          className: "text-xl mb-2",
          children: "Error"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_development_runtime11.jsxDEV("p", {
          className: "text-sm",
          children: error
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_development_runtime11.jsxDEV(jsx_development_runtime11.Fragment, {}, undefined, false, undefined, this);
};

// src/pages/DepositPage.tsx
const import_react42 = __toESM(require_react(), 1);

// src/components/InfoCard.tsx
const import_react37 = __toESM(require_react(), 1);
const jsx_development_runtime12 = __toESM(require_jsx_development_runtime(), 1);
const InfoCard = import_react37.memo(({ text }) => {
  const lines = Array.isArray(text) ? text : [text];
  return /* @__PURE__ */ jsx_development_runtime12.jsxDEV("div", {
    className: "bg-indigo-900/20 border border-green-800/30 rounded-lg p-2 text-sm flex items-start w-full",
    children: [
      /* @__PURE__ */ jsx_development_runtime12.jsxDEV("div", {
        className: "p-1 bg-indigo-800/30 rounded-full mr-3 mt-0.5",
        children: /* @__PURE__ */ jsx_development_runtime12.jsxDEV("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "text-indigo-400",
          children: [
            /* @__PURE__ */ jsx_development_runtime12.jsxDEV("title", {
              children: "Info"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime12.jsxDEV("circle", {
              cx: "12",
              cy: "12",
              r: "10"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime12.jsxDEV("path", {
              d: "M12 16v-4"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime12.jsxDEV("path", {
              d: "M12 8h.01"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime12.jsxDEV("div", {
        children: [
          /* @__PURE__ */ jsx_development_runtime12.jsxDEV("span", {
            className: "font-medium text-indigo-300 text-sm",
            children: "About"
          }, undefined, false, undefined, this),
          lines.map((line, index_) => /* @__PURE__ */ jsx_development_runtime12.jsxDEV("p", {
            className: "text-gray-300 mt-0.5 text-xs",
            dangerouslySetInnerHTML: { __html: line }
          }, index_, false, undefined, this))
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
InfoCard.displayName = "InfoCard";

// src/components/Page.tsx
const jsx_development_runtime13 = __toESM(require_jsx_development_runtime(), 1);
const Page = ({ children, info }) => {
  return /* @__PURE__ */ jsx_development_runtime13.jsxDEV("div", {
    className: "flex flex-col items-center gap-8 mt-8 lg:gap-12 lg:mt-12 xl:gap-16 xl:mt-16",
    children: [
      /* @__PURE__ */ jsx_development_runtime13.jsxDEV("div", {
        className: "max-w-192 w-full",
        children
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime13.jsxDEV(InfoCard, {
        text: info
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// src/components/SwapToken.tsx
const import_react41 = __toESM(require_react(), 1);

// src/components/SwapInput.tsx
const import_react38 = __toESM(require_react(), 1);
const jsx_development_runtime14 = __toESM(require_jsx_development_runtime(), 1);
const SwapInput = import_react38.memo(({ label, selectedCoin, onCoinChange, balance, value, onChange, outputCoin, excludeCoins }) => {
  const { exchangeRates, prices } = useGlobalContext();
  const [isDropdownOpen, setIsDropdownOpen] = import_react38.useState(false);
  const dropdownReference = import_react38.useRef(null);
  excludeCoins = [outputCoin, "cMGP", ...excludeCoins];
  const availableCoins = Object.keys(coins).filter((coin) => !excludeCoins.includes(coin));
  import_react38.useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownReference.current && !dropdownReference.current.contains(event.target))
        setIsDropdownOpen(false);
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const estimatedOutput = () => {
    if (value === 0n)
      return;
    const inputAmount = formatEther(value, decimals[selectedCoin]);
    if (selectedCoin === "rMGP" && outputCoin === "yMGP")
      return;
    if (selectedCoin === "MGP" && outputCoin === "rMGP")
      return;
    if (selectedCoin === "yMGP" && outputCoin === "rMGP")
      return;
    else if (selectedCoin === "yMGP" && outputCoin === "MGP")
      return (inputAmount / exchangeRates.curve.ymgpMGP).toFixed(6) + " " + outputCoin;
    else if (outputCoin === "rMGP")
      return (inputAmount * prices[selectedCoin === "ETH" ? `W${selectedCoin}` : selectedCoin] / prices.MGP / exchangeRates.curve.mgpRMGP).toFixed(6) + " " + outputCoin;
    else
      return;
  };
  return /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
    className: "mb-4",
    children: [
      /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
        className: "flex justify-between items-center mb-1",
        children: [
          /* @__PURE__ */ jsx_development_runtime14.jsxDEV("h3", {
            className: "text-md font-medium",
            children: label
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
            className: "text-sm text-gray-400",
            children: [
              "Balance: ",
              formatEther(balance, decimals[selectedCoin]).toFixed(4),
              " ",
              selectedCoin
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
        className: "bg-gray-900 rounded-lg p-4 flex items-center justify-between",
        children: [
          /* @__PURE__ */ jsx_development_runtime14.jsxDEV("input", {
            type: "text",
            placeholder: "0",
            className: "bg-transparent outline-none text-xl w-3/4",
            value: value === 0n ? undefined : formatEther(value, decimals[selectedCoin]),
            onChange: (e) => onChange(BigInt(Math.round((Number.isNaN(Number.parseFloat(e.target.value)) ? 0 : Number.parseFloat(e.target.value)) * Number(10n ** BigInt(decimals[selectedCoin])))))
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
            className: "flex items-center space-x-2",
            children: [
              /* @__PURE__ */ jsx_development_runtime14.jsxDEV("button", {
                type: "button",
                className: "text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded",
                onClick: () => onChange(balance),
                children: "MAX"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
                className: "relative",
                ref: dropdownReference,
                children: [
                  /* @__PURE__ */ jsx_development_runtime14.jsxDEV("button", {
                    type: "button",
                    onClick: () => setIsDropdownOpen(!isDropdownOpen),
                    className: `rounded-md px-3 py-1 flex items-center cursor-pointer hover:opacity-90 transition-opacity ${coins[selectedCoin === "ETH" ? `W${selectedCoin}` : selectedCoin].bgColor}`,
                    children: [
                      /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
                        className: `w-5 h-5 rounded-full flex items-center justify-center mr-2 ${coins[selectedCoin === "ETH" ? `W${selectedCoin}` : selectedCoin].color}`,
                        children: selectedCoin[0]?.toUpperCase()
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime14.jsxDEV("span", {
                        className: "mr-2",
                        children: selectedCoin
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_development_runtime14.jsxDEV("svg", {
                        className: `w-4 h-4 transition-transform ${isDropdownOpen ? "rotate-180" : ""}`,
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24",
                        children: /* @__PURE__ */ jsx_development_runtime14.jsxDEV("path", {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M19 9l-7 7-7-7"
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  isDropdownOpen && /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
                    className: "absolute top-full mt-1 right-0 bg-gray-800 border border-gray-700 rounded-lg shadow-xl z-50 min-w-32",
                    children: availableCoins.map((coin) => /* @__PURE__ */ jsx_development_runtime14.jsxDEV(jsx_development_runtime14.Fragment, {
                      children: [
                        /* @__PURE__ */ jsx_development_runtime14.jsxDEV("button", {
                          className: `w-full px-3 py-2 flex items-center hover:bg-gray-700 transition-colors first:rounded-t-lg last:rounded-b-lg ${selectedCoin === coin ? "bg-gray-700" : ""}`,
                          type: "button",
                          onClick: () => {
                            onCoinChange(coin);
                            setIsDropdownOpen(false);
                          },
                          children: [
                            /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
                              className: `w-5 h-5 rounded-full flex items-center justify-center mr-2 ${coins[coin].color}`,
                              children: coin[0]?.toUpperCase()
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsx_development_runtime14.jsxDEV("span", {
                              children: coin
                            }, undefined, false, undefined, this)
                          ]
                        }, coin, true, undefined, this),
                        coin === "WETH" && /* @__PURE__ */ jsx_development_runtime14.jsxDEV("button", {
                          className: `w-full px-3 py-2 flex items-center hover:bg-gray-700 transition-colors first:rounded-t-lg last:rounded-b-lg ${selectedCoin === coin.replace("W", "") ? "bg-gray-700" : ""}`,
                          type: "button",
                          onClick: () => {
                            onCoinChange(coin.replace("W", ""));
                            setIsDropdownOpen(false);
                          },
                          children: [
                            /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
                              className: `w-5 h-5 rounded-full flex items-center justify-center mr-2 ${coins[coin].color}`,
                              children: coin[1]?.toUpperCase()
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsx_development_runtime14.jsxDEV("span", {
                              children: coin.replace("W", "")
                            }, undefined, false, undefined, this)
                          ]
                        }, coin, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this))
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      estimatedOutput() !== undefined && /* @__PURE__ */ jsx_development_runtime14.jsxDEV("div", {
        className: "mt-2 text-sm text-gray-400 text-center",
        children: [
          "",
          estimatedOutput()
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
SwapInput.displayName = "SwapInput";

// src/components/BuyOnCurve.tsx
const import_react40 = __toESM(require_react(), 1);

// src/components/TokenApproval.tsx
const import_react39 = __toESM(require_react(), 1);
const jsx_development_runtime15 = __toESM(require_jsx_development_runtime(), 1);
const TokenApproval = import_react39.memo(({ allowance, sendAmount, onApprove, tokenSymbol, curve = false, className = "w-full" }) => {
  const [approveInfinity, setApproveInfinity] = import_react39.useState(false);
  const [isApproving, setIsApproving] = import_react39.useState(false);
  const handleApprove = () => {
    setIsApproving(true);
    onApprove(approveInfinity);
  };
  if (allowance >= sendAmount)
    return;
  return /* @__PURE__ */ jsx_development_runtime15.jsxDEV("div", {
    className,
    children: [
      /* @__PURE__ */ jsx_development_runtime15.jsxDEV("div", {
        className: "flex items-center",
        children: [
          /* @__PURE__ */ jsx_development_runtime15.jsxDEV("input", {
            id: `approve-infinity-${tokenSymbol}`,
            type: "checkbox",
            className: "mr-2",
            checked: approveInfinity,
            onChange: () => setApproveInfinity((v) => !v)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime15.jsxDEV("label", {
            htmlFor: `approve-infinity-${tokenSymbol}`,
            className: "text-sm text-gray-300 select-none cursor-pointer",
            children: "Approve Infinity"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime15.jsxDEV("button", {
        type: "submit",
        className: "w-full py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min mt-2 disabled:opacity-50 disabled:cursor-not-allowed mb-2 text-xs md:text-md",
        onClick: handleApprove,
        disabled: isApproving,
        children: isApproving ? "Approving..." : `Approve ${tokenSymbol}${curve ? ` on Curve` : ""}`
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
TokenApproval.displayName = "TokenApproval";

// src/components/BuyOnCurve.tsx
const jsx_development_runtime16 = __toESM(require_jsx_development_runtime(), 1);
const BuyOnCurve = import_react40.memo(({ sendAmount, curveAmount, allowanceCurve, nativeRate, onApprove, buy, tokenASymbol, tokenBSymbol }) => {
  return /* @__PURE__ */ jsx_development_runtime16.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_development_runtime16.jsxDEV(TokenApproval, {
        sendAmount,
        allowance: allowanceCurve,
        onApprove,
        tokenSymbol: tokenASymbol,
        curve: true
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime16.jsxDEV("div", {
        className: "relative",
        children: [
          /* @__PURE__ */ jsx_development_runtime16.jsxDEV("button", {
            type: "submit",
            className: "w-full py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min text-xs md:text-md",
            onClick: buy,
            children: [
              "Buy on Curve (",
              formatEther(curveAmount).toFixed(4),
              " ",
              tokenBSymbol,
              ")"
            ]
          }, undefined, true, undefined, this),
          (() => {
            const directRate = formatEther(sendAmount) * nativeRate;
            const premiumDiscount = (formatEther(curveAmount) - directRate) / directRate * 100;
            const isPremium = premiumDiscount > 0;
            return Math.abs(premiumDiscount) >= 0.01 ? /* @__PURE__ */ jsx_development_runtime16.jsxDEV("span", {
              className: `absolute text-xs md:text-md -top-4 md:-top-2 right-2 text-xs px-2 py-1 rounded ${isPremium ? "bg-green-800/80 text-green-200" : "bg-red-800/80 text-red-200"}`,
              children: [
                isPremium ? "+" : "",
                premiumDiscount.toFixed(2),
                "%"
              ]
            }, undefined, true, undefined, this) : undefined;
          })()
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
BuyOnCurve.displayName = "BuyOnCurve";

// src/components/SwapButton.tsx
const jsx_development_runtime17 = __toESM(require_jsx_development_runtime(), 1);
const SwapButton = ({ buy, nativeSwap, label, tokenIn, tokenOut }) => {
  const { actions, allowances, amounts, wallet, exchangeRates } = useGlobalContext();
  if (tokenIn === "MGP" && tokenOut === "rMGP" || tokenIn === "rMGP" && tokenOut === "yMGP" || tokenIn === "rMGP" && tokenOut === "MGP") {
    const nativeRate = tokenIn === "MGP" && tokenOut === "rMGP" ? exchangeRates.mintRMGP : (tokenIn === "rMGP" && tokenOut === "MGP" ? exchangeRates.mintRMGP * 0.9 : 1);
    return /* @__PURE__ */ jsx_development_runtime17.jsxDEV("div", {
      className: "grid grid-cols-2 gap-2",
      children: [
        /* @__PURE__ */ jsx_development_runtime17.jsxDEV("div", {
          children: [
            tokenOut !== "MGP" && /* @__PURE__ */ jsx_development_runtime17.jsxDEV(TokenApproval, {
              sendAmount: amounts.send,
              allowance: allowances[tokenIn][0],
              onApprove: (infinity) => actions.approve(tokenOut, tokenIn, infinity),
              tokenSymbol: tokenIn
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime17.jsxDEV("button", {
              type: "submit",
              className: "py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min w-full text-xs md:text-md",
              onClick: nativeSwap,
              children: [
                label,
                " (",
                formatEther(BigInt(Number(amounts.send) * nativeRate)).toFixed(4),
                " ",
                tokenOut,
                ")"
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx_development_runtime17.jsxDEV(BuyOnCurve, {
          sendAmount: amounts.send,
          curveAmount: amounts.mgpRmgpCurve,
          allowanceCurve: allowances.curve[tokenIn][0],
          nativeRate,
          onApprove: (infinity) => actions.approve("cMGP", tokenIn, infinity),
          buy,
          tokenASymbol: tokenIn,
          tokenBSymbol: tokenOut
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  if (tokenIn === "MGP" && tokenOut === "yMGP")
    return /* @__PURE__ */ jsx_development_runtime17.jsxDEV(BuyOnCurve, {
      sendAmount: amounts.send,
      curveAmount: amounts.mgpYmgpCurve,
      allowanceCurve: allowances.curve[tokenIn][0],
      nativeRate: 1,
      onApprove: (infinity) => actions.approve("cMGP", tokenIn, infinity),
      buy: actions.convertMGP,
      tokenASymbol: tokenIn,
      tokenBSymbol: tokenOut
    }, undefined, false, undefined, this);
  if (tokenIn === "yMGP" && tokenOut === "rMGP")
    return /* @__PURE__ */ jsx_development_runtime17.jsxDEV(BuyOnCurve, {
      sendAmount: amounts.send,
      curveAmount: amounts.ymgpRmgpCurve,
      allowanceCurve: allowances.curve[tokenIn][0],
      nativeRate: 1,
      onApprove: (infinity) => actions.approve("cMGP", tokenIn, infinity),
      buy: actions.sellYMGP,
      tokenASymbol: tokenIn,
      tokenBSymbol: tokenOut
    }, undefined, false, undefined, this);
  if (tokenIn === "yMGP" && tokenOut === "MGP")
    return /* @__PURE__ */ jsx_development_runtime17.jsxDEV(BuyOnCurve, {
      sendAmount: amounts.send,
      curveAmount: amounts.ymgpMgpCurve,
      allowanceCurve: allowances.curve[tokenIn][0],
      nativeRate: 1 / exchangeRates.mintRMGP * 0.9,
      onApprove: (infinity) => actions.approve("cMGP", tokenIn, infinity),
      buy: actions.sellYMGP,
      tokenASymbol: tokenIn,
      tokenBSymbol: tokenOut
    }, undefined, false, undefined, this);
  if (tokenIn === "ETH")
    return /* @__PURE__ */ jsx_development_runtime17.jsxDEV("button", {
      type: "submit",
      className: "py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min w-full text-xs md:text-md",
      onClick: () => actions.mintWETH(),
      children: "Mint WETH"
    }, undefined, false, undefined, this);
  return /* @__PURE__ */ jsx_development_runtime17.jsxDEV(jsx_development_runtime17.Fragment, {
    children: [
      /* @__PURE__ */ jsx_development_runtime17.jsxDEV(TokenApproval, {
        sendAmount: amounts.send,
        allowance: allowances.odos[tokenIn][0],
        onApprove: (infinity) => actions.approve("ODOSRouter", tokenIn, infinity),
        tokenSymbol: tokenIn
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime17.jsxDEV("button", {
        type: "submit",
        className: "py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min w-full text-xs md:text-md",
        onClick: () => actions.swap(contracts[wallet.chain][tokenIn].address, contracts[wallet.chain].MGP.address),
        children: "Swap to MGP With Odos"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// src/components/SwapToken.tsx
const jsx_development_runtime18 = __toESM(require_jsx_development_runtime(), 1);
const SwapToken = ({ originalTokenIn, tokenOut, buy, nativeSwap, label, excludeCoins }) => {
  const { amounts, balances } = useGlobalContext();
  const [tokenIn, setTokenIn] = import_react41.useState(originalTokenIn);
  return /* @__PURE__ */ jsx_development_runtime18.jsxDEV(jsx_development_runtime18.Fragment, {
    children: [
      /* @__PURE__ */ jsx_development_runtime18.jsxDEV(SwapInput, {
        label: `Get ${tokenOut}`,
        selectedCoin: tokenIn,
        onCoinChange: setTokenIn,
        balance: balances[tokenIn][0],
        value: amounts.send,
        onChange: amounts.setSend,
        outputCoin: tokenOut,
        excludeCoins
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime18.jsxDEV(SwapButton, {
        buy,
        nativeSwap,
        label,
        tokenIn,
        tokenOut
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// src/pages/DepositPage.tsx
const jsx_development_runtime19 = __toESM(require_jsx_development_runtime(), 1);
const DepositPage = import_react42.memo(() => {
  const { actions, amounts, rewards } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime19.jsxDEV(Page, {
    info: "MGP can be converted to rMGP to earn auto compounded yield. Yield is accrued from vlMGP SubDAO Rewards.",
    children: [
      /* @__PURE__ */ jsx_development_runtime19.jsxDEV(SwapToken, {
        originalTokenIn: "MGP",
        tokenOut: "rMGP",
        curveAmount: amounts.mgpRmgpCurve,
        buy: actions.buyRMGP,
        label: "Mint",
        nativeSwap: actions.depositMGP,
        excludeCoins: ["CKP", "PNP", "EGP", "LTP", "WETH"]
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime19.jsxDEV("div", {
        className: "mt-4 text-sm text-gray-400",
        children: [
          /* @__PURE__ */ jsx_development_runtime19.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime19.jsxDEV("span", {
                children: "Original APR"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime19.jsxDEV("span", {
                children: [
                  Math.round(1e4 * rewards.mgpAPR) / 100,
                  "%"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime19.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime19.jsxDEV("span", {
                children: "Reward APY"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime19.jsxDEV("span", {
                children: [
                  Math.round(1e4 * aprToApy(rewards.mgpAPR) * 0.9) / 100,
                  "%"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
DepositPage.displayName = "DepositPage";

// src/pages/SupplyLiquidityPage.tsx
const import_react44 = __toESM(require_react(), 1);

// src/components/AmountInput.tsx
const import_react43 = __toESM(require_react(), 1);
const jsx_development_runtime20 = __toESM(require_jsx_development_runtime(), 1);
const AmountInput = import_react43.memo(({ label, balance, value, onChange, token, placeholder }) => {
  return /* @__PURE__ */ jsx_development_runtime20.jsxDEV("div", {
    className: "mb-4",
    children: [
      /* @__PURE__ */ jsx_development_runtime20.jsxDEV("div", {
        className: "flex justify-between items-center mb-1",
        children: [
          /* @__PURE__ */ jsx_development_runtime20.jsxDEV("h3", {
            className: "text-md font-medium",
            children: label
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime20.jsxDEV("div", {
            className: "text-sm text-gray-400",
            children: [
              "Balance: ",
              formatEther(balance, 18).toFixed(4),
              " ",
              token.symbol
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime20.jsxDEV("div", {
        className: "bg-gray-900 rounded-lg p-4 flex items-center justify-between",
        children: [
          /* @__PURE__ */ jsx_development_runtime20.jsxDEV("input", {
            type: "text",
            placeholder: placeholder ?? "0",
            className: "bg-transparent outline-none text-xl w-3/4",
            value: value === 0n ? undefined : formatEther(value),
            onChange: (e) => onChange(parseEther(Number.isNaN(Number.parseFloat(e.target.value)) ? 0 : Number.parseFloat(e.target.value)))
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime20.jsxDEV("div", {
            className: "flex items-center space-x-2",
            children: [
              /* @__PURE__ */ jsx_development_runtime20.jsxDEV("button", {
                type: "button",
                className: "text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded",
                onClick: () => onChange(balance),
                children: "MAX"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime20.jsxDEV("div", {
                className: `rounded-md px-3 py-1 flex items-center ${token.bgColor}`,
                children: [
                  /* @__PURE__ */ jsx_development_runtime20.jsxDEV("div", {
                    className: `w-5 h-5 rounded-full flex items-center justify-center mr-2 ${token.color}`,
                    children: token.symbol[0]?.toUpperCase()
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_development_runtime20.jsxDEV("span", {
                    children: token.symbol
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
AmountInput.displayName = "AmountInput";

// src/pages/SupplyLiquidityPage.tsx
const jsx_development_runtime21 = __toESM(require_jsx_development_runtime(), 1);
const SupplyLiquidityPage = import_react44.memo(() => {
  const { actions, amounts, balances } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime21.jsxDEV(Page, {
    info: 'Supply liquidity to the cMGP Curve pool (MGP/rMGP/yMGP). You can supply liquidity at any ratio of MGP:rMGP:yMGP, however it is recommended you match the targets to prevent slippage. To stake or withdraw liquidity, use <a href="https://www.curve.finance/dex/arbitrum/pools/factory-stable-ng-179/withdraw/" className="text-blue-400">Curve</a>.',
    children: [
      /* @__PURE__ */ jsx_development_runtime21.jsxDEV(AmountInput, {
        label: "Supply MGP",
        balance: balances.MGP[0],
        value: amounts.mgpLP,
        onChange: amounts.setMGPLP,
        token: { symbol: "MGP", color: "bg-blue-400", bgColor: "bg-blue-600" },
        placeholder: (() => {
          const mgpTarget = Number(balances.mgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve + balances.ymgpCurve);
          const totalRecommendedLP = amounts.rmgpLP === 0n ? Number(amounts.ymgpLP) / (Number(balances.ymgpCurve) / Number(balances.rmgpCurve + balances.ymgpCurve)) : (amounts.ymgpLP === 0n ? Number(amounts.rmgpLP) / (Number(balances.rmgpCurve) / Number(balances.rmgpCurve + balances.ymgpCurve)) : Number(amounts.rmgpLP + amounts.ymgpLP));
          return formatEther(BigInt(totalRecommendedLP * mgpTarget / (1 - mgpTarget))).toString();
        })()
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime21.jsxDEV("div", {
        className: "mb-4 text-sm text-gray-400 flex justify-between",
        children: [
          /* @__PURE__ */ jsx_development_runtime21.jsxDEV("span", {
            children: "Target"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime21.jsxDEV("span", {
            children: [
              (100 * Number(balances.mgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve + balances.ymgpCurve)).toFixed(0),
              "%"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime21.jsxDEV(AmountInput, {
        label: "Supply rMGP",
        balance: balances.rMGP[0],
        value: amounts.rmgpLP,
        onChange: amounts.setRMGPLP,
        token: { symbol: "rMGP", color: "bg-green-400", bgColor: "bg-green-600" },
        placeholder: (() => {
          const rmgpTarget = Number(balances.rmgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve + balances.ymgpCurve);
          const totalRecommendedLP = amounts.mgpLP === 0n ? Number(amounts.ymgpLP) / (Number(balances.ymgpCurve) / Number(balances.mgpCurve + balances.ymgpCurve)) : (amounts.ymgpLP === 0n ? Number(amounts.mgpLP) / (Number(balances.mgpCurve) / Number(balances.mgpCurve + balances.ymgpCurve)) : Number(amounts.mgpLP + amounts.ymgpLP));
          return formatEther(BigInt(totalRecommendedLP * rmgpTarget / (1 - rmgpTarget))).toString();
        })()
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime21.jsxDEV("div", {
        className: "mb-4 text-sm text-gray-400 flex justify-between",
        children: [
          /* @__PURE__ */ jsx_development_runtime21.jsxDEV("span", {
            children: "Target"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime21.jsxDEV("span", {
            children: [
              (100 * Number(balances.rmgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve + balances.ymgpCurve)).toFixed(0),
              "%"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime21.jsxDEV(AmountInput, {
        label: "Supply yMGP",
        balance: balances.yMGP[0],
        value: amounts.ymgpLP,
        onChange: amounts.setYMGPLP,
        token: { symbol: "yMGP", color: "bg-green-400", bgColor: "bg-green-600" },
        placeholder: (() => {
          const ymgpTarget = Number(balances.ymgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve + balances.ymgpCurve);
          const totalRecommendedLP = amounts.mgpLP === 0n ? Number(amounts.rmgpLP) / (Number(balances.rmgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve)) : (amounts.rmgpLP === 0n ? Number(amounts.mgpLP) / (Number(balances.mgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve)) : Number(amounts.mgpLP + amounts.rmgpLP));
          return formatEther(BigInt(totalRecommendedLP * ymgpTarget / (1 - ymgpTarget))).toString();
        })()
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime21.jsxDEV("div", {
        className: "mb-4 text-sm text-gray-400 flex justify-between",
        children: [
          /* @__PURE__ */ jsx_development_runtime21.jsxDEV("span", {
            children: "Target"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime21.jsxDEV("span", {
            children: [
              (100 * Number(balances.ymgpCurve) / Number(balances.mgpCurve + balances.rmgpCurve + balances.ymgpCurve)).toFixed(0),
              "%"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime21.jsxDEV("button", {
        type: "submit",
        className: "w-full py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min}",
        onClick: actions.supplyLiquidity,
        children: "Get cMGP"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
SupplyLiquidityPage.displayName = "SupplyLiquidityPage";

// src/pages/RedeemPage.tsx
const import_react45 = __toESM(require_react(), 1);
const jsx_development_runtime22 = __toESM(require_jsx_development_runtime(), 1);
const RedeemPage = import_react45.memo(() => {
  const { actions, amounts, exchangeRates, withdraws } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime22.jsxDEV(Page, {
    info: [
      "rMGP can be redeemed for the underlying MGP through the withdrawal queue for a 10% fee or swapped instantly at market rate via Curve.",
      "The withdrawal queue is processed directly through Magpie, therefore native withdrawals take at minimum 60 days.",
      "Only 6 withdrawals can be processed through Magpie at once. If all slots are used, withdrawals will be added to the queue once a new slot is made available making worst case withdrawal time 120 days.",
      "With the 10% withdrawal fee, rMGP depegs under 90% of the underlying value always recover as they can be arbitraged by people willing to wait for withdrawals to be processed.",
      "Half of the withdrawal fee (5% of withdrawal) is redistributed to yMGP holders as yield, with the other half sent to the Reefi treasury."
    ],
    children: [
      /* @__PURE__ */ jsx_development_runtime22.jsxDEV(SwapToken, {
        originalTokenIn: "rMGP",
        tokenOut: "MGP",
        curveAmount: amounts.rmgpMgpCurve,
        buy: actions.buyMGP,
        nativeSwap: actions.redeemRMGP,
        label: "Redeem via Queue",
        excludeCoins: ["CKP", "PNP", "EGP", "LTP", "WETH"]
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime22.jsxDEV("div", {
        className: "mt-4 text-sm text-gray-400 flex justify-between",
        children: [
          /* @__PURE__ */ jsx_development_runtime22.jsxDEV("span", {
            children: "Native Redemption Rate"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime22.jsxDEV("span", {
            children: [
              exchangeRates.curve.rmgpMGP,
              " MGP to rMGP"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      withdraws.userPendingWithdraws > 0n ? /* @__PURE__ */ jsx_development_runtime22.jsxDEV(jsx_development_runtime22.Fragment, {
        children: [
          /* @__PURE__ */ jsx_development_runtime22.jsxDEV("h3", {
            className: "text-md font-medium mt-4",
            children: "Pending Withdraws"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime22.jsxDEV("p", {
            children: [
              formatEther(withdraws.userPendingWithdraws, decimals.MGP),
              " MGP"
            ]
          }, undefined, true, undefined, this),
          withdraws.unlockSchedule[0] ? /* @__PURE__ */ jsx_development_runtime22.jsxDEV("p", {
            children: [
              "Unlock available in: ",
              formatTime(Number(withdraws.unlockSchedule[0].endTime) - Date.now() / 1000),
              " to ",
              formatTime(Number(withdraws.unlockSchedule.at(-1)?.endTime) + 60 * 60 * 24 * 60 - Date.now() / 1000)
            ]
          }, undefined, true, undefined, this) : /* @__PURE__ */ jsx_development_runtime22.jsxDEV("p", {
            children: "N/A"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this) : "",
      withdraws.userWithdrawable > 0n ? /* @__PURE__ */ jsx_development_runtime22.jsxDEV(jsx_development_runtime22.Fragment, {
        children: [
          /* @__PURE__ */ jsx_development_runtime22.jsxDEV("h3", {
            className: "text-md font-medium mt-4",
            children: "Available To Withdraw"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime22.jsxDEV("p", {
            children: [
              formatEther(withdraws.userWithdrawable, decimals.MGP),
              " MGP"
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime22.jsxDEV("button", {
            type: "submit",
            className: "w-full py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min}",
            onClick: actions.withdrawMGP,
            children: "Withdraw MGP"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this) : ""
    ]
  }, undefined, true, undefined, this);
});
RedeemPage.displayName = "RedeemPage";

// src/pages/LockPage.tsx
const import_react46 = __toESM(require_react(), 1);
const jsx_development_runtime23 = __toESM(require_jsx_development_runtime(), 1);
const LockPage = import_react46.memo(() => {
  const { actions, rewards, balances, amounts, locked } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime23.jsxDEV(Page, {
    info: [
      "yMGP can be locked to earn additional yield paid in rMGP. 5% of protocol yield and half of rMGP withdrawal fees are paid to yMGP lockers.",
      "Locked yMGP is able to vote on Magpie proposals with boosted vote power, controlling all of Reefi's vlMGP."
    ],
    children: [
      /* @__PURE__ */ jsx_development_runtime23.jsxDEV(AmountInput, {
        label: "Lock yMGP",
        token: { symbol: "yMGP", color: "bg-green-400", bgColor: "bg-green-600" },
        balance: balances.yMGP[0],
        value: amounts.send,
        onChange: amounts.setSend
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime23.jsxDEV("button", {
        type: "submit",
        className: "w-full py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min",
        onClick: actions.lockYMGP,
        children: "Lock yMGP"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime23.jsxDEV("div", {
        className: "mt-4 text-sm text-gray-400",
        children: [
          /* @__PURE__ */ jsx_development_runtime23.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime23.jsxDEV("span", {
                children: "Base APY"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime23.jsxDEV("span", {
                children: [
                  Math.round(1e4 * aprToApy(rewards.mgpAPR) * 0.9) / 100,
                  "%"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime23.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime23.jsxDEV("span", {
                children: "Additional APY"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime23.jsxDEV("span", {
                children: [
                  Math.round(1e4 * (Number(locked.reefiMGP) * aprToApy(rewards.mgpAPR) * 0.05 / Number(locked.ymgp))) / 100,
                  "%+"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime23.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime23.jsxDEV("span", {
                children: "Total APY"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime23.jsxDEV("span", {
                children: [
                  Math.round(1e4 * (Number(locked.reefiMGP) * aprToApy(rewards.mgpAPR) * 0.05 / Number(locked.ymgp) + aprToApy(rewards.mgpAPR) * 0.9)) / 100,
                  "%+"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
LockPage.displayName = "LockPage";

// src/pages/UnlockPage.tsx
const import_react47 = __toESM(require_react(), 1);
const jsx_development_runtime24 = __toESM(require_jsx_development_runtime(), 1);
const UnlockPage = import_react47.memo(() => {
  const { balances, amounts, actions } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime24.jsxDEV(Page, {
    info: ["yMGP can be unlocked instantly. Unlocked yMGP earns the underlying rMGP yield, but forfeits the additional yield."],
    children: [
      /* @__PURE__ */ jsx_development_runtime24.jsxDEV(AmountInput, {
        label: "Get yMGP",
        balance: balances.yMGP[0],
        value: amounts.send,
        onChange: amounts.setSend,
        token: { symbol: "yMGP", color: "bg-green-400", bgColor: "bg-green-600" }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime24.jsxDEV("button", {
        type: "submit",
        className: "w-full py-2 rounded-lg transition-colors bg-green-600 hover:bg-green-700 h-min",
        onClick: actions.unlockYMGP,
        children: "Unlock yMGP"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
UnlockPage.displayName = "UnlockPage";

// public/diagram.svg
const diagram_default = "./diagram-61tcs965.svg";

// src/components/Questions.tsx
const import_react48 = __toESM(require_react(), 1);
const jsx_development_runtime25 = __toESM(require_jsx_development_runtime(), 1);
const qaData = [
  {
    question: "What is Reefi and how does it work?",
    answer: [
      "Reefi is a protocol that refinances Magpie yield and governance by creating liquid derivatives of vlMGP (vote-locked MGP).",
      "It allows users to earn auto-compounding yield while maintaining liquidity and boosted yields, as well as boosted governance power."
    ]
  },
  {
    question: "What are the different tokens in the Reefi ecosystem?",
    answer: [
      "<strong>MGP</strong>: The base token from Magpie protocol",
      "<strong>rMGP</strong>: Liquid token representing locked MGP that earns auto-compounding yield (90% of vlMGP yield)",
      "<strong>yMGP</strong>: Token backed 1:1 by rMGP that can be locked for additional yield (5% of protocol yield + withdrawal fees)",
      "<strong>vMGP</strong>: Governance token backed by yMGP that controls Reefi's vlMGP voting power",
      "<strong>cMGP</strong>: Curve LP token for the MGP/rMGP/yMGP/vMGP pool that earns swap fees + underlying yield"
    ]
  },
  {
    question: "How do I earn yield with Reefi?",
    answer: [
      "1. <strong>Deposit MGP</strong>: Convert MGP to rMGP to earn 90% of vlMGP yield with auto-compounding",
      "2. <strong>Lock yMGP</strong>: Convert rMGP to yMGP and lock it to earn additional yield from protocol fees",
      "3. <strong>Provide Liquidity</strong>: Supply tokens to the Curve pool to earn swap fees plus underlying yield",
      "4. <strong>Compound Rewards</strong>: Anyone can compound pending yield and receive 1% as a reward"
    ]
  },
  {
    question: "What are the withdrawal mechanics for rMGP?",
    answer: [
      "rMGP can be redeemed for MGP in two ways:",
      "1. <strong>Instant Market Rate</strong>: Swap on Curve at current market price",
      "2. <strong>Native Redemption</strong>: Use the withdrawal queue for 90% of underlying value (10% fee) with 60-120 day wait time",
      "The 10% withdrawal fee is split: 5% to locked yMGP holders, 5% to Reefi treasury"
    ]
  },
  {
    question: "Why can't I withdraw yMGP?",
    answer: [
      "yMGP can't be natively redeemed for rMGP or MGP, instead it must be swapped at market rate.",
      "yMGP always trades at a discount, which allows for yMGP buyers to buy leveraged vlMGP yield.",
      "yMGP is designed for people dedicated to Magpie & Reefi, it rewards holders willing to commit with boosted yields and Reefi voting power.",
      "yMGP holders benefit the ecosystem by increasing permanent TVL, irreversibly boosting vMGP's voting power."
    ]
  },
  {
    question: "Why does rMGP have a withdrawal fee and delay?",
    answer: [
      "The withdrawal mechanics are inherited from Magpie's vlMGP system:",
      " vlMGP has a minimum 60-day unlock period",
      " Only 6 withdrawal slots are available at once, potentially extending wait time to 120 days in rare cases",
      " The 10% fee acts as incentive to yMGP holders and ensures rMGP maintains a 90%-100% peg to underlying MGP value",
      " This creates arbitrage opportunities for those willing to wait for withdrawals"
    ]
  },
  {
    question: "How does governance work in Reefi?",
    answer: [
      "<strong>vMGP Governance</strong>: vMGP holders control all of Reefi's vlMGP voting power on Magpie proposals",
      "<strong>Reefi DAO</strong>: Locked yMGP holders vote on Reefi protocol decisions",
      "<strong>Treasury</strong>: Receives 4% of compounded yield and 5% of withdrawal fees",
      "The core team has no initial token allocation as all tokens are backed by underlying MGP"
    ]
  },
  {
    question: "What are the risks of using Reefi?",
    answer: [
      "<strong>Smart Contract Risk</strong>: Reefi is in early beta and may contain bugs",
      "<strong>Depeg Risk</strong>: rMGP may trade below 90% of MGP value, though arbitrage mechanisms exist",
      "<strong>Liquidity Risk</strong>: Withdrawal queues may be full, extending redemption time",
      "<strong>Protocol Risk</strong>: Dependency on Magpie protocol and vlMGP mechanics"
    ]
  },
  {
    question: "How do I compound rewards and earn the 1% fee?",
    answer: [
      "Anyone can compound pending vlMGP yield by clicking 'Compound Yield' when it's profitable.",
      "The compounder receives 1% of all pending yield as yMGP tokens.",
      "This can be automated using scripts that monitor gas costs vs. rewards.",
      "Compounding benefits the entire protocol by reinvesting yield and maintaining peg stability."
    ]
  },
  {
    question: "What is the difference between minting and buying on Curve?",
    answer: [
      "<strong>Minting</strong>: Native protocol rate - rMGP minted at current backing ratio, yMGP always 1:1 with rMGP",
      "<strong>Curve Trading</strong>: Market-determined rates with potential premium/discount",
      "The UI shows percentage differences to help you choose the better option.",
      "Arbitrage opportunities exist when market rates deviate significantly from mint/burn rates."
    ]
  },
  {
    question: "Which chains does Reefi support?",
    answer: [
      "Reefi is deployed on:",
      " <strong>BNB Chain</strong>: BnB Smart Chain",
      " <strong>Arbitrum</strong>: Arbitrum One"
    ]
  },
  {
    question: "How are yields calculated and displayed?",
    answer: [
      "<strong>MGP APR</strong>: Base yield from vlMGP staking rewards",
      "<strong>rMGP APY</strong>: ~90% of MGP yield, auto-compounded",
      "<strong>Locked yMGP APY</strong>: Base auto-compound rMGP yield + additional yield from protocol fees",
      "<strong>cMGP APY</strong>: Weighted average of underlying token yields + Curve swap fees",
      "Yields are variable and depend on protocol usage and external factors."
    ]
  },
  {
    question: "Why is vMGP backed by yMGP instead of rMGP?",
    answer: [
      "vMGP strengthens yMGP's peg because it is minted 1:1 for yMGP that is burnt forever.",
      "By burning yMGP, the yield on locked yMGP increases as a smaller portion of yMGP is locked.",
      "It is important that yMGP receives this boost over rMGP, as rMGP is hard-pegged while yMGP isn't."
    ]
  }
];
const QASection = () => {
  const [openItems, setOpenItems] = import_react48.useState(new Set);
  const toggleItem = (index2) => {
    const newOpenItems = new Set(openItems);
    if (newOpenItems.has(index2))
      newOpenItems.delete(index2);
    else
      newOpenItems.add(index2);
    setOpenItems(newOpenItems);
  };
  return /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
    className: "bg-gray-800 p-3 rounded-xl border border-gray-700 flex justify-center",
    children: /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
      className: "max-w-256",
      children: [
        /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
          className: "mb-6 bg-gray-900/80 rounded-xl p-4 border border-dashed border-yellow-700",
          children: [
            /* @__PURE__ */ jsx_development_runtime25.jsxDEV("h3", {
              className: "text-lg font-semibold mb-2 text-yellow-400",
              children: " Important Notice"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime25.jsxDEV("p", {
              className: "text-gray-300 text-sm",
              children: [
                "Reefi is in ",
                /* @__PURE__ */ jsx_development_runtime25.jsxDEV("strong", {
                  children: "very early beta"
                }, undefined, false, undefined, this),
                ". Please only deposit small amounts that you can afford to lose. The protocol may contain unknown bugs and should be used with caution"
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx_development_runtime25.jsxDEV("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Frequently Asked Questions"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
          className: "space-y-2",
          children: qaData.map((item, index2) => /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
            className: "border border-gray-700 rounded-lg",
            children: [
              /* @__PURE__ */ jsx_development_runtime25.jsxDEV("button", {
                type: "button",
                className: "w-full text-left p-4 flex justify-between items-center hover:bg-gray-700/30 transition-colors",
                onClick: () => toggleItem(index2),
                children: [
                  /* @__PURE__ */ jsx_development_runtime25.jsxDEV("span", {
                    className: "font-medium text-gray-200",
                    children: item.question
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_development_runtime25.jsxDEV("svg", {
                    className: `w-5 h-5 text-gray-400 transform transition-transform ${openItems.has(index2) ? "rotate-180" : ""}`,
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: /* @__PURE__ */ jsx_development_runtime25.jsxDEV("path", {
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      strokeWidth: 2,
                      d: "M19 9l-7 7-7-7"
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              openItems.has(index2) && /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
                className: "px-4 pb-4",
                children: /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
                  className: "pt-2 border-t border-gray-700",
                  children: Array.isArray(item.answer) ? item.answer.map((paragraph, pIndex) => /* @__PURE__ */ jsx_development_runtime25.jsxDEV("p", {
                    className: "text-gray-300 text-sm mb-2 last:mb-0",
                    dangerouslySetInnerHTML: { __html: paragraph }
                  }, pIndex, false, undefined, this)) : /* @__PURE__ */ jsx_development_runtime25.jsxDEV("p", {
                    className: "text-gray-300 text-sm",
                    dangerouslySetInnerHTML: { __html: item.answer }
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, index2, true, undefined, this))
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_development_runtime25.jsxDEV("div", {
          className: "flex justify-center my-4",
          children: /* @__PURE__ */ jsx_development_runtime25.jsxDEV("img", {
            src: diagram_default,
            alt: "Diagram",
            className: "w-full"
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
};

// src/pages/ConvertPage.tsx
const import_react49 = __toESM(require_react(), 1);
const jsx_development_runtime26 = __toESM(require_jsx_development_runtime(), 1);
const ConvertPage = import_react49.memo(() => {
  const { actions, amounts } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime26.jsxDEV(Page, {
    info: "yMGP is backed 1:1 by rMGP. This process can not be undone. yMGP alone has no additional benefit over rMGP, it must be locked for boosted yield.",
    children: /* @__PURE__ */ jsx_development_runtime26.jsxDEV(SwapToken, {
      originalTokenIn: "rMGP",
      tokenOut: "yMGP",
      curveAmount: amounts.rmgpYmgpCurve,
      buy: actions.buyYMGP,
      nativeSwap: actions.depositRMGP,
      label: "Mint",
      excludeCoins: ["CKP", "EGP", "PNP", "LTP", "WETH"]
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
});
ConvertPage.displayName = "ConvertPage";

// src/components/YieldBadge.tsx
const import_react50 = __toESM(require_react(), 1);
const jsx_development_runtime27 = __toESM(require_jsx_development_runtime(), 1);
const Badge = import_react50.memo(({ title, value, breakdown }) => {
  return /* @__PURE__ */ jsx_development_runtime27.jsxDEV("div", {
    className: "text-sm bg-gray-700 rounded-lg px-3 py-1 flex items-center relative group cursor-help",
    title: `${title}: ${value}`,
    children: [
      /* @__PURE__ */ jsx_development_runtime27.jsxDEV("div", {
        className: "w-2 h-2 rounded-full bg-green-400 mr-2"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime27.jsxDEV("span", {
        children: [
          title,
          ": ",
          value
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime27.jsxDEV("div", {
        className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 text-xs text-white bg-black rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10",
        children: /* @__PURE__ */ jsx_development_runtime27.jsxDEV("div", {
          className: "space-y-1",
          children: breakdown.map((item, index2) => /* @__PURE__ */ jsx_development_runtime27.jsxDEV("div", {
            className: "flex justify-between gap-2",
            children: [
              /* @__PURE__ */ jsx_development_runtime27.jsxDEV("span", {
                children: [
                  item.asset,
                  ":"
                ]
              }, undefined, true, undefined, this),
              item.apy === undefined ? /* @__PURE__ */ jsx_development_runtime27.jsxDEV("span", {
                children: [
                  item.apr === "variable" ? "Variable" : `${Math.round(item.apr * 1e4) / 100}%`,
                  " APR"
                ]
              }, undefined, true, undefined, this) : /* @__PURE__ */ jsx_development_runtime27.jsxDEV("span", {
                children: [
                  item.apy === "variable" ? "Variable" : `${Math.round(item.apy * 1e4) / 100}%`,
                  " APY"
                ]
              }, undefined, true, undefined, this)
            ]
          }, index2, true, undefined, this))
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
Badge.displayName = "Badge";
const YieldBadge = import_react50.memo(({ asset, apy, apr, suffix, breakdown }) => {
  const yieldType = apy === undefined ? "APR" : "APY";
  const yieldValue = apy ?? apr;
  const percentage = Math.round((yieldValue === "variable" ? 0 : yieldValue) * 1e4) / 100;
  return /* @__PURE__ */ jsx_development_runtime27.jsxDEV(Badge, {
    title: `${asset} ${yieldType}`,
    value: `${percentage}%${suffix ?? ""}`,
    breakdown
  }, undefined, false, undefined, this);
});
YieldBadge.displayName = "YieldBadge";

// src/pages/CompoundYield.tsx
const import_react51 = __toESM(require_react(), 1);
const jsx_development_runtime28 = __toESM(require_jsx_development_runtime(), 1);
const CompoundYield = import_react51.memo(() => {
  const { actions, locked, prices, rewards, wallet } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime28.jsxDEV(Page, {
    info: "Pending yield (PNP, EGP, etc) gets converted to MGP and locked as vlMGP. The underlying backing of rMGP increases each time yields are compounded. 1% of MGP yield is sent to the compounder as yMGP, 4% sent to the treasury, and 5% to locked yMGP holders. By clicking the button below, you will receive 1% of the pending yield.",
    children: [
      /* @__PURE__ */ jsx_development_runtime28.jsxDEV("h3", {
        className: "text-md font-medium mb-1",
        children: "Uncompounded Yield"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
        className: "bg-gray-700/50 p-5 rounded-lg p-2",
        children: [
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
            className: "flex items-center justify-between mb-2",
            children: [
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("p", {
                className: "font-medium text-lg",
                children: [
                  formatNumber(rewards.uncompoundedMGPYield, 4),
                  " MGP"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("p", {
                className: "font-medium text-lg",
                children: [
                  "$",
                  formatNumber(rewards.uncompoundedMGPYield * prices.MGP, 4)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          Object.keys(rewards.pendingRewards).map((symbol) => /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
            className: "flex justify-between",
            children: [
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("p", {
                className: "font-small text-xs",
                children: [
                  formatNumber(formatEther(rewards.pendingRewards[symbol].rewards, decimals[symbol]), 4),
                  " ",
                  symbol
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("p", {
                className: "font-small text-xs",
                children: [
                  formatNumber(prices[symbol] * Number(formatEther(rewards.pendingRewards[symbol].rewards, decimals[symbol])) / prices.MGP, 4),
                  " MGP"
                ]
              }, undefined, true, undefined, this)
            ]
          }, symbol, true, undefined, this))
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime28.jsxDEV("button", {
        type: "button",
        className: "w-full mt-4 bg-green-600 hover:bg-green-700 py-3 rounded-lg transition-colors",
        onClick: actions.compoundRMGP,
        children: [
          "Compound Yield (Get ~",
          Number(rewards.estimatedCompoundAmount[0] ?? 0n) / 100,
          " yMGP)"
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
        className: "mt-4 text-sm text-gray-400",
        children: [
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                children: "Estimated Payout"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                children: [
                  "$",
                  formatNumber(rewards.uncompoundedMGPYield * prices.MGP * 0.01, 4)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                children: "Estimated Gas Fee"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                children: [
                  "$",
                  formatNumber(rewards.estimatedCompoundGasFee, 4)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                children: "Estimated Profit"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                className: `text-${rewards.uncompoundedMGPYield * prices.MGP * 0.01 > rewards.estimatedCompoundGasFee ? "green" : "red"}-400`,
                children: [
                  rewards.uncompoundedMGPYield * prices.MGP * 0.01 > rewards.estimatedCompoundGasFee ? "" : "-",
                  "$",
                  String(formatNumber(rewards.uncompoundedMGPYield * prices.MGP * 0.01 - rewards.estimatedCompoundGasFee, 6)).replace("-", "")
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          rewards.uncompoundedMGPYield * prices.MGP * 0.01 < rewards.estimatedCompoundGasFee && /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                children: "ETA Till Profitable"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                children: formatTime(rewards.estimatedCompoundGasFee / prices.MGP / (formatEther(BigInt(rewards.mgpAPR * Number(locked.reefiMGP)), decimals.MGP) / (365 * 24 * 60 * 60)))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime28.jsxDEV("div", {
        className: "mt-6 bg-gray-900/80 rounded-xl p-4 border border-dashed border-green-700",
        children: [
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("h3", {
            className: "text-lg font-semibold mb-2 text-green-400",
            children: "Developer Tip: Automate Compounding for Free Money"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("p", {
            className: "text-gray-300 text-sm mb-2",
            children: "Compounding vlMGP yield is critical to Reefi's function. Anyone can trigger a compound, which compounds everyone's pending yield. By doing so, you receive 1% of all pending yield. You can automate this process and earn rewards with no investment."
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("ul", {
            className: "list-disc list-inside text-gray-400 text-xs mb-2",
            children: [
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("li", {
                children: "Monitor the estimated profit and gas fee."
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("li", {
                children: [
                  "Trigger compounding when profit exceeds gas cost by calling ",
                  /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                    className: "font-mono bg-gray-800 px-1 py-0.5 rounded",
                    children: [
                      contracts[wallet.chain].rMGP.address,
                      ".claim()"
                    ]
                  }, undefined, true, undefined, this),
                  " whenever rewards are higher than gas fees."
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("li", {
                children: "This can be done using free cloud functions, GitHub Actions, or a serverless cron job."
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime28.jsxDEV("p", {
            className: "text-gray-400 text-xs",
            children: [
              "Example: Use ",
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                className: "font-mono bg-gray-800 px-1 py-0.5 rounded",
                children: "Viem"
              }, undefined, false, undefined, this),
              ", ",
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                className: "font-mono bg-gray-800 px-1 py-0.5 rounded",
                children: "ethers.js"
              }, undefined, false, undefined, this),
              " or ",
              /* @__PURE__ */ jsx_development_runtime28.jsxDEV("span", {
                className: "font-mono bg-gray-800 px-1 py-0.5 rounded",
                children: "web3.js"
              }, undefined, false, undefined, this),
              " in a scheduled script to call the contract method and claim your reward automatically."
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
CompoundYield.displayName = "CompoundYield";

// src/pages/ClaimYield.tsx
const import_react52 = __toESM(require_react(), 1);
const jsx_development_runtime29 = __toESM(require_jsx_development_runtime(), 1);
const ClaimYield = import_react52.memo(() => {
  const { actions, balances, locked, supplies, rewards } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime29.jsxDEV(Page, {
    info: ["Locked yMGP earns additional yield from the underlying vlMGP and from 5% of rMGP withdrawal.", "To claim pending MGP yield, compound rMGP yield."],
    children: [
      /* @__PURE__ */ jsx_development_runtime29.jsxDEV("h3", {
        className: "text-md font-medium mb-1",
        children: "Unclaimed Rewards"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime29.jsxDEV("div", {
        className: "bg-gray-700/50 rounded-lg p-4 flex justify-between",
        children: [
          /* @__PURE__ */ jsx_development_runtime29.jsxDEV("div", {
            className: "flex flex-col",
            children: [
              /* @__PURE__ */ jsx_development_runtime29.jsxDEV("p", {
                className: "font-medium text-lg",
                children: [
                  "You: ",
                  formatNumber(formatEther(rewards.unclaimedUserYield, decimals.yMGP), 4),
                  " rMGP"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime29.jsxDEV("p", {
                className: "text-sm text-gray-400",
                children: [
                  "+",
                  formatNumber(0.05 * rewards.uncompoundedMGPYield * (Number(locked.userYMGP) / Number(locked.ymgp)), 4),
                  " MGP"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime29.jsxDEV("div", {
            className: "flex flex-col text-right",
            children: [
              /* @__PURE__ */ jsx_development_runtime29.jsxDEV("p", {
                className: "font-medium text-lg",
                children: [
                  "Total: ",
                  formatNumber(formatEther(balances.ymgpHoldings - supplies.ymgp - locked.ymgp, decimals.yMGP), 4),
                  " rMGP"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime29.jsxDEV("p", {
                className: "text-sm text-gray-400",
                children: [
                  "+",
                  formatNumber(rewards.uncompoundedMGPYield * 0.05, 4),
                  " MGP"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime29.jsxDEV("button", {
        type: "button",
        className: "w-full mt-4 bg-green-600 hover:bg-green-700 py-3 rounded-lg transition-colors",
        onClick: actions.claimYMGPRewards,
        children: "Claim Rewards"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
ClaimYield.displayName = "ClaimYield";

// src/components/NotificationCard.tsx
const import_react53 = __toESM(require_react(), 1);
const jsx_development_runtime30 = __toESM(require_jsx_development_runtime(), 1);
const NotificationCard = ({ notification, setNotification }) => {
  import_react53.useEffect(() => {
    if (notification.length > 0)
      setTimeout(() => setNotification(""), 2000);
  }, [notification, setNotification]);
  return notification.length > 0 ? /* @__PURE__ */ jsx_development_runtime30.jsxDEV("div", {
    className: "absolute z-2 top-2 right-2",
    children: /* @__PURE__ */ jsx_development_runtime30.jsxDEV("div", {
      className: "bg-blue-700 p-4 rounded-lg text-center",
      children: /* @__PURE__ */ jsx_development_runtime30.jsxDEV("p", {
        className: "text-sm text-white",
        children: notification
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_development_runtime30.jsxDEV(jsx_development_runtime30.Fragment, {}, undefined, false, undefined, this);
};

// src/pages/GetMGPPage.tsx
const import_react54 = __toESM(require_react(), 1);
const jsx_development_runtime31 = __toESM(require_jsx_development_runtime(), 1);
const GetMGPPage = import_react54.memo(() => {
  const { actions, amounts, rewards } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime31.jsxDEV(Page, {
    info: "MGP is Magpie's governance token. All Reefi derivatives are built around MGP.",
    children: [
      /* @__PURE__ */ jsx_development_runtime31.jsxDEV(SwapToken, {
        originalTokenIn: "WETH",
        tokenOut: "MGP",
        curveAmount: amounts.mgpRmgpCurve,
        buy: actions.buyRMGP,
        excludeCoins: ["rMGP", "yMGP"]
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime31.jsxDEV("div", {
        className: "mt-4 text-sm text-gray-400",
        children: [
          /* @__PURE__ */ jsx_development_runtime31.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime31.jsxDEV("span", {
                children: "Original APR"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime31.jsxDEV("span", {
                children: "0%"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime31.jsxDEV("div", {
            className: "flex justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_development_runtime31.jsxDEV("span", {
                children: "Locked APR"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime31.jsxDEV("span", {
                children: [
                  Math.round(1e4 * rewards.mgpAPR) / 100,
                  "%"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
GetMGPPage.displayName = "GetMGPPage";

// src/pages/Features.tsx
const import_react55 = __toESM(require_react(), 1);
const jsx_development_runtime32 = __toESM(require_jsx_development_runtime(), 1);
const features = [
  {
    title: "Auto-Compounding Yield",
    description: "Earn 90% of vlMGP yield with automatic compounding through rMGP, maintaining liquidity while maximizing returns.",
    icon: "\uD83D\uDD04"
  },
  {
    title: "Liquid Derivatives",
    description: "Receive transferrable tokens for all MGP derivatives, combining liquidity with staking rewards.",
    icon: "\uD83D\uDCA7"
  },
  {
    title: "Enhanced Yields",
    description: "Lock yMGP to earn additional protocol fees (5% of withdrawals + vlMGP yield) on top of base rMGP returns.",
    icon: "\uD83D\uDCC8"
  },
  {
    title: "Boosted Governance Power",
    description: "Control Reefi's vlMGP voting power through vMGP tokens, amplifying your influence in Magpie governance decisions.",
    icon: "\uD83D\uDDF3"
  },
  {
    title: "Compound Rewards",
    description: "Earn 1% of all pending yield by compounding rewards for the entire protocol - automated income opportunity.",
    icon: "\uD83D\uDCB0"
  },
  {
    title: "Arbitrage Opportunities",
    description: "Profit from rate differences between native minting, Curve trading, and withdrawal mechanisms.",
    icon: ""
  },
  {
    title: "Cross-Chain Support",
    description: "Access Reefi on both BNB Chain and Arbitrum networks with seamless multi-chain functionality.",
    icon: "\uD83C\uDF10"
  },
  {
    title: "Risk Management",
    description: "Built-in peg stability mechanisms and withdrawal queues protect against depegging while maintaining liquidity.",
    icon: "\uD83D\uDEE1"
  }
];
const Features = import_react55.memo(() => {
  const { rewards, supplies, exchangeRates, prices } = useGlobalContext();
  const boost = (rewards.lockedYmgpAPY + rewards.mgpAPR) / rewards.mgpAPR - 1;
  return /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
    className: "flex flex-col items-center",
    children: [
      /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
        className: "grid grid-cols-2 md:grid-cols-4 gap-4 w-full mb-4",
        children: [
          /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
            className: "bg-gradient-to-r from-green-600/20 to-blue-600/20 p-3 rounded-lg text-center border border-green-600/30",
            children: [
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-lg font-bold text-green-400",
                children: [
                  (100 * aprToApy(rewards.mgpAPR)).toFixed(2),
                  "%+"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-xs text-gray-400",
                children: "Average Reefi Yield"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
            className: "bg-gradient-to-r from-green-600/20 to-blue-600/20 p-3 rounded-lg text-center border border-green-600/30",
            children: [
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-lg font-bold text-green-400",
                children: [
                  (100 * rewards.mgpAPR).toFixed(2),
                  "%"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-xs text-gray-400",
                children: "Base Magpie Yield"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
            className: "bg-gradient-to-r from-orange-600/20 to-red-600/20 p-3 rounded-lg text-center border border-orange-600/30",
            children: [
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-lg font-bold text-orange-400",
                children: [
                  boost.toFixed(2),
                  "x+"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-xs text-gray-400",
                children: "Yield Boost"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
            className: "bg-gradient-to-r from-green-600/20 to-blue-600/20 p-3 rounded-lg text-center border border-green-600/30",
            children: [
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-lg font-bold text-green-400",
                children: [
                  "$",
                  (1000 * prices.MGP * exchangeRates.curve.vmgpMGP * Number(supplies.vmgp) / Number(supplies.rmgp)).toFixed(2),
                  " vs $",
                  (1000 * prices.MGP).toFixed(2)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
                className: "text-xs text-gray-400",
                children: "Vote Price (1k Votes)"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
        className: "grid grid-cols-2 md:grid-cols-4 gap-3 w-full",
        children: features.map((feature, index2) => /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
          className: "bg-gray-900/50 p-3 rounded-lg border border-gray-700/50 hover:border-green-600/30 transition-colors",
          children: [
            /* @__PURE__ */ jsx_development_runtime32.jsxDEV("div", {
              className: "text-xl mb-2",
              children: feature.icon
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime32.jsxDEV("h3", {
              className: "text-sm font-semibold mb-1 text-green-400",
              children: feature.title
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_development_runtime32.jsxDEV("p", {
              className: "text-gray-300 text-xs leading-tight",
              children: feature.description
            }, undefined, false, undefined, this)
          ]
        }, index2, true, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
Features.displayName = "Features";

// src/App.tsx
const jsx_development_runtime33 = __toESM(require_jsx_development_runtime(), 1);
const AppContent = () => {
  const [page, setPage] = import_react56.useState("deposit");
  const [error, setError] = import_react56.useState("");
  const { balances, exchangeRates, locked, rewards } = useGlobalContext();
  return /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
    className: "flex h-screen bg-gray-900 text-white",
    children: [
      /* @__PURE__ */ jsx_development_runtime33.jsxDEV(ConnectWallet, {}, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime33.jsxDEV(ErrorCard, {
        error,
        setError
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
        className: "flex-grow overflow-auto",
        children: [
          /* @__PURE__ */ jsx_development_runtime33.jsxDEV(Header, {}, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
            className: "p-4 md:p-6 md:mx-16 lg:mx-22 xl:mx-28 flex flex-col gap-6",
            children: [
              /* @__PURE__ */ jsx_development_runtime33.jsxDEV(TokenCards, {}, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime33.jsxDEV(Features, {}, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                children: [
                  /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                    className: "bg-gray-800 p-3 border border-gray-700 rounded-t-xl",
                    children: [
                      /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                        className: "flex flex-col-reverse gap-2 lg:flex-row justify-between",
                        children: [
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                            className: "bg-gray-700 p-1 rounded-lg flex",
                            children: [
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "getMGP" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "getMGP" ? setPage(undefined) : setPage("getMGP"),
                                children: "Get MGP"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "deposit" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "deposit" ? setPage(undefined) : setPage("deposit"),
                                children: "Get rMGP"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "compoundRMGP" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "compoundRMGP" ? setPage(undefined) : setPage("compoundRMGP"),
                                children: "Compound Yield"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "redeem" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "redeem" ? setPage(undefined) : setPage("redeem"),
                                children: "Redeem rMGP"
                              }, undefined, false, undefined, this)
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                            className: "flex flex-row-reverse h-min",
                            children: /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                              className: "flex gap-1",
                              children: [
                                /* @__PURE__ */ jsx_development_runtime33.jsxDEV(YieldBadge, {
                                  asset: "MGP",
                                  apr: rewards.mgpAPR,
                                  breakdown: [{ asset: "Original vlMGP", apr: rewards.mgpAPR }]
                                }, undefined, false, undefined, this),
                                /* @__PURE__ */ jsx_development_runtime33.jsxDEV(YieldBadge, {
                                  asset: "rMGP",
                                  apy: aprToApy(rewards.mgpAPR) * 0.9,
                                  breakdown: [{ asset: "vlMGP", apy: aprToApy(rewards.mgpAPR) * 0.9 }]
                                }, undefined, false, undefined, this)
                              ]
                            }, undefined, true, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      page === "getMGP" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(GetMGPPage, {}, undefined, false, undefined, this),
                      page === "deposit" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(DepositPage, {}, undefined, false, undefined, this),
                      page === "compoundRMGP" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(CompoundYield, {}, undefined, false, undefined, this),
                      page === "redeem" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(RedeemPage, {}, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                    className: "bg-gray-800 p-3 border border-gray-700",
                    children: [
                      /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                        className: "flex flex-col-reverse gap-2 lg:flex-row justify-between",
                        children: [
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                            className: "bg-gray-700 p-1 rounded-lg flex",
                            children: [
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "convert" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "convert" ? setPage(undefined) : setPage("convert"),
                                children: "Get yMGP"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "lock" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "lock" ? setPage(undefined) : setPage("lock"),
                                children: "Lock yMGP"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "claimYMGP" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "claimYMGP" ? setPage(undefined) : setPage("claimYMGP"),
                                children: "Claim Yield"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                                type: "button",
                                className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "unlock" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                                onClick: () => page === "unlock" ? setPage(undefined) : setPage("unlock"),
                                children: "Unlock yMGP"
                              }, undefined, false, undefined, this)
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                            className: "flex flex-row-reverse h-min",
                            children: /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                              className: "flex gap-1",
                              children: [
                                /* @__PURE__ */ jsx_development_runtime33.jsxDEV(YieldBadge, {
                                  asset: "yMGP",
                                  apy: aprToApy(rewards.mgpAPR) * 0.9,
                                  breakdown: [{ asset: "rMGP", apy: aprToApy(rewards.mgpAPR) * 0.9 }]
                                }, undefined, false, undefined, this),
                                /* @__PURE__ */ jsx_development_runtime33.jsxDEV(YieldBadge, {
                                  asset: "Locked yMGP",
                                  apy: Number(locked.reefiMGP) * aprToApy(rewards.mgpAPR) * 0.05 / Number(locked.ymgp) + aprToApy(rewards.mgpAPR) * 0.9,
                                  suffix: "+",
                                  breakdown: [
                                    { asset: "Base vlMGP", apy: aprToApy(rewards.mgpAPR) * 0.9 },
                                    { asset: "Boosted vlMGP", apr: Number(locked.reefiMGP) * rewards.mgpAPR * 0.05 / Number(locked.ymgp) },
                                    { asset: "Withdrawals", apr: "variable" }
                                  ]
                                }, undefined, false, undefined, this)
                              ]
                            }, undefined, true, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      page === "convert" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(ConvertPage, {}, undefined, false, undefined, this),
                      page === "lock" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(LockPage, {}, undefined, false, undefined, this),
                      page === "claimYMGP" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(ClaimYield, {}, undefined, false, undefined, this),
                      page === "unlock" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(UnlockPage, {}, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                    className: "bg-gray-800 p-3 border border-gray-700",
                    children: /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                      className: "flex flex-col-reverse gap-2 lg:flex-row justify-between",
                      children: /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                        className: "bg-gray-700 p-1 rounded-lg flex",
                        children: [
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                            type: "button",
                            className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "buyVotes" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                            onClick: () => page === "buyVotes" ? setPage(undefined) : setPage("buyVotes"),
                            children: "Get vMGP"
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                            type: "button",
                            className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "vote" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                            onClick: () => page === "vote" ? setPage(undefined) : setPage("vote"),
                            children: "Vote"
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                    className: "bg-gray-800 p-3 border border-gray-700 rounded-b-xl",
                    children: [
                      /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                        className: "flex flex-col-reverse gap-2 lg:flex-row justify-between",
                        children: [
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                            className: "bg-gray-700 p-1 rounded-lg flex",
                            children: /* @__PURE__ */ jsx_development_runtime33.jsxDEV("button", {
                              type: "button",
                              className: `px-2 py-1 rounded-md transition-colors text-xs md:text-sm ${page === "supplyLiquidity" ? "bg-green-600 text-white" : "bg-transparent text-gray-400 hover:text-white"}`,
                              onClick: () => page === "supplyLiquidity" ? setPage(undefined) : setPage("supplyLiquidity"),
                              children: "Supply Liquidity"
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                            className: "flex flex-row-reverse h-min",
                            children: /* @__PURE__ */ jsx_development_runtime33.jsxDEV("div", {
                              className: "flex gap-1",
                              children: /* @__PURE__ */ jsx_development_runtime33.jsxDEV(YieldBadge, {
                                asset: "cMGP",
                                apy: rewards.cmgpAPY,
                                breakdown: [
                                  { asset: `${(100 * Number(balances.mgpCurve) * exchangeRates.mintRMGP / (Number(balances.mgpCurve) + Number(balances.rmgpCurve) * exchangeRates.mintRMGP + Number(balances.ymgpCurve) * exchangeRates.mintRMGP)).toFixed(2)}% MGP`, apy: 0 },
                                  { asset: `${(100 * Number(balances.rmgpCurve) * exchangeRates.mintRMGP / (Number(balances.mgpCurve) + Number(balances.rmgpCurve) * exchangeRates.mintRMGP + Number(balances.ymgpCurve) * exchangeRates.mintRMGP)).toFixed(2)}% rMGP`, apy: aprToApy(rewards.mgpAPR) * 0.9 },
                                  { asset: `${(100 * Number(balances.ymgpCurve) * exchangeRates.mintRMGP / (Number(balances.mgpCurve) + Number(balances.rmgpCurve) * exchangeRates.mintRMGP + Number(balances.ymgpCurve) * exchangeRates.mintRMGP)).toFixed(2)}% yMGP`, apy: aprToApy(rewards.mgpAPR) * 0.9 },
                                  { asset: "Swap Fees", apy: rewards.cmgpPoolAPY }
                                ]
                              }, undefined, false, undefined, this)
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      page === "supplyLiquidity" && /* @__PURE__ */ jsx_development_runtime33.jsxDEV(SupplyLiquidityPage, {}, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_development_runtime33.jsxDEV(QASection, {}, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime33.jsxDEV(ConversionRates, {}, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_development_runtime33.jsxDEV(Contracts, {}, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
const App = () => {
  const [error, setError] = import_react56.useState("");
  const [notification, setNotification] = import_react56.useState("");
  const [page] = import_react56.useState("deposit");
  return /* @__PURE__ */ jsx_development_runtime33.jsxDEV(GlobalProvider, {
    setError,
    setNotification,
    page,
    children: [
      /* @__PURE__ */ jsx_development_runtime33.jsxDEV(ErrorCard, {
        error,
        setError
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime33.jsxDEV(NotificationCard, {
        notification,
        setNotification
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_development_runtime33.jsxDEV(AppContent, {}, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
const App_default = App;

// src/index.tsx
const jsx_development_runtime34 = __toESM(require_jsx_development_runtime(), 1);
import_client.default.createRoot(document.querySelector("#root")).render(/* @__PURE__ */ jsx_development_runtime34.jsxDEV(import_react57.default.StrictMode, {
  children: /* @__PURE__ */ jsx_development_runtime34.jsxDEV(App_default, {}, undefined, false, undefined, this)
}, undefined, false, undefined, this));
